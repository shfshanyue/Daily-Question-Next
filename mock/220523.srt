1
00:00:00,166 --> 00:00:01,333
大家好我是山月

2
00:00:01,533 --> 00:00:04,199
今天面试一位5年工作经验的前端

3
00:00:04,200 --> 00:00:05,566
这是他的简历

4
00:00:06,100 --> 00:00:08,466
他最近一份工作是XXX方向的

5
00:00:08,466 --> 00:00:09,499
前端负责人

6
00:00:09,733 --> 00:00:10,966
喂你好

7
00:00:11,600 --> 00:00:14,300
喂你好

8
00:00:14,566 --> 00:00:17,099
这个交付 POC 60+ 什么产品

9
00:00:17,100 --> 00:00:18,066
这是什么意思

10
00:00:19,366 --> 00:00:23,333
啊是我们的产品需要做私有化交付

11
00:00:23,733 --> 00:00:26,133
呃也理解为一种萨斯平台

12
00:00:26,133 --> 00:00:27,499
然后做私有化交付

13
00:00:27,800 --> 00:00:29,966
呃然后这个是当时我们

14
00:00:31,500 --> 00:00:34,966
做了这个产品做前端管理的时候

15
00:00:34,966 --> 00:00:36,199
因为我们有

16
00:00:36,400 --> 00:00:38,566
公共的产品还有私有化的产品

17
00:00:38,733 --> 00:00:39,766
然后当时

18
00:00:40,066 --> 00:00:41,266
为了交付私有化

19
00:00:41,266 --> 00:00:43,133
因为公共产品和私有化产品

20
00:00:43,133 --> 00:00:45,066
是有功能的一些差异的

21
00:00:45,200 --> 00:00:47,333
嗯之前的管理方式

22
00:00:47,333 --> 00:00:50,166
是通过分支的方式进行管理

23
00:00:50,600 --> 00:00:52,066
但是分支管理非常混乱

24
00:00:52,066 --> 00:00:54,966
然后呢会导致一些研发效率的问题

25
00:00:54,966 --> 00:00:56,199
就比如说我们公

26
00:00:56,366 --> 00:00:58,966
公共方向的功能进行迭代了

27
00:00:58,966 --> 00:01:00,099
也要同步到

28
00:01:00,533 --> 00:01:02,533
呃私有方向的分支上

29
00:01:02,533 --> 00:01:04,266
然后会导致一些重复开发

30
00:01:04,266 --> 00:01:06,399
还有就是功能性的差异的问题

31
00:01:06,400 --> 00:01:07,533
一些产生

32
00:01:07,866 --> 00:01:09,066
而为了解决这个问题呢

33
00:01:09,066 --> 00:01:12,899
就是我们想在前端用一些同源的方式

34
00:01:12,900 --> 00:01:15,466
就是公共的产品和私有的产品进行

35
00:01:15,533 --> 00:01:17,566
同一套代码进行

36
00:01:18,000 --> 00:01:19,000
交付和部署

37
00:01:19,466 --> 00:01:21,533
然后就有了这个功能清单

38
00:01:21,533 --> 00:01:23,266
这个设想和想法

39
00:01:23,266 --> 00:01:25,499
就是前端会把所有的

40
00:01:26,100 --> 00:01:29,966
功能进行嗯就是梳理

41
00:01:29,966 --> 00:01:31,799
然后

42
00:01:31,800 --> 00:01:34,666
各个产品的进行功能清单的一个配置

43
00:01:34,666 --> 00:01:35,766
然后我们在

44
00:01:36,000 --> 00:01:38,300
我们前端项目打包的时候

45
00:01:38,300 --> 00:01:39,266
被拉到

46
00:01:39,466 --> 00:01:42,866
呃所有就是各个当前产品的那个的嗯

47
00:01:42,866 --> 00:01:44,966
当前环境的一个功能清单

48
00:01:45,000 --> 00:01:47,700
然后对这些清单呢

49
00:01:48,466 --> 00:01:51,766
清单上的功能进行一些就是

50
00:01:52,166 --> 00:01:53,966
裁剪

51
00:01:54,666 --> 00:01:57,966
对我们私有的私有的产品进行交付

52
00:01:57,966 --> 00:02:00,299
然后提升我们的交付效率

53
00:02:00,300 --> 00:02:01,333
还有研发效率

54
00:02:01,333 --> 00:02:02,999
然后我们之后的一些

55
00:02:03,333 --> 00:02:04,699
呃私有化的产品呢

56
00:02:04,700 --> 00:02:06,133
我们只需要通过

57
00:02:06,466 --> 00:02:07,566
啊我们的功能清

58
00:02:07,566 --> 00:02:08,666
功能清单平台

59
00:02:08,666 --> 00:02:10,766
进行一些功能清单的配置

60
00:02:10,933 --> 00:02:13,666
然后呃在我们的流水线上

61
00:02:14,000 --> 00:02:16,133
对当前的配置进行打包

62
00:02:16,133 --> 00:02:19,966
然后呃进行一些交付

63
00:02:21,866 --> 00:02:22,966
嗯行好

64
00:02:23,133 --> 00:02:26,199
嗯你们这是一个 sass tob 的一个平台

65
00:02:26,200 --> 00:02:29,966
然后是基于一些大客户要进行一些

66
00:02:30,200 --> 00:02:32,133
特性的私有化的交付是吧

67
00:02:32,133 --> 00:02:33,299
比如说有些大客户

68
00:02:33,300 --> 00:02:34,666
然后他们给的钱比较高

69
00:02:34,733 --> 00:02:37,266
然后你要给他开发一些定制化的功能

70
00:02:38,200 --> 00:02:39,000
是的

71
00:02:41,400 --> 00:02:42,200
嗯好

72
00:02:43,133 --> 00:02:49,533
[问]你们的这个功能配置清单是怎么维护的

73
00:02:50,333 --> 00:02:53,166
我们独立起了一个项目

74
00:02:53,166 --> 00:02:56,599
然后呢呃是一个共清单的平台

75
00:02:56,600 --> 00:02:58,766
然后在这个平台上呢我们会有

76
00:02:58,900 --> 00:03:01,000
呃我们的产品是比较多的

77
00:03:01,066 --> 00:03:02,333
然后会接入

78
00:03:02,566 --> 00:03:03,499
呃就是

79
00:03:03,500 --> 00:03:05,200
每个产品都可以接入我们这个平台

80
00:03:05,200 --> 00:03:06,266
然后在这个平台上

81
00:03:06,266 --> 00:03:08,299
去配置你当前产品的

82
00:03:08,300 --> 00:03:09,733
所需所有的功能

83
00:03:10,066 --> 00:03:11,299
然后呢

84
00:03:11,766 --> 00:03:13,899
我们每一个交付的项目

85
00:03:13,900 --> 00:03:15,866
就是还有一个项目维度的一个

86
00:03:15,933 --> 00:03:17,299
清单的管理

87
00:03:17,366 --> 00:03:18,333
然后这个项目呢

88
00:03:18,333 --> 00:03:20,333
就可以对针对于接入

89
00:03:20,333 --> 00:03:23,099
接入清单平台的这些产品呢

90
00:03:23,100 --> 00:03:24,066
进行一些配置

91
00:03:24,100 --> 00:03:25,200
就比如说我这个项目

92
00:03:25,700 --> 00:03:26,933
要 A 产品和 B 产品

93
00:03:26,933 --> 00:03:27,566
不要 C 产品

94
00:03:27,566 --> 00:03:29,733
我就需要配置 A 产品和 B 产品

95
00:03:29,733 --> 00:03:30,699
然后我在这个

96
00:03:30,733 --> 00:03:33,566
项目里面去配 A 产品和 B 产品的功能

97
00:03:33,666 --> 00:03:38,133
然后呃就是对功能然后呢

98
00:03:38,900 --> 00:03:39,700
这个清单平台呢

99
00:03:39,700 --> 00:03:41,933
最终会产生一个 json 文件

100
00:03:42,266 --> 00:03:42,466
对

101
00:03:42,466 --> 00:03:45,566
就是比如说 A 产品他配置了一些功能

102
00:03:45,566 --> 00:03:47,766
会产生一个大的一个 json 文件

103
00:03:47,766 --> 00:03:49,899
然后我们在 A 产品进行打包的时候

104
00:03:49,900 --> 00:03:52,666
会通过这个项目特有的一个 id

105
00:03:52,800 --> 00:03:53,666
然后去识别

106
00:03:53,666 --> 00:03:55,933
去拉到当前这个项目

107
00:03:56,000 --> 00:03:57,366
A 产品的功能清单

108
00:03:57,600 --> 00:03:59,800
然后我们在通过打包的时候

109
00:03:59,800 --> 00:04:01,333
我们通过 webpack 的插件

110
00:04:01,333 --> 00:04:03,099
然后把这个项目的功能清单

111
00:04:03,100 --> 00:04:04,266
注入到我们的

112
00:04:04,400 --> 00:04:05,800
生产的代码里

113
00:04:06,066 --> 00:04:08,099
然后呢就是

114
00:04:08,566 --> 00:04:10,099
交付给客户去使用

115
00:04:13,166 --> 00:04:14,466
嗯行好

116
00:04:19,933 --> 00:04:22,166
你们这个功能清单是一个平台

117
00:04:22,166 --> 00:04:25,766
它是对于多个项目都是可以这样做的

118
00:04:25,766 --> 00:04:28,066
然后每一个项目然后有多少个

119
00:04:28,266 --> 00:04:30,099
产品的一些特性

120
00:04:30,100 --> 00:04:30,900
是吧

121
00:04:31,600 --> 00:04:33,133
是的

122
00:04:33,166 --> 00:04:36,499
这听起来像是一个 feature flag 的云服务

123
00:04:37,200 --> 00:04:40,333
对是的他就是一个 feature flag 的云服务

124
00:04:40,366 --> 00:04:42,299
flag 然后他最终会产生一个对

125
00:04:42,366 --> 00:04:44,199
接送的一个文件啊

126
00:04:44,200 --> 00:04:46,133
这个飞车这个飞车 flag 服务

127
00:04:46,133 --> 00:04:48,999
然后是由你们其他团队去做的这个

128
00:04:49,200 --> 00:04:50,400
这个东西是吧

129
00:04:50,766 --> 00:04:52,599
啊就是我们团队自己做的啊

130
00:04:52,600 --> 00:04:54,466
你们团队自己去做的这个东西

131
00:04:54,800 --> 00:04:56,100
对对对哎

132
00:04:56,100 --> 00:04:57,333
那你们做的这个非常 flag

133
00:04:57,333 --> 00:04:59,733
这个服务是自己从头开始做的

134
00:04:59,733 --> 00:05:01,333
还是去基于一些开源

135
00:05:01,333 --> 00:05:03,066
的一些工具去做的

136
00:05:03,466 --> 00:05:04,599
自己从头开始做的

137
00:05:04,600 --> 00:05:06,800
然后我们

138
00:05:07,366 --> 00:05:08,299
数据库是 mysql

139
00:05:08,300 --> 00:05:11,666
然后我们的那个服务端呢是用的 koa

140
00:05:13,600 --> 00:05:15,166
然后在这里面有一个

141
00:05:15,200 --> 00:05:17,766
桌面多任务上传优化建立渲染进程

142
00:05:17,766 --> 00:05:19,966
与子进程的通讯频率

143
00:05:20,000 --> 00:05:21,800
[问]降低卡顿这个是怎么做的

144
00:05:24,166 --> 00:05:27,066
你们这个是一个桌面应用吗

145
00:05:27,733 --> 00:05:30,366
对一个桌面运用它主要的功能就是

146
00:05:30,366 --> 00:05:32,600
一些存储云的一些交互

147
00:05:33,466 --> 00:05:34,266
啊

148
00:05:35,033 --> 00:05:37,466
然后对一些桶(bucket)的一些交互的操作

149
00:05:37,466 --> 00:05:40,066
就比如上传文件下传文件然后管理统

150
00:05:40,266 --> 00:05:41,833
管理我们统的文件

151
00:05:42,166 --> 00:05:45,800
然后呢他因为这个桌面工具呢是嗯

152
00:05:45,800 --> 00:05:46,766
历史比较久了

153
00:05:46,766 --> 00:05:50,233
他是17年18年左右开发出来的

154
00:05:50,233 --> 00:05:52,033
然后有一些历史遗留的问题

155
00:05:52,066 --> 00:05:54,000
目前这个问题呢是这样的

156
00:05:54,033 --> 00:05:56,133
就是如果说用户在上传

157
00:05:57,566 --> 00:06:00,966
一些批量的小的文件的时候

158
00:06:00,966 --> 00:06:01,866
比如说上传

159
00:06:02,333 --> 00:06:03,766
像之前的那个场景

160
00:06:03,766 --> 00:06:06,433
是上传 200 个小文件的时候

161
00:06:06,433 --> 00:06:08,133
会界面会非常卡

162
00:06:08,333 --> 00:06:10,399
非常卡顿嗯

163
00:06:10,633 --> 00:06:12,399
核心问题呢是因为

164
00:06:13,400 --> 00:06:17,066
他把之前的逻辑呢是渲染进程

165
00:06:17,133 --> 00:06:18,533
他还开了一个紫禁城

166
00:06:18,533 --> 00:06:20,766
用来去上传文件和操作

167
00:06:20,833 --> 00:06:23,599
然后呢这个上传文件的紫禁城的会

168
00:06:23,666 --> 00:06:25,433
呃我们的上传任务

169
00:06:26,000 --> 00:06:28,266
更新状态会通知我们的渲染进程

170
00:06:28,366 --> 00:06:29,200
然后因为子进程

171
00:06:29,200 --> 00:06:31,200
和渲染进程的频繁通信呢

172
00:06:31,200 --> 00:06:34,600
导致这个渲染进程非常的卡

173
00:06:35,466 --> 00:06:37,166
导致这个渲染性能非常卡

174
00:06:37,233 --> 00:06:38,866
然后呢之前是

175
00:06:39,000 --> 00:06:41,600
他主要是这个任务状态变化了啊

176
00:06:41,600 --> 00:06:43,466
比如说他上传一个文件

177
00:06:43,466 --> 00:06:45,733
这个文件啊开始上传了

178
00:06:45,733 --> 00:06:47,633
然后呢还有就是开始的状态

179
00:06:47,633 --> 00:06:49,366
还有就中间上传速率

180
00:06:49,433 --> 00:06:50,566
比如说他上传

181
00:06:50,933 --> 00:06:53,833
这个文件当前的贷款是多少速率

182
00:06:53,866 --> 00:06:55,533
然后，还有就是他最终

183
00:06:55,733 --> 00:06:58,133
上传失败或者成功这些状态

184
00:06:58,233 --> 00:07:00,933
在遇到一些很小的一些文件的时候

185
00:07:01,166 --> 00:07:02,466
比如说我上传一个文件夹

186
00:07:02,466 --> 00:07:03,766
这个文件夹里面有非常多

187
00:07:03,766 --> 00:07:05,033
非常多的一些小文件

188
00:07:05,033 --> 00:07:07,133
然后他会频繁的上传成功

189
00:07:07,133 --> 00:07:07,766
因为

190
00:07:07,766 --> 00:07:09,800
呃然后会频繁的通知我们的渲染进程

191
00:07:09,800 --> 00:07:13,866
就会导致渲染进程就会卡顿

192
00:07:13,866 --> 00:07:15,033
为了解决这个问题呢

193
00:07:15,033 --> 00:07:16,733
就是一是我们去

194
00:07:17,533 --> 00:07:19,533
定时的

195
00:07:20,033 --> 00:07:22,433
收集我们当前就是任务的状态

196
00:07:22,433 --> 00:07:23,933
然后定时的去通知

197
00:07:24,133 --> 00:07:25,766
然后降低这个

198
00:07:25,800 --> 00:07:27,833
子进程与渲染进程的通讯频率

199
00:07:28,533 --> 00:07:31,066
然后不再是

200
00:07:31,200 --> 00:07:34,233
每一个任务改变状态了就会去通知

201
00:07:34,233 --> 00:07:36,133
而是批量地去通知我们

202
00:07:36,133 --> 00:07:38,766
每当前这些任务的状态

203
00:07:39,166 --> 00:07:40,266
然后减少这个

204
00:07:40,266 --> 00:07:42,233
紫禁城和渲染进城的一些

205
00:07:42,766 --> 00:07:43,600
交互的频率

206
00:07:43,600 --> 00:07:46,266
然后提升他的渲染的一个

207
00:07:48,000 --> 00:07:49,400
倒立吧嗯

208
00:07:50,466 --> 00:07:52,000
嗯行好

209
00:07:53,800 --> 00:07:55,000
嗯对

210
00:07:58,066 --> 00:07:59,833
其实解决高病发问题的时候

211
00:07:59,833 --> 00:08:01,399
也有一个和这个很像

212
00:08:01,400 --> 00:08:03,933
就是批量写缓存 (最后特定的时间点触发再写数据库)

213
00:08:06,600 --> 00:08:08,933
叫 Write Behind 的一个策略好像是这样

214
00:08:09,833 --> 00:08:11,433
啊这个我了解一下

215
00:08:11,666 --> 00:08:14,933
那行好然后下下来有一个啊对

216
00:08:15,033 --> 00:08:17,233
刚才宣染建成与紫建成通讯频率

217
00:08:17,400 --> 00:08:19,800
渲染进程与子进程是如何通讯的

218
00:08:21,733 --> 00:08:25,999
呃他是通过弄的的紫金城去交互的

219
00:08:30,133 --> 00:08:35,399
[问] Docker 容器化去标准化交付是什么意思

220
00:08:36,200 --> 00:08:38,600
这个也是我们一些客户的

221
00:08:38,766 --> 00:08:41,533
一些需要这个桌面工具的

222
00:08:41,800 --> 00:08:44,466
呃桌面工具的版本然后呢

223
00:08:44,866 --> 00:08:47,233
目前如果说我们把

224
00:08:47,933 --> 00:08:49,666
首先是他这样一些场景啊

225
00:08:49,666 --> 00:08:51,133
首先他一个这个工具

226
00:08:51,133 --> 00:08:53,033
之前呢是针对我们

227
00:08:53,366 --> 00:08:56,266
嗯公共产品的一些呃交付

228
00:08:56,400 --> 00:08:57,733
只对我们公共个客户

229
00:08:57,733 --> 00:08:58,199
然后呢

230
00:08:58,200 --> 00:09:00,600
现在有一些就是私有化的一些需求

231
00:09:00,833 --> 00:09:01,966
啊主要是私有化需求

232
00:09:01,966 --> 00:09:04,166
需要针对性的修改我们

233
00:09:05,200 --> 00:09:08,266
我们那个呃桌面的嗯

234
00:09:08,833 --> 00:09:10,433
比如说 logo 呀然后名称啊

235
00:09:10,433 --> 00:09:13,266
还有就是它里面的一些配置项啊

236
00:09:13,266 --> 00:09:15,400
这些是在

237
00:09:15,400 --> 00:09:18,166
当前的需求是没当前的这个

238
00:09:18,433 --> 00:09:19,933
黄金是没法满足的

239
00:09:19,966 --> 00:09:21,066
然后呢我们

240
00:09:21,533 --> 00:09:23,733
之前的交付流程是本地编译的

241
00:09:23,733 --> 00:09:24,933
本地打包的啊

242
00:09:24,933 --> 00:09:26,166
并没有走流水线

243
00:09:26,166 --> 00:09:29,733
然后我把它就是

244
00:09:30,033 --> 00:09:31,999
把这个桌面工具，接入了我们

245
00:09:32,233 --> 00:09:34,266
我们云上的一个流水线

246
00:09:34,666 --> 00:09:37,000
然后去进行的一些打包

247
00:09:37,000 --> 00:09:39,533
然后把里面的所有的

248
00:09:39,733 --> 00:09:41,466
像 logo 呀、像配置文件啊配置项

249
00:09:42,133 --> 00:09:43,733
我们进行了一些拆分

250
00:09:44,066 --> 00:09:45,600
抽离然后可以

251
00:09:46,066 --> 00:09:48,433
通过配置文件来进行针对性

252
00:09:48,433 --> 00:09:51,133
针对环境性的这种打包交付

253
00:09:51,266 --> 00:09:52,600
还有一个问题就是

254
00:09:52,600 --> 00:09:53,800
为什么要做容器化呢

255
00:09:53,800 --> 00:09:55,266
就是

256
00:09:56,400 --> 00:09:59,066
一是我们当前这个桌面工具

257
00:09:59,066 --> 00:10:00,000
我们交付了客户

258
00:10:00,000 --> 00:10:03,000
客户这边呃可以进行一些下载吗

259
00:10:03,000 --> 00:10:04,533
如果说放在我们

260
00:10:04,533 --> 00:10:06,166
静态服务器上可以进行下载

261
00:10:06,200 --> 00:10:06,666
但是呢

262
00:10:06,666 --> 00:10:09,333
就是如果说我们后续进行更新的话

263
00:10:09,666 --> 00:10:12,733
呃用户下载到本地的呃桌面工具没有

264
00:10:12,733 --> 00:10:14,066
没有这个更新的服务

265
00:10:14,066 --> 00:10:15,633
是没有办法进行更新的

266
00:10:15,633 --> 00:10:17,666
然后容器化里面提

267
00:10:17,666 --> 00:10:18,766
供了一个

268
00:10:19,200 --> 00:10:21,433
呃桌面工具的一个更新服务

269
00:10:21,600 --> 00:10:25,066
然后呢我们部署在用户的机器上

270
00:10:25,066 --> 00:10:27,066
然后用户可以在每次

271
00:10:27,566 --> 00:10:28,866
打开这个工具的时候

272
00:10:28,866 --> 00:10:31,033
会进行一些更新的一些检查

273
00:10:31,833 --> 00:10:33,033
然后主要是为了

274
00:10:34,033 --> 00:10:36,733
给这个桌面工具一个更新服务

275
00:10:36,733 --> 00:10:38,933
然后做的一些容器化的交付

276
00:10:39,600 --> 00:10:41,600
嗯那你们交付的时候

277
00:10:41,600 --> 00:10:43,466
除了交付这个桌面端的应用

278
00:10:43,466 --> 00:10:44,400
还有交付什么内容

279
00:10:44,400 --> 00:10:45,833
是不是还要交付一个 sever

280
00:10:46,000 --> 00:10:47,133
一个后端的一个内容

281
00:10:47,133 --> 00:10:48,733
还有一些数据库的那些配置

282
00:10:50,733 --> 00:10:53,399
这个容器化的主要是

283
00:10:53,733 --> 00:10:56,333
用的一个 linux 镜像啊

284
00:10:56,333 --> 00:10:58,199
不是，nginx 镜像做的

285
00:10:59,600 --> 00:11:02,633
然后他是没有什么后端的

286
00:11:03,000 --> 00:11:05,266
嗯是后端的

287
00:11:05,333 --> 00:11:06,133
后端的容器

288
00:11:06,133 --> 00:11:08,133
容器进项就不是我们前端的进项

289
00:11:08,400 --> 00:11:10,633
像我们之前所有的嗯

290
00:11:10,633 --> 00:11:11,366
刚才说的

291
00:11:11,366 --> 00:11:13,466
我们清单平台交付的一些云产品啊

292
00:11:13,466 --> 00:11:16,333
都是做的容器化打包的交付

293
00:11:17,200 --> 00:11:18,766
那你们这个容器化打包交付

294
00:11:18,766 --> 00:11:20,333
就是说你们容器化

295
00:11:20,333 --> 00:11:22,266
只不过是把打包的这个过程中

296
00:11:22,266 --> 00:11:24,633
交给交给你们的 CICD

297
00:11:24,633 --> 00:11:26,833
或者交给你们的这些 docker 去做

298
00:11:28,066 --> 00:11:29,266
CICD 是另一个了

299
00:11:29,266 --> 00:11:31,966
CICD 是就是打包之前

300
00:11:32,200 --> 00:11:34,233
交付之前的工作

301
00:11:34,233 --> 00:11:36,666
他交就是 CICD 会产出一个

302
00:11:36,800 --> 00:11:39,000
我们桌面端是一些安装包

303
00:11:39,166 --> 00:11:40,600
然后我们这个安装包呢

304
00:11:40,600 --> 00:11:42,766
会走我们另一个

305
00:11:43,566 --> 00:11:45,566
另一个就是容器化的一个

306
00:11:45,800 --> 00:11:47,833
打包的一个 csd

307
00:11:48,200 --> 00:11:50,166
然后打出来一个刀客

308
00:11:50,166 --> 00:11:53,000
刀客进项呢我们再去给用户进行交付

309
00:11:54,033 --> 00:11:54,466
嗯

310
00:11:54,466 --> 00:11:57,133
你们给用户交付的是一个 docker 镜像

311
00:11:57,133 --> 00:12:00,066
还是最后是一个二进制的一个

312
00:12:00,200 --> 00:12:01,733
可执行应用

313
00:12:03,333 --> 00:12:04,866
实际上是镜像

314
00:12:05,133 --> 00:12:06,366
对然后他其实

315
00:12:06,433 --> 00:12:07,733
会再包一层

316
00:12:07,733 --> 00:12:09,033
是包一个 charm 包

317
00:12:10,166 --> 00:12:11,000
什么包

318
00:12:11,633 --> 00:12:12,599
charm 包

319
00:12:34,000 --> 00:12:35,133
然后这个呢

320
00:12:35,133 --> 00:12:37,633
我不是特别了解这个包

321
00:12:37,633 --> 00:12:39,366
因为这个是交付团队做的

322
00:12:39,366 --> 00:12:40,600
标准化的一个包

323
00:12:45,366 --> 00:12:47,633
那其实我理理解上

324
00:12:47,666 --> 00:12:49,433
它是用啾啾(juju)去管理的

325
00:12:49,433 --> 00:12:52,366
啾啾可能类似于 k8s 吧

326
00:12:54,533 --> 00:12:57,333
可以理解为 charm 是 k8s 里就是

327
00:12:58,033 --> 00:13:00,033
类似于 docker 的一个镜像

328
00:13:00,033 --> 00:13:01,199
可能是这样的

329
00:13:02,800 --> 00:13:05,800
嗯嗯 k8s 里面有一些东西叫 chart (实际上是 helm)

330
00:13:05,800 --> 00:13:08,533
但是这个也需要用户的环境有 k8s

331
00:13:10,133 --> 00:13:12,566
对我们不是 k8s 我们是 juju

332
00:13:19,333 --> 00:13:21,333
他类似于 k8s 吧

333
00:13:22,566 --> 00:13:24,733
具体深入的话我不是特别了解

334
00:13:24,733 --> 00:13:25,833
他类似于 k8s

335
00:13:25,966 --> 00:13:28,800
然后就是我们交付的一个流程

336
00:13:30,666 --> 00:13:34,066
然后你们给到用户的

337
00:13:34,066 --> 00:13:35,200
就是给到那些

338
00:13:35,433 --> 00:13:36,866
私有化定制那些企业的时候

339
00:13:36,866 --> 00:13:38,233
就给他们一个 charm 包

340
00:13:38,233 --> 00:13:39,233
然后他们

341
00:13:40,266 --> 00:13:41,066
在他们那里

342
00:13:42,033 --> 00:13:43,799
对进行多机器的部署

343
00:13:43,866 --> 00:13:46,000
然后这个镜像会跑在

344
00:13:46,533 --> 00:13:49,066
有些是4个，有些是6个机器上

345
00:13:51,666 --> 00:13:52,633
嗯好

346
00:13:53,366 --> 00:13:54,466
那他们私有化交付

347
00:13:54,466 --> 00:13:56,666
比如说他们是要和后端进行交互的

348
00:13:56,666 --> 00:13:57,533
然后所以

349
00:13:57,733 --> 00:13:59,566
所以他们的后端应用的这个 Server

350
00:13:59,566 --> 00:14:02,233
肯定也是和这个在一块进行打包

351
00:14:02,233 --> 00:14:05,066
一块去交付给他们的这个服务

352
00:14:05,333 --> 00:14:06,799
但是前后端不是一个包吗

353
00:14:06,800 --> 00:14:08,400
所以他们是他们的包，我们就我们

354
00:14:08,400 --> 00:14:09,733
的包可能就

355
00:14:10,333 --> 00:14:12,933
嗯对不太一样。然后他们包也比较多

356
00:14:17,566 --> 00:14:19,166
嗯行好了解

357
00:14:27,200 --> 00:14:29,000
但是你们交付的不是一个桌面应用吗

358
00:14:29,000 --> 00:14:31,766
它们最后怎么把这个桌面应用给打开

359
00:14:37,633 --> 00:14:39,433
啊对所以你们是通过

360
00:14:40,733 --> 00:14:41,433
这个容器化

361
00:14:41,433 --> 00:14:44,133
是把这个下载的这个东西放上面去了

362
00:14:44,266 --> 00:14:46,566
对是的是把下载的放上面去的

363
00:14:49,366 --> 00:14:51,266
然后那个像我们

364
00:14:51,333 --> 00:14:52,866
其他产品都不是桌面的产品啊

365
00:14:52,866 --> 00:14:53,600
其他产品

366
00:14:53,600 --> 00:14:55,466
交付的话也其实也是一个 nginx

367
00:14:55,466 --> 00:14:57,433
但是这个 nginx

368
00:14:58,266 --> 00:15:01,233
主要是对流量进行一些转发

369
00:15:01,633 --> 00:15:03,933
它要是 index.html

370
00:15:03,966 --> 00:15:04,766
就更简单了

371
00:15:04,766 --> 00:15:07,400
直接把这静态资源交付给他们就可以

372
00:15:07,400 --> 00:15:09,666
因为产品要多所以

373
00:15:11,000 --> 00:15:12,200
嗯好

374
00:15:13,933 --> 00:15:15,033
那行好了解

375
00:15:16,133 --> 00:15:24,333
[问]你是如何去建设低代码平台的

376
00:15:25,366 --> 00:15:27,400
我主要是负责这个国际化功能这块

377
00:15:28,266 --> 00:15:30,733
然后我们这个低代码平台是一个

378
00:15:30,733 --> 00:15:32,799
也是一个 SaaS 平台啊

379
00:15:33,033 --> 00:15:35,233
然后呢，他可以对

380
00:15:35,866 --> 00:15:39,400
就是直接生成我们当前那个应用

381
00:15:40,166 --> 00:15:41,766
就是包括后端接口

382
00:15:41,766 --> 00:15:42,966
也可以在我们这个平台上

383
00:15:42,966 --> 00:15:45,266
进行一些构建

384
00:15:45,566 --> 00:15:47,933
他是一个就是全...

385
00:15:48,433 --> 00:15:50,566
怎么说全栈型的

386
00:15:51,366 --> 00:15:52,400
一个平台建设

387
00:15:52,400 --> 00:15:54,133
就是可以直接把应用我们直接

388
00:15:54,133 --> 00:15:54,866
这个平台上

389
00:15:54,866 --> 00:15:56,033
可以直接产出应用

390
00:15:56,333 --> 00:15:58,033
然后我们主要是针对

391
00:15:59,366 --> 00:16:02,800
用户有一些国际化的一些需求啊

392
00:16:02,833 --> 00:16:06,833
然后我们在构建这个应用的时候需要

393
00:16:07,133 --> 00:16:08,066
就是用户需要

394
00:16:08,066 --> 00:16:10,366
可以自主的去配置这个国际化语料

395
00:16:10,533 --> 00:16:12,666
然后在我们的

396
00:16:12,966 --> 00:16:14,933
设计态的时候

397
00:16:15,366 --> 00:16:17,200
就是我们在设计这个应用的时候

398
00:16:17,200 --> 00:16:19,533
设计其实就是可以理解为低代码

399
00:16:19,533 --> 00:16:20,966
拖拉拽的那个阶段

400
00:16:21,233 --> 00:16:22,599
就是编辑器的一个阶段

401
00:16:22,766 --> 00:16:25,066
然后可以自主的去配置

402
00:16:25,233 --> 00:16:26,399
比如说像 label 呀

403
00:16:26,400 --> 00:16:28,200
像我们一些...

404
00:16:28,233 --> 00:16:30,833
像这种还有就是接口

405
00:16:30,833 --> 00:16:33,566
接口层面的接口报错的一些错误 code

406
00:16:33,566 --> 00:16:36,800
的一些国际化的一些处理

407
00:16:37,133 --> 00:16:38,399
主要是

408
00:16:38,600 --> 00:16:41,133
在这个平台上构建的时候是在

409
00:16:41,366 --> 00:16:43,066
应用配置的时候

410
00:16:43,066 --> 00:16:47,200
用户可以在可以自主的去

411
00:16:47,533 --> 00:16:49,599
设置当前的语料

412
00:16:49,666 --> 00:16:51,433
语料的key，然后语料的 value

413
00:16:51,566 --> 00:16:54,433
然后我们配置好的语料呢会

414
00:16:55,000 --> 00:16:57,933
在用户编辑的时候进行呃

415
00:16:57,933 --> 00:17:00,166
就会在这个应用上的一个配置

416
00:17:00,166 --> 00:17:02,366
像里面会有这些这些语料

417
00:17:02,366 --> 00:17:04,200
然后用呃我们

418
00:17:04,766 --> 00:17:07,033
在编辑器的时候用户可以

419
00:17:08,000 --> 00:17:10,400
可以自主的去选择这些语料啊

420
00:17:10,400 --> 00:17:11,666
应用发布的时候

421
00:17:12,033 --> 00:17:13,199
我们针对

422
00:17:13,566 --> 00:17:16,133
用户已经配置好的语料呢进行

423
00:17:16,433 --> 00:17:17,866
发布

424
00:17:18,066 --> 00:17:21,133
对应的键值对队我们发布在

425
00:17:21,200 --> 00:17:23,566
就是发布在这个

426
00:17:23,800 --> 00:17:24,800
应用的

427
00:17:25,733 --> 00:17:26,566
配置向上

428
00:17:26,800 --> 00:17:29,433
然后，这个应用呢就会有一个

429
00:17:29,433 --> 00:17:30,266
也会有一个

430
00:17:30,266 --> 00:17:32,233
就是国际化切换的一个开关嘛

431
00:17:35,000 --> 00:17:37,466
还有就是啊用户在配置他的

432
00:17:37,466 --> 00:17:38,466
因为低代码平台嘛

433
00:17:38,466 --> 00:17:39,766
有一些数据呢

434
00:17:40,133 --> 00:17:41,399
嗯是需要

435
00:17:41,666 --> 00:17:43,566
有些数据是动态的啊

436
00:17:43,566 --> 00:17:47,400
也有些数据呢就是呃需要去呃

437
00:17:47,666 --> 00:17:48,933
转换的时候

438
00:17:49,166 --> 00:17:51,333
呃需要去做一些国际化的操作

439
00:17:51,333 --> 00:17:54,633
就是在我们会会有一个呃配

440
00:17:54,633 --> 00:17:57,599
在用户去配置的时候会有一些就是

441
00:17:58,800 --> 00:17:59,833
那你叫什么

442
00:18:04,333 --> 00:18:06,366
晚上好啊行好

443
00:18:06,566 --> 00:18:08,566
那刚刚输入的那个啊

444
00:18:08,733 --> 00:18:09,966
我们往下走吧

445
00:18:10,533 --> 00:18:11,533
好

446
00:18:11,533 --> 00:18:16,533
[问]我们在这里有一个 webpack 构建速度的优化，这个是怎么做的

447
00:18:17,566 --> 00:18:18,366
嗯

448
00:18:19,000 --> 00:18:20,933
这个当时做的是这样的

449
00:18:21,200 --> 00:18:23,400
我们之前的那个项目呢

450
00:18:23,400 --> 00:18:25,633
基本上就是基于 vue-cli

451
00:18:26,333 --> 00:18:28,066
去跑的也没有什么

452
00:18:28,733 --> 00:18:30,266
也没有做什么优化

453
00:18:30,266 --> 00:18:33,366
我这边优化的主要是一个

454
00:18:35,766 --> 00:18:37,766
dll 的动态链接的一些

455
00:18:38,266 --> 00:18:40,666
就是 plugin 的一些配置

456
00:18:41,466 --> 00:18:42,266
嗯

457
00:18:43,133 --> 00:18:44,033
然后呢就是一些

458
00:18:44,033 --> 00:18:46,966
就是我们代码里面引入的一些

459
00:18:47,333 --> 00:18:48,533
一些包呀

460
00:18:49,966 --> 00:18:50,766
呃

461
00:18:53,633 --> 00:18:55,199
比如说就是这个

462
00:18:57,033 --> 00:18:58,066
我们代码里面

463
00:18:58,233 --> 00:19:00,533
webpack 会自动去查询这个

464
00:19:00,533 --> 00:19:02,166
我们引用的这个库

465
00:19:02,400 --> 00:19:04,733
然后我们可以通过

466
00:19:04,933 --> 00:19:06,599
那个别名的配置

467
00:19:06,600 --> 00:19:08,666
然后去减少这个别名库的

468
00:19:08,666 --> 00:19:11,166
他的检索的一个时间

469
00:19:11,166 --> 00:19:12,966
还有就是主要是通过

470
00:19:13,066 --> 00:19:14,766
当时用的是 happypack 做的

471
00:19:14,766 --> 00:19:16,266
多进程的一个

472
00:19:16,266 --> 00:19:17,766
多线程的一个加速的编译

473
00:19:18,333 --> 00:19:21,533
现在不是不用这个 happy pack 的

474
00:19:36,466 --> 00:19:39,566
打包然后做的就是还有一些

475
00:19:40,666 --> 00:19:43,600
像 babel 那些缓存啊

476
00:19:48,533 --> 00:19:49,799
嗯行好

477
00:19:50,466 --> 00:19:51,266
嗯

478
00:19:53,966 --> 00:19:56,033
对在 webpack5 里边还有一个 cache-loader

479
00:19:56,033 --> 00:19:57,333
这个也可以用一下

480
00:20:00,000 --> 00:20:01,866
哦当时可能因为我们之前

481
00:20:01,933 --> 00:20:03,833
因为是2018年的时候

482
00:20:03,933 --> 00:20:06,933
19年的时候做的

483
00:20:06,933 --> 00:20:14,399
[问] 基于 koa/vue 的服务端渲染这个是怎么做的

484
00:20:14,866 --> 00:20:16,266
啊主要是

485
00:20:16,833 --> 00:20:20,399
主要是用的 koa 的服务端渲染

486
00:20:20,833 --> 00:20:24,599
koa 的 vue 的服务端渲染然后去

487
00:20:25,600 --> 00:20:29,000
因为我们是一个内嵌的一个页面

488
00:20:29,400 --> 00:20:30,200
嗯

489
00:20:31,633 --> 00:20:32,866
内嵌的一个 hybrid 的页面

490
00:20:32,866 --> 00:20:35,066
所以因为我们所有的

491
00:20:35,200 --> 00:20:36,733
单页面前段渲染的页面

492
00:20:36,733 --> 00:20:38,333
都会有白屏这样的问题

493
00:20:38,466 --> 00:20:39,966
然后当时呢是

494
00:20:40,600 --> 00:20:41,766
我们直接用了 koa/vue

495
00:20:41,766 --> 00:20:44,066
的服务段渲染来

496
00:20:44,733 --> 00:20:47,199
后端去生成一个静态页面

497
00:20:47,400 --> 00:20:48,200
然后我们

498
00:20:48,266 --> 00:20:50,000
客户端呢去直接加上这个静态页面

499
00:20:50,000 --> 00:20:52,200
来减少这个页面的白屏时间

500
00:20:53,666 --> 00:20:55,033
嗯行好

501
00:20:56,033 --> 00:20:58,766
[问]那你说一下，vue 服务端渲染的这个原理吧

502
00:21:00,633 --> 00:21:01,433
呃

503
00:21:18,600 --> 00:21:20,933
嗯我这会没看，我理解是他

504
00:21:21,366 --> 00:21:23,966
还是通过他自己的服务端的一个编辑器

505
00:21:23,966 --> 00:21:26,633
然后去把当前的模板都编译出来

506
00:21:27,233 --> 00:21:28,033
嗯

507
00:21:30,033 --> 00:21:31,733
然后应该会调用

508
00:21:32,466 --> 00:21:35,766
google 的那个 chrome 的那个模块 (没听懂)

509
00:21:35,766 --> 00:21:38,866
然后去把我们的 DOM 去渲染出来

510
00:21:39,466 --> 00:21:42,366
第一部分就是

511
00:21:42,466 --> 00:21:44,200
由服务端然后

512
00:21:44,466 --> 00:21:46,833
通过 vue 的组件然后生成一些

513
00:21:46,966 --> 00:21:48,266
在服务端直接渲染好

514
00:21:48,266 --> 00:21:49,266
所以就叫服务端渲染

515
00:21:49,266 --> 00:21:51,166
生成一些字符串给了前端

516
00:21:51,166 --> 00:21:53,400
然后前端这边还需要进行一些

517
00:21:53,566 --> 00:21:55,133
hydrate 的一些操作

518
00:21:55,133 --> 00:21:57,999
然后把一些激活这个页面对

519
00:21:58,000 --> 00:21:59,166
然后把一些 props 啊

520
00:21:59,166 --> 00:22:01,533
data 呀再扔进去就可以了

521
00:22:02,600 --> 00:22:03,400
嗯

522
00:22:04,433 --> 00:22:05,333
嗯行好

523
00:22:05,333 --> 00:22:09,866
[问]这边有一个功能模块拆分，提升产品交付效率，是怎么做的

524
00:22:12,133 --> 00:22:16,666
嗯这块呢嗯我们主 app 里面有一些

525
00:22:17,433 --> 00:22:19,833
运营的产品就运营的页面

526
00:22:19,833 --> 00:22:22,633
还有用户的比如说用户协议啊

527
00:22:22,800 --> 00:22:25,600
服务协用服务的一些介绍呀

528
00:22:25,600 --> 00:22:26,466
这些页面

529
00:22:26,566 --> 00:22:28,366
他不是强依赖于我们 app

530
00:22:28,366 --> 00:22:29,800
里面的一些数据的

531
00:22:30,133 --> 00:22:34,133
就他可能只依赖依赖一些用户的嗯

532
00:22:34,866 --> 00:22:36,133
一些信息所以

533
00:22:36,133 --> 00:22:37,399
呢我们只是

534
00:22:37,600 --> 00:22:40,400
就把这块就从我们主 app 里面

535
00:22:40,600 --> 00:22:41,600
拆出来了

536
00:22:42,800 --> 00:22:44,666
当时做的是拆了一个服务

537
00:22:44,666 --> 00:22:46,600
就是新独立部署的一个服务

538
00:22:46,600 --> 00:22:48,466
但相相当于用 ul 料理

539
00:22:48,466 --> 00:22:51,666
链接跳转的这种方式去做的

540
00:22:54,133 --> 00:22:55,633
嗯行好的

541
00:22:56,866 --> 00:22:58,200
那后面想想应该可以用

542
00:22:58,200 --> 00:22:59,600
就是动态的一些

543
00:23:00,133 --> 00:23:02,399
动态路由去做这个事

544
00:23:02,400 --> 00:23:04,166
可能比较比较好一点

545
00:23:05,000 --> 00:23:06,200
嗯对

546
00:23:08,033 --> 00:23:10,599
有交互上来说用户就不用再去加载

547
00:23:10,600 --> 00:23:11,400
我们

548
00:23:12,133 --> 00:23:14,366
就会减少一定的白屏时间

549
00:23:15,266 --> 00:23:18,033
嗯好然后在上面有一个完善上线流程

550
00:23:18,033 --> 00:23:19,166
业务对接流程

551
00:23:19,366 --> 00:23:21,933
[问]降低稳定性问题30%这个是怎么做的

552
00:23:22,066 --> 00:23:23,733
就是呃这么说吧

553
00:23:23,733 --> 00:23:26,999
你们在团队管理上怎么去做这个事情

554
00:23:28,666 --> 00:23:30,200
嗯是是这样的

555
00:23:30,200 --> 00:23:31,733
就是我们

556
00:23:32,000 --> 00:23:33,066
现在这个团队呢

557
00:23:33,066 --> 00:23:36,600
其实这个标准规范呢比较欠缺啊

558
00:23:36,600 --> 00:23:37,833
然后呢我们

559
00:23:38,066 --> 00:23:39,533
我在工作的过程中

560
00:23:39,533 --> 00:23:42,533
发现一些就是频繁的一些问题啊

561
00:23:42,533 --> 00:23:45,033
就是出现一些线上问题

562
00:23:45,033 --> 00:23:46,599
然后会导致我们这个

563
00:23:47,233 --> 00:23:48,266
事故

564
00:23:49,033 --> 00:23:51,033
我们会有个事故的评级标准吗

565
00:23:51,600 --> 00:23:54,266
然后我们有一个问题呢因为

566
00:23:54,733 --> 00:23:57,833
呃因为我们的那个就是对接客户的

567
00:23:57,833 --> 00:23:58,633
我们叫 tom

568
00:23:58,800 --> 00:24:00,066
这些人呢去

569
00:24:00,466 --> 00:24:02,866
再找先他们会优先去找后端

570
00:24:02,866 --> 00:24:04,200
因为有些出现的问题呢

571
00:24:04,200 --> 00:24:06,466
其实大部分都是因为后段的问题

572
00:24:06,833 --> 00:24:08,333
他们会优先找后端

573
00:24:08,400 --> 00:24:11,166
但是其实呢有一些前端的问题呃

574
00:24:11,166 --> 00:24:13,533
其实前端同学一眼就能

575
00:24:13,800 --> 00:24:15,233
看出来这个问题的

576
00:24:15,766 --> 00:24:16,800
具体是因为什么

577
00:24:16,800 --> 00:24:19,166
有可能是因为上限啊什么之之类的

578
00:24:19,600 --> 00:24:21,933
嗯或者是一些遗漏的一些 case

579
00:24:22,733 --> 00:24:24,966
嗯然后我们就建立了一个

580
00:24:24,966 --> 00:24:27,066
就是一个是通知的一个制度

581
00:24:27,066 --> 00:24:29,166
就是我们所我们所有设计

582
00:24:29,166 --> 00:24:30,366
上线的一些产品呢

583
00:24:30,366 --> 00:24:31,333
我们需要把

584
00:24:31,333 --> 00:24:32,666
各个角色都通知到

585
00:24:32,833 --> 00:24:34,999
包括对接客户的呃

586
00:24:35,366 --> 00:24:37,266
这些同学嗯

587
00:24:38,166 --> 00:24:39,433
然后到就是

588
00:24:39,833 --> 00:24:41,766
减少我们如果说我们上线了

589
00:24:41,766 --> 00:24:44,233
然后导致出现了线上问题

590
00:24:44,266 --> 00:24:47,200
然后其实呃后端查了半天没有查到

591
00:24:47,200 --> 00:24:47,600
但是呢

592
00:24:47,600 --> 00:24:49,933
其实前端一眼就能看出来这个问题

593
00:24:49,933 --> 00:24:53,066
就是为了减少事故影响的时长

594
00:24:53,200 --> 00:24:54,166
然后呢

595
00:24:54,833 --> 00:24:58,066
避免我们这个事故呢升级

596
00:24:58,066 --> 00:24:59,400
其实我们在5分钟之内

597
00:24:59,400 --> 00:25:00,733
可能这个事故就非常小

598
00:25:00,733 --> 00:25:01,733
然后如果说我们

599
00:25:02,000 --> 00:25:03,533
事故发生了20分钟还没有解决

600
00:25:03,533 --> 00:25:05,066
这个事故就比较严重

601
00:25:06,833 --> 00:25:08,599
然后一个就是我们这个

602
00:25:08,800 --> 00:25:09,933
通知的这个流程

603
00:25:09,933 --> 00:25:11,066
还有就是我们

604
00:25:12,466 --> 00:25:13,933
发现问题的同学呢

605
00:25:14,133 --> 00:25:18,599
呃会我们会有一些就是消息通知

606
00:25:19,933 --> 00:25:21,033
一个是嗯

607
00:25:21,766 --> 00:25:23,000
我们有一个通知群吧

608
00:25:23,000 --> 00:25:24,633
就是建了一个新建了一个通知群

609
00:25:24,633 --> 00:25:26,866
然后我们会在通知群里面去徒步我们

610
00:25:26,866 --> 00:25:28,033
当前这个产品

611
00:25:28,200 --> 00:25:29,066
上线的一些信息

612
00:25:29,066 --> 00:25:30,333
或者线上的一些问题

613
00:25:30,333 --> 00:25:32,566
还有还有就是

614
00:25:35,266 --> 00:25:38,366
然后就是我们在上线的时候其实嗯

615
00:25:39,200 --> 00:25:42,066
对 qa 我们的就是 qa 同学呢

616
00:25:42,200 --> 00:25:43,166
也有频繁变动

617
00:25:43,166 --> 00:25:43,733
这个情况

618
00:25:43,733 --> 00:25:45,266
导致一些我们的测试 case

619
00:25:45,266 --> 00:25:47,400
没有办法进行沉淀啊

620
00:25:47,400 --> 00:25:50,166
我们前前端团队内部呢

621
00:25:50,166 --> 00:25:51,733
会有一些就是自测的一些 kiss

622
00:25:51,733 --> 00:25:53,966
但是可能没有办法完全覆盖到

623
00:25:54,066 --> 00:25:56,266
我们各个场景啊

624
00:25:56,266 --> 00:25:58,000
但是我们的 qv 同学呢

625
00:25:58,000 --> 00:25:59,766
和我们又不是同一个部门的

626
00:25:59,866 --> 00:26:01,666
所以我们嗯

627
00:26:02,866 --> 00:26:05,933
对 qv 同学进行了一些就是要求吗

628
00:26:05,933 --> 00:26:06,966
需要就是 qv

629
00:26:06,966 --> 00:26:07,766
我们在

630
00:26:07,800 --> 00:26:09,633
今后的一些测试迭代的过程中

631
00:26:09,633 --> 00:26:12,433
需要把测试 case 呢沉淀下来

632
00:26:12,433 --> 00:26:15,266
沉淀在一个我们的文档里面

633
00:26:15,433 --> 00:26:17,633
然后以便我们后续接手呀

634
00:26:17,633 --> 00:26:19,166
或者是我们新同学熟悉这

635
00:26:19,166 --> 00:26:20,266
个产品的时候

636
00:26:20,566 --> 00:26:21,366
呃

637
00:26:21,966 --> 00:26:24,433
避免我们同样的问题发生发生

638
00:26:25,733 --> 00:26:29,599
嗯降低我们问题发生的概率嗯行好

639
00:26:29,866 --> 00:26:31,733
嗯嗯对嗯

640
00:26:31,733 --> 00:26:32,799
最近就是

641
00:26:32,833 --> 00:26:35,233
最近几年就流行一个敏捷的概念

642
00:26:35,233 --> 00:26:40,433
[问]你可以对敏捷这个概念做一下阐述吗

643
00:26:42,466 --> 00:26:45,133
嗯敏捷的话我们主要就是

644
00:26:45,733 --> 00:26:47,533
敏捷的概念主要是小步快跑嘛

645
00:26:47,533 --> 00:26:50,333
然后我们不断就是频繁的迭代

646
00:26:50,333 --> 00:26:52,433
然后去不断可能试错

647
00:26:52,433 --> 00:26:53,466
然后像自己

648
00:26:54,400 --> 00:26:56,200
敏捷开发的话

649
00:26:56,200 --> 00:26:56,966
我们就是

650
00:26:56,966 --> 00:26:59,200
尽量把一个功能就是拆分到很

651
00:26:59,200 --> 00:27:00,966
很细力度就是很小的力度

652
00:27:00,966 --> 00:27:03,400
我们保证我们在短时间内可以进行

653
00:27:03,466 --> 00:27:05,066
一个小功能的上线

654
00:27:05,066 --> 00:27:06,866
然后进行呃

655
00:27:07,466 --> 00:27:09,033
一个小功能加一个小功能

656
00:27:09,033 --> 00:27:10,399
将频繁的去迭代

657
00:27:10,400 --> 00:27:12,400
然后去不断完善我们这个

658
00:27:12,600 --> 00:27:14,166
嗯产品功能

659
00:27:14,566 --> 00:27:16,933
呃敏捷的理念就是要

660
00:27:17,333 --> 00:27:18,966
尽快的上线一个

661
00:27:19,600 --> 00:27:22,033
可以可以使用的一个贝塔的一个版本

662
00:27:22,033 --> 00:27:24,733
然后我们在这个贝塔版本的基础上

663
00:27:24,733 --> 00:27:27,933
在在基础上相当于是垒砖头吧

664
00:27:27,933 --> 00:27:30,633
一个一小块一小块就往上累呃

665
00:27:30,833 --> 00:27:32,666
但这个环节上我们

666
00:27:32,966 --> 00:27:34,766
研发册还有就是产品册

667
00:27:34,766 --> 00:27:37,866
还有就是测试册需要嗯

668
00:27:38,666 --> 00:27:41,333
就是需要沟通的这个

669
00:27:41,966 --> 00:27:43,133
沟通的这个

670
00:27:43,600 --> 00:27:45,733
嗯成本还是比较高的

671
00:27:46,466 --> 00:27:48,233
嗯其他的话

672
00:27:49,666 --> 00:27:51,533
那我暂时理解有这么多吗

673
00:27:52,000 --> 00:27:52,800
嗯

674
00:27:53,766 --> 00:27:57,533
刚才那个叫最小可用产品，叫 mvp

675
00:27:58,433 --> 00:27:59,433
啊对 mvp

676
00:28:00,166 --> 00:28:02,733
对然后他应该除了还有一个叫

677
00:28:02,733 --> 00:28:04,333
快速试错的一个

678
00:28:04,600 --> 00:28:06,633
嗯快速试错就快速测试

679
00:28:06,633 --> 00:28:07,866
然后快速的交付

680
00:28:08,000 --> 00:28:09,533
就是3 s 那些情况呢

681
00:28:09,533 --> 00:28:11,366
就是我们刚上了一个功能

682
00:28:11,366 --> 00:28:14,366
然后可以马上的去把它进行测试

683
00:28:14,366 --> 00:28:15,166
然后一有问题

684
00:28:15,166 --> 00:28:17,166
然后可以快速的回滚这些

685
00:28:18,000 --> 00:28:22,533
嗯嗯行好那本次内容就到这里了

