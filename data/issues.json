[
  {
    "id": "MDU6SXNzdWU1MTYwNTcyNDA=",
    "number": 1,
    "title": "【Q001】网站开发中，如何实现图片的懒加载",
    "body": "网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTEzMzE0NQ==",
          "body": "懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片\r\n\r\n故问题拆分成两个：\r\n\r\n1. 如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）\r\n2. 如何控制图片的加载\r\n\r\n## 方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n`clientTop`，`offsetTop`，`clientHeight` 以及 `scrollTop` 各种关于图片的高度作比对\r\n\r\n这些高度都代表了什么意思？\r\n\r\n这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了\r\n\r\n**所以它有一个问题：复杂琐碎不好理解！**\r\n\r\n仅仅知道它静态的高度还不够，我们还需要知道动态的\r\n\r\n**如何动态？监听 `window.scroll` 事件**\r\n\r\n### 如何控制图片的加载\r\n\r\n``` html\r\n<img data-src=\"shanyue.jpg\">\r\n```\r\n\r\n首先设置一个临时 Data 属性 `data-src`，控制加载时使用 `src` 代替 `data-src`，可利用 DataSet API 实现\r\n\r\n``` html\r\nimg.src = img.datset.src\r\n```\r\n\r\n## 方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API\r\n\r\n改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n引入一个新的 API， **`Element.getBoundingClientRect()` 方法返回元素的大小及其相对于视口的位置。**\r\n\r\n<img alt=\"getBoundingClientRect示例图\" src=\"https://mdn.mozillademos.org/files/15087/rect.png\">\r\n\r\n那如何判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。\r\n\r\n``` js\r\n// clientHeight 代表当前视口的高度\r\nimg.getBoundingClientRect().top < document.documentElement.clientHeight\r\n```\r\n\r\n**监听 `window.scroll` 事件也优化一下**\r\n\r\n加个节流器，提高性能。工作中一般使用 `lodash.throttle` 就可以了，万能的 `lodash` 啊！\r\n\r\n``` js\r\n_.throttle(func, [wait=0], [options={}])\r\n```\r\n\r\n参考 [什么是防抖和节流，他们的应用场景有哪些](https://github.com/shfshanyue/Daily-Question/issues/3)，或者[前端面试题](https://q.shanyue.tech/fe/js/3.html)\r\n\r\n## 方案三: IntersectionObserver API + DataSet API\r\n\r\n再改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n**方案二使用的方法是: `window.scroll` 监听 `Element.getBoundingClientRect()` 并使用 `_.throttle` 节流**\r\n\r\n**一系列组合动作太复杂了，于是浏览器出了一个三合一事件: `IntersectionObserver` API，一个能够监听元素是否到了当前视口的事件，一步到位！**\r\n\r\n事件回调的参数是 [IntersectionObserverEntry](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry) 的集合，代表关于是否在可见视口的一系列值\r\n\r\n其中，`entry.isIntersecting` 代表目标元素可见\r\n\r\n``` javascript\r\nconst observer = new IntersectionObserver((changes) => {\r\n  // changes: 目标元素集合\r\n  changes.forEach((change) => {\r\n    // intersectionRatio\r\n    if (change.isIntersecting) {\r\n      const img = change.target\r\n      img.src = img.dataset.src\r\n      observer.unobserve(img)\r\n    }\r\n  })\r\n})\r\n\r\nobserver.observe(img)\r\n```\r\n\r\n**当然，`IntersectionObserver` 除了给图片做懒加载外，还可以对单页应用资源做预加载。**\r\n\r\n如在 `next.js v9` 中，会对视口内的资源做预加载，可以参考 [next 9 production optimizations](https://nextjs.org/blog/next-9#production-optimizations)\r\n\r\n``` jsx\r\n<Link href=\"/about\">\r\n  <a>关于山月</a>\r\n</Link>\r\n```\r\n\r\n## 方案四: LazyLoading属性\r\n\r\n浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。实在是...！\r\n\r\n``` html\r\n<img src=\"shanyue.jpg\" loading=\"lazy\">\r\n```\r\n\r\n不过目前浏览器兼容性不太好，关于 `loading` 属性的文章也可以查看 [Native image lazy-loading for the web!](https://addyosmani.com/blog/lazy-loading/)\r\n",
          "star": {
            "totalCount": 9
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MDkyNzE1MQ==",
          "body": "intersectionObserver ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hanhang123",
            "url": "https://github.com/hanhang123"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMDA4NzU0Ng==",
          "body": "比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了！！！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "AgnesWY",
            "url": "https://github.com/AgnesWY"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzAyNzcxMg==",
          "body": "那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hivm",
          "body": "那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haiifeng",
            "url": "https://github.com/haiifeng"
          }
        },
        {
          "id": "IC_kwDODQzyOs42MkyK",
          "body": "方案二的简单Demo:\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>图片懒加载</title>\r\n    <style>\r\n        img {\r\n            width: 100%;\r\n            height: 600px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <img src=\"https://cdn.pixabay.com/photo/2021/08/24/15/38/sand-6570980_960_720.jpg\" alt=\"1\">\r\n    <img src=\"https://cdn.pixabay.com/photo/2013/02/21/19/06/drink-84533_960_720.jpg\" alt=\"2\">\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2014/12/15/17/16/boardwalk-569314_960_720.jpg\" alt=\"3\">\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg\" alt=\"4\">\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_960_720.jpg\" alt=\"5\">\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2017/03/26/21/54/yoga-2176668_960_720.jpg\" alt=\"6\">\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2015/03/17/14/05/sparkler-677774_960_720.jpg\" alt=\"7\">\r\n    <script src=\"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.js\"></script>\r\n    <script>\r\n        const images = document.querySelectorAll('img');\r\n        const lazyLoad = () => {\r\n            images.forEach((item) => {\r\n                // 触发条件为img元素的CSSOM对象到视口顶部的距离 < 100px + 视口高度，+100px为了提前触发图片加载\r\n                if (item.getBoundingClientRect().top < document.documentElement.clientHeight + 100) {\r\n                    if ('src' in item.dataset) {\r\n                        item.src = item.dataset.src;\r\n                    }\r\n                }\r\n            })\r\n        }\r\n        document.addEventListener('scroll', _.throttle(lazyLoad, 200));\r\n    </script>\r\n</body>\r\n</html>\r\n```",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs42Tg0P",
          "body": "@hwb2017 可以在 codepen 里写一下，然后附个地址",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs42T0ZZ",
          "body": "方案二的Demo(CodePen)  https://codepen.io/hwb2017/pen/BaZKeLa",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs43OSk1",
          "body": "在react hook中要怎么应用？看到这篇文章https://juejin.cn/post/6844903768966856717，但是改成 useRef 不行，hook 不能在循环中使用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ha0ran2001",
            "url": "https://github.com/Ha0ran2001"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-OrJP",
          "body": "方案一的实现[demo](https://codesandbox.io/s/manual-image-lazy-6zzhr?file=/index.html)，ScrollListener类用于监听和处理滚动，在Controller（实现onEnterViewport方法）元素出现在视窗内时调用controller.onEnterViewport()，最后移除controller。\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>offsetTop计算实现图片懒加载</title>\r\n    <style>\r\n      body {\r\n        margin: 0;\r\n      }\r\n      .img {\r\n        width: 100%;\r\n        height: 100%;\r\n        object-fit: cover;\r\n        object-position: center;\r\n      }\r\n\r\n      .wrap {\r\n        margin: 10px;\r\n        display: inline-block;\r\n        width: 480px;\r\n        height: 270px;\r\n      }\r\n\r\n      .container {\r\n        width: 100vw;\r\n        height: 100vh;\r\n        overflow: auto;\r\n      }\r\n\r\n      h1 {\r\n        text-align: center;\r\n      }\r\n\r\n      .main {\r\n        margin: 0;\r\n        width: 2000px;\r\n      }\r\n    </style>\r\n  </head>\r\n\r\n  <body>\r\n    <section class=\"container\">\r\n      <h1>请滚动页面查看效果</h1>\r\n      <div class=\"main\"></div>\r\n    </section>\r\n  </body>\r\n  <script defer>\r\n    \"use strict\";\r\n\r\n    // 图片url列表\r\n    const images = [\r\n      \"https://h2.ioliu.cn/bing/Latern2022_ZH-CN0112710917_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/MaldivesHeart_ZH-CN0032539727_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/FaceOff_ZH-CN9969100257_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/DarwinsArch_ZH-CN9740478501_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/TeaGardensMunnar_ZH-CN9587720369_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/SnowyBern_ZH-CN5472524801_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/SevenSistersCliffs_ZH-CN5362127173_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/SpeloncatoSnow_ZH-CN8115437163_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/WinterludeIce_ZH-CN7868524911_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/Oymyakon_ZH-CN7758768574_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/MexicoMonarchs_ZH-CN7526758236_640x480.jpg?imageslim\",\r\n      \"https://h2.ioliu.cn/bing/WinterOlymics_ZH-CN7384614076_640x480.jpg?imageslim\",\r\n      \"233\"\r\n    ];\r\n\r\n    // 未加载时默认url\r\n    const defaultUrl =\r\n      \"data:image/svg+xml;base64,PHN2ZyB0PSIxNjQ0ODk5MzI0NDgwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjIwOTMiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNODc0LjEgODEzLjc1SDE0OS45Yy0yMi4yMiAwLTQwLjIzLTE4LjAxLTQwLjIzLTQwLjIzVjI1MC40OWMwLTIyLjIyIDE4LjAxLTQwLjIzIDQwLjIzLTQwLjIzaDcyNC4yYzIyLjIyIDAgNDAuMjMgMTguMDEgNDAuMjMgNDAuMjN2NTIzLjAzYzAgMjIuMjEtMTguMDIgNDAuMjMtNDAuMjMgNDAuMjN6TTI4MC42NiAzMTAuODRjLTM4Ljg5IDAtNzAuNDEgMzEuNTItNzAuNDEgNzAuNDFzMzEuNTIgNzAuNDEgNzAuNDEgNzAuNDEgNzAuNDEtMzEuNTIgNzAuNDEtNzAuNDEtMzEuNTItNzAuNDEtNzAuNDEtNzAuNDF6IG01MTIuOTcgMTAwLjU4YzAtMjIuMjItMTguMDEtNDAuMjMtNDAuMjMtNDAuMjNoLTQwLjIzYy02Ni42NiAwLTEyMC43IDU0LjA0LTEyMC43IDEyMC43djQwLjIzYzAgMzMuMzMtMjcuMDIgNjAuMzUtNjAuMzUgNjAuMzUtMTguMjkgMC0zNC40Ny04LjMxLTQ1LjU0LTIxLjE1LTAuMDUtMC4wNi0wLjI1LTAuMjgtMC4yOS0wLjMzLTIyLjA5LTI0LjA1LTU5Ljc3LTM4Ljg2LTk0Ljk4LTM4Ljg2LTAuNDQgMC0wLjg0IDAuMTItMS4yOCAwLjEzbC0wLjA2LTAuMDZjLTg4LjI2IDAuNzMtMTU5LjU5IDcyLjQ0LTE1OS41OSAxNjAuODYgMCAyMi4yMiAxOC4wMSA0MC4yMyA0MC4yMyA0MC4yM0g3NTMuNGMyMi4yMiAwIDQwLjIzLTE4LjAxIDQwLjIzLTQwLjIzVjQxMS40MnoiIHAtaWQ9IjIwOTQiIGZpbGw9IiNjZGNkY2QiPjwvcGF0aD48L3N2Zz4=\";\r\n\r\n    // 加载错误时代替\r\n    const errorUrl =\r\n      \"data:image/svg+xml;base64,PHN2ZyB0PSIxNjQ0ODk5ODEzMDQ1IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQ0OTEiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNNjQuMzgzMjM0IDUxMkM2NC4zODMyMzQgMjY0Ljc4NzgyOSAyNjQuNzg3ODI5IDY0LjM4MzIzNCA1MTIgNjQuMzgzMjM0IDc1OS4yMTIxNzEgNjQuMzgzMjM0IDk1OS42MTY3NjYgMjY0Ljc4NzgyOSA5NTkuNjE2NzY2IDUxMiA5NTkuNjE2NzY2IDc1OS4yMTIxNzEgNzU5LjIxMjE3MSA5NTkuNjE2NzY2IDUxMiA5NTkuNjE2NzY2IDI2NC43ODc4MjkgOTU5LjYxNjc2NiA2NC4zODMyMzQgNzU5LjIxMjE3MSA2NC4zODMyMzQgNTEyWk00NzQuMjMyMzc5IDc3MS4yNDUxMjRDNDc2LjQwODcxOCA3OTcuMzU1NTEyIDQ5MC41NTEzNzIgODEwLjQxMjEyMyA1MTYuNjYzMTc2IDgxMC40MTIxMjMgNTQyLjc3MzU2NCA4MTAuNDEyMTIzIDU1Ni45MTc2MzUgNzk3LjM1NTUxMiA1NTkuMDkyNTU2IDc3MS4yNDUxMjQgNTU2LjkxNzYzNSA3NDUuMTMzMzE5IDU0Mi43NzM1NjQgNzMwLjk5MDY2NiA1MTYuNjYzMTc2IDcyOC44MTQzMjcgNDkwLjU1MTM3MiA3MzAuOTkwNjY2IDQ3Ni40MDg3MTggNzQ1LjEzMzMxOSA0NzQuMjMyMzc5IDc3MS4yNDUxMjRaTTQ4MC43NTk5NzcgNjExLjMxNDc0OEM0ODAuNzU5OTc3IDYzNy40MjY1NTQgNDkyLjcyNzcxIDY1MC40ODE3NDcgNTE2LjY2MzE3NiA2NTAuNDgxNzQ3IDU0MC41OTcyMjYgNjUwLjQ4MTc0NyA1NTIuNTY0OTYgNjM3LjQyNjU1NCA1NTIuNTY0OTYgNjExLjMxNDc0OEw1NTIuNTY0OTYgMjQ5LjAyNDYxOEM1NTIuNTY0OTYgMjIyLjkxNDIzMSA1NDAuNTk3MjI2IDIwOS44NTc2MTkgNTE2LjY2MzE3NiAyMDkuODU3NjE5IDQ5Mi43Mjc3MSAyMDkuODU3NjE5IDQ4MC43NTk5NzcgMjIyLjkxNDIzMSA0ODAuNzU5OTc3IDI0OS4wMjQ2MThMNDgwLjc1OTk3NyA2MTEuMzE0NzQ4WiIgcC1pZD0iNDQ5MiIgZmlsbD0iI2NkY2RjZCI+PC9wYXRoPjwvc3ZnPg==\";\r\n\r\n    // 滚动监听和防抖\r\n    class ScrollListener {\r\n      entries = [];\r\n      taskId = 0;\r\n\r\n      constructor() {\r\n        document.addEventListener(\"scroll\", this.scrollDebounce.bind(this), {\r\n          capture: true,\r\n          passive: true\r\n        });\r\n      }\r\n\r\n      isInViewport(controller) {\r\n        let offsetTop = 0,\r\n          offsetLeft = 0,\r\n          el = controller.el,\r\n          scrollTop = 0,\r\n          scrollLeft = 0,\r\n          html = document.documentElement;\r\n        while (el && el !== html) {\r\n          offsetTop = offsetTop + el.offsetTop;\r\n          offsetLeft = offsetLeft + el.offsetLeft;\r\n          el = el.offsetParent;\r\n        }\r\n\r\n        el = controller.el;\r\n        while (el) {\r\n          scrollTop += el.scrollTop;\r\n          scrollLeft += el.scrollLeft;\r\n          el = el.parentElement;\r\n        }\r\n        offsetTop -= scrollTop;\r\n        offsetLeft -= scrollLeft;\r\n\r\n        el = controller.el;\r\n        return (\r\n          offsetTop < html.scrollTop + innerHeight &&\r\n          offsetTop + el.clientHeight > html.scrollTop &&\r\n          offsetLeft < html.scrollLeft + innerWidth &&\r\n          offsetLeft + el.clientWidth > html.scrollLeft\r\n        );\r\n      }\r\n\r\n      scrollDebounce() {\r\n        if (this.taskId) {\r\n          clearTimeout(this.taskId);\r\n        }\r\n        this.taskId = setTimeout(this.handleScroll.bind(this), 200);\r\n      }\r\n\r\n      addController(controller) {\r\n        this.entries.push(controller);\r\n        this.scrollDebounce();\r\n      }\r\n\r\n      handleScroll() {\r\n        this.entries = this.entries.filter((controller) => {\r\n          return !controller.blob;\r\n        });\r\n        this.entries.forEach((controller) => {\r\n          if (this.isInViewport(controller)) {\r\n            controller.onEnterViewport();\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // 图片控制对象\r\n    class ImageController {\r\n      img = \"\";\r\n      blob = null;\r\n      el = null;\r\n      wrap = null;\r\n      constructor(\r\n        url = \"\",\r\n        parent = document.body,\r\n        className = \"wrap\",\r\n        el = document.createElement(\"img\")\r\n      ) {\r\n        el.src = defaultUrl;\r\n        el.classList.add(\"img\");\r\n\r\n        this.el = el;\r\n        this.img = url;\r\n\r\n        this.wrap = document.createElement(\"div\");\r\n        this.wrap.classList.add(className);\r\n        this.wrap.append(el);\r\n        parent.append(this.wrap);\r\n      }\r\n\r\n      showImage() {\r\n        const target = this;\r\n        this.fetchImage().then(() => {\r\n          target.el.src = this.blob;\r\n        });\r\n      }\r\n\r\n      showLoading() {\r\n        this.el.src = defaultUrl;\r\n      }\r\n\r\n      showError() {\r\n        this.el.src = errorUrl;\r\n      }\r\n\r\n      onEnterViewport() {\r\n        this.showImage();\r\n      }\r\n\r\n      async fetchImage() {\r\n        if (typeof fetch !== \"function\") {\r\n          this.thowError();\r\n          throw new Error(\"浏览器不支持fetch接口\");\r\n        }\r\n\r\n        // 如果已经加载过，直接返回\r\n        if (!this.blob) {\r\n          const target = this;\r\n          return fetch(this.img)\r\n            .then((res) => {\r\n              if (res.status > 199 && res.status < 300) return res.blob();\r\n              else return Promise.reject();\r\n            })\r\n            .then((blob) => {\r\n              if (/image/.test(blob.type)) return URL.createObjectURL(blob);\r\n              else return Promise.reject();\r\n            })\r\n            .then((url) => {\r\n              target.blob = url;\r\n            })\r\n            .catch(() => {\r\n              target.showError();\r\n              throw new Error(\"URL不正确或MIME类型不正确\");\r\n            });\r\n        }\r\n      }\r\n    }\r\n\r\n    const scrollListener = new ScrollListener(),\r\n      main = document.getElementsByClassName(\"main\")[0],\r\n      imageControllers = images.map((url) => {\r\n        const controller = new ImageController(url, main);\r\n        scrollListener.addController(controller);\r\n      });\r\n  </script>\r\n</html>\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liucan233",
            "url": "https://github.com/liucan233"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-WDRr",
          "body": "方案二有那么一点点抖动，这里重新实现了一下\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Document</title>\r\n  <style>\r\n    * {\r\n      margin: 0px;\r\n      padding: 0px;\r\n    }\r\n\r\n    body {\r\n      margin: 0px;\r\n      padding: 0px;\r\n    }\r\n\r\n    img {\r\n      display: block;\r\n    }\r\n  </style>\r\n</head>\r\n\r\n<body>\r\n  <div class=\"demo\">\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2021/08/24/15/38/sand-6570980_960_720.jpg\" alt=\"1\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2013/02/21/19/06/drink-84533_960_720.jpg\" alt=\"2\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg\" alt=\"3\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_960_720.jpg\" alt=\"4\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2017/03/26/21/54/yoga-2176668_960_720.jpg\" alt=\"5\" />\r\n  </div>\r\n</body>\r\n<script>\r\n  const demo = document.querySelectorAll('img')\r\n  function lazy () {\r\n    for (let elem of demo) {\r\n      if (elem.getBoundingClientRect().top < document.documentElement.clientHeight) {\r\n        if (elem.dataset.src && elem.src == '') {\r\n          elem.src = elem.dataset.src\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function throttle (t, fn) {\r\n    let time\r\n    return function () {\r\n      if (!time) {\r\n        time = setTimeout(() => {\r\n          time = null\r\n          fn()\r\n        }, t)\r\n      }\r\n    }\r\n  }\r\n  lazy()\r\n  window.addEventListener('scroll', throttle(500, lazy))\r\n</script>\r\n\r\n</html>\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "LMW-lmw",
            "url": "https://github.com/LMW-lmw"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CxH2p",
          "body": "**方法三的简单 demo**\r\n\r\n```HTML\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>3.IntersectionObserver API + DataSet API</title>\r\n    <style>\r\n\r\n      * {\r\n        margin: 0px;\r\n        padding: 0px;\r\n      }\r\n\r\n      body {\r\n        margin: 0px;\r\n        padding: 0px;\r\n      }\r\n\r\n      img {\r\n        width: 100%;\r\n        height: 600px;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <img src=\"https://cdn.pixabay.com/photo/2021/08/24/15/38/sand-6570980_960_720.jpg\" alt=\"1\" />\r\n    <img src=\"https://cdn.pixabay.com/photo/2013/02/21/19/06/drink-84533_960_720.jpg\" alt=\"2\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2014/12/15/17/16/boardwalk-569314_960_720.jpg\" alt=\"3\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg\" alt=\"4\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_960_720.jpg\" alt=\"5\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2017/03/26/21/54/yoga-2176668_960_720.jpg\" alt=\"6\" />\r\n    <img data-src=\"https://cdn.pixabay.com/photo/2015/03/17/14/05/sparkler-677774_960_720.jpg\" alt=\"7\" />\r\n    <script>\r\n      const images = document.querySelectorAll('img')\r\n\r\n      // 新的 api  IntersectionObserver \r\n      const observer = new IntersectionObserver((changes) => {\r\n        changes.forEach(change => {\r\n          if (change.isIntersecting) {\r\n            const img = change.target\r\n            // if (img.dataset.src && img.src == \"\") {\r\n            //   img.src = img.dataset.src\r\n            // }\r\n            img.dataset.src && img.src == \"\" && (img.src = img.dataset.src)\r\n            observer.unobserve(img)\r\n          }\r\n        })\r\n      })\r\n\r\n      images.forEach(img => observer.observe(img))\r\n    </script>\r\n  </body>\r\n</html>\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "gethin036",
            "url": "https://github.com/gethin036"
          }
        },
        {
          "id": "IC_kwDODQzyOs5EWm_g",
          "body": "在vue中实现图片懒加载\r\nhttps://github.com/wangkaiwd/vue-image-lazy",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yanshuaidong",
            "url": "https://github.com/yanshuaidong"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Rez88",
          "body": "> **方法三的简单 demo**\r\n> \r\n> ```\r\n> <!DOCTYPE html>\r\n> <html lang=\"en\">\r\n>   <head>\r\n>     <meta charset=\"UTF-8\" />\r\n>     <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\r\n>     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n>     <title>3.IntersectionObserver API + DataSet API</title>\r\n>     <style>\r\n> \r\n>       * {\r\n>         margin: 0px;\r\n>         padding: 0px;\r\n>       }\r\n> \r\n>       body {\r\n>         margin: 0px;\r\n>         padding: 0px;\r\n>       }\r\n> \r\n>       img {\r\n>         width: 100%;\r\n>         height: 600px;\r\n>       }\r\n>     </style>\r\n>   </head>\r\n>   <body>\r\n>     <img src=\"https://cdn.pixabay.com/photo/2021/08/24/15/38/sand-6570980_960_720.jpg\" alt=\"1\" />\r\n>     <img src=\"https://cdn.pixabay.com/photo/2013/02/21/19/06/drink-84533_960_720.jpg\" alt=\"2\" />\r\n>     <img data-src=\"https://cdn.pixabay.com/photo/2014/12/15/17/16/boardwalk-569314_960_720.jpg\" alt=\"3\" />\r\n>     <img data-src=\"https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg\" alt=\"4\" />\r\n>     <img data-src=\"https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_960_720.jpg\" alt=\"5\" />\r\n>     <img data-src=\"https://cdn.pixabay.com/photo/2017/03/26/21/54/yoga-2176668_960_720.jpg\" alt=\"6\" />\r\n>     <img data-src=\"https://cdn.pixabay.com/photo/2015/03/17/14/05/sparkler-677774_960_720.jpg\" alt=\"7\" />\r\n>     <script>\r\n>       const images = document.querySelectorAll('img')\r\n> \r\n>       // 新的 api  IntersectionObserver \r\n>       const observer = new IntersectionObserver((changes) => {\r\n>         changes.forEach(change => {\r\n>           if (change.isIntersecting) {\r\n>             const img = change.target\r\n>             // if (img.dataset.src && img.src == \"\") {\r\n>             //   img.src = img.dataset.src\r\n>             // }\r\n>             img.dataset.src && img.src == \"\" && (img.src = img.dataset.src)\r\n>             observer.unobserve(img)\r\n>           }\r\n>         })\r\n>       })\r\n> \r\n>       images.forEach(img => observer.observe(img))\r\n>     </script>\r\n>   </body>\r\n> </html>\r\n> ```\r\n@gethinzz \r\nintersectionObserver这个方式，我试了，但是第三张出现到视口的时候，下面的图片全部一起加载完毕了。。。 isIntersecting 和 intersectionRatio的值都是一致的，这跟我理解的不一样，是我理解错了吗",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "MSpringy",
            "url": "https://github.com/MSpringy"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VU4_p",
          "body": "IntersectionObserver 也可以去做一些广告曝光统计。 \r\n\r\n我之前做过一个 统计 banner 广告曝光次数的需求，在用户看到这个 banner 的时候，去上报一下",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "croatialu",
            "url": "https://github.com/croatialu"
          }
        },
        {
          "id": "IC_kwDODQzyOs5WJVEX",
          "body": "> > **方法三的简单 demo**\r\n> > ```\r\n> > <!DOCTYPE html>\r\n> > <html lang=\"en\">\r\n> >   <head>\r\n> >     <meta charset=\"UTF-8\" />\r\n> >     <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\r\n> >     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n> >     <title>3.IntersectionObserver API + DataSet API</title>\r\n> >     <style>\r\n> > \r\n> >       * {\r\n> >         margin: 0px;\r\n> >         padding: 0px;\r\n> >       }\r\n> > \r\n> >       body {\r\n> >         margin: 0px;\r\n> >         padding: 0px;\r\n> >       }\r\n> > \r\n> >       img {\r\n> >         width: 100%;\r\n> >         height: 600px;\r\n> >       }\r\n> >     </style>\r\n> >   </head>\r\n> >   <body>\r\n> >     <img src=\"https://cdn.pixabay.com/photo/2021/08/24/15/38/sand-6570980_960_720.jpg\" alt=\"1\" />\r\n> >     <img src=\"https://cdn.pixabay.com/photo/2013/02/21/19/06/drink-84533_960_720.jpg\" alt=\"2\" />\r\n> >     <img data-src=\"https://cdn.pixabay.com/photo/2014/12/15/17/16/boardwalk-569314_960_720.jpg\" alt=\"3\" />\r\n> >     <img data-src=\"https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg\" alt=\"4\" />\r\n> >     <img data-src=\"https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_960_720.jpg\" alt=\"5\" />\r\n> >     <img data-src=\"https://cdn.pixabay.com/photo/2017/03/26/21/54/yoga-2176668_960_720.jpg\" alt=\"6\" />\r\n> >     <img data-src=\"https://cdn.pixabay.com/photo/2015/03/17/14/05/sparkler-677774_960_720.jpg\" alt=\"7\" />\r\n> >     <script>\r\n> >       const images = document.querySelectorAll('img')\r\n> > \r\n> >       // 新的 api  IntersectionObserver \r\n> >       const observer = new IntersectionObserver((changes) => {\r\n> >         changes.forEach(change => {\r\n> >           if (change.isIntersecting) {\r\n> >             const img = change.target\r\n> >             // if (img.dataset.src && img.src == \"\") {\r\n> >             //   img.src = img.dataset.src\r\n> >             // }\r\n> >             img.dataset.src && img.src == \"\" && (img.src = img.dataset.src)\r\n> >             observer.unobserve(img)\r\n> >           }\r\n> >         })\r\n> >       })\r\n> > \r\n> >       images.forEach(img => observer.observe(img))\r\n> >     </script>\r\n> >   </body>\r\n> > </html>\r\n> > ```\r\n> \r\n> @gethinzz intersectionObserver这个方式，我试了，但是第三张出现到视口的时候，下面的图片全部一起加载完毕了。。。 isIntersecting 和 intersectionRatio的值都是一致的，这跟我理解的不一样，是我理解错了吗\r\n\r\n这里需要将图片给一个默认高度，因为页面滚动的时候，懒加载的图片都没有宽高，所以滚动判断会认为该元素已经在可视区域了\r\n你可以在 img.dataset.src && img.src == \"\" && (img.src = img.dataset.src) 这一句上面加一个断点，就能看到懒加载图片都是破损状态，但是都在可视区域内了\r\n```\r\n<style>\r\n    body {\r\n      display: flex;\r\n      flex-direction: column;\r\n    }\r\n\r\n    img {\r\n      min-height: 640px;\r\n    }\r\n  </style>\r\n````",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhengaimin",
            "url": "https://github.com/zhengaimin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY0MjgxNDI=",
    "number": 2,
    "title": "【Q002】当 ping 一个 IP 地址时发生了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTMzNjQ4Nw==",
          "body": "从 `ping` 的 `man` 手册就可以看出来，`ping` 实际上发送了 **`ICMP ECHO_REQUEST`** 的报文\r\n\r\n> ping -- send ICMP ECHO_REQUEST packets to network hosts\r\n\r\n通过让目标 IP 地址返回 **`ICMP ECHO_RESPONSE`** 报文来判断 IP 可不可达。\r\n\r\n`ICMP` 分为 `Query` 查询报文及 `Error Message` 报文，ping 为查询报文。",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTUzMjA=",
    "number": 3,
    "title": "【Q003】什么是防抖和节流，他们的应用场景有哪些",
    "body": "追问：\r\n\r\n1. 如何要在时间刚开始就执行一次，应如何处理，如同 [lodash/debounce](https://lodash.com/docs/4.17.15#debounce) 的 `leading`\r\n2. 如何实现防抖函数的取消，如 lodash/debounce",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTU0MA==",
          "body": "####  防抖(debounce)\r\n触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\r\n\r\n##### 示例代码\r\n```javascript\r\n    // 防抖函数\r\n    function debounce(fn, wait) {\r\n        let timer;\r\n        return function() {\r\n            let _this = this;\r\n            let args = arguments;\r\n            if(timer) { clearTimeout(timer) }\r\n            timer = setTimeout(function(){\r\n                fn.apply(_this, args)\r\n            }, wait);      \r\n        }\r\n    }\r\n    // 使用\r\n    window.onresize = debounce(function() {console.log('resize')}, 500)\r\n```\r\n\r\n#### 节流(throttle)\r\n高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率\r\n##### 示例代码\r\n\r\n```javascript\r\n    // 方式1: 使用时间戳\r\n    function throttle1(fn, wait) {\r\n        let time = 0;\r\n        return function() {\r\n            let _this = this;\r\n            let args = arguments;\r\n            let now = Date.now()\r\n            if(now - time > wait) {\r\n                fn.apply(_this, args);\r\n                time = now;\r\n            }\r\n        }\r\n    }\r\n    // 方式2: 使用定时器\r\n    function thorttle2(fn, wait) {\r\n        let timer;\r\n        return function () {\r\n            let _this = this;\r\n            let args = arguments;\r\n            \r\n            if(!timer) {\r\n                timer = setTimeout(function(){\r\n                    timer = null;\r\n                    fn.apply(_this, args)\r\n                }, wait)\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n上面`节流`和`防抖`实现方式比较简单，但是已经可以满足日常使用，如果想更近一步了解可以查看[underscore](https://www.bootcss.com/p/underscore/)和[lodash](https://www.lodashjs.com/docs/latest)文档中`debounce`和`thorttle`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xiaoai7904",
            "url": "https://github.com/xiaoai7904"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1Mzg5OTIzNw==",
          "body": "## 防抖 (debounce)\r\n\r\n防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。\r\n\r\n想要了解一个概念，必先了解概念所应用的场景。在 JS 这个世界中，有哪些防抖的场景呢\r\n\r\n1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖\r\n1. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖\r\n1. 文本编辑器实时保存，当无任何更改操作一秒后进行保存\r\n\r\n代码如下，可以看出来**防抖重在清零 `clearTimeout(timer)`**\r\n\r\n``` js\r\nfunction debounce (f, wait) {\r\n  let timer\r\n  return (...args) => {\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      f(...args)\r\n    }, wait)\r\n  }\r\n}\r\n```\r\n\r\n## 节流 (throttle)\r\n\r\n节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。\r\n\r\n1. `scroll` 事件，每隔一秒计算一次位置信息等\r\n1. 浏览器播放事件，每个一秒计算一次进度信息等\r\n1. input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)\r\n\r\n代码如下，可以看出来**节流重在加锁 `timer=timeout`**\r\n\r\n``` js\r\nfunction throttle (f, wait) {\r\n  let timer\r\n  return (...args) => {\r\n    if (timer) { return }\r\n    timer = setTimeout(() => {\r\n      f(...args)\r\n      timer = null\r\n    }, wait)\r\n  }\r\n}\r\n```\r\n\r\n## 总结 (简要答案)\r\n\r\n+ 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。**代码实现重在清零 `clearTimeout`**。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。\r\n+ 节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。**代码实现重在开锁关锁 `timer=timeout; timer=null`**。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。",
          "star": {
            "totalCount": 10
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs48RR7m",
          "body": "你好，向请问一下防抖函数的`let _this = this`的作用是什么，这里的`this`不是都指向window吗？小白求指教，谢谢！！！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Janezhang650",
            "url": "https://github.com/Janezhang650"
          }
        },
        {
          "id": "IC_kwDODQzyOs5AXGM1",
          "body": "防抖函数里面有可能有this相关的语句，this必须指向调用它的对象，而定时器里面指向全局对象window是不合适的。",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "0124z",
            "url": "https://github.com/0124z"
          }
        },
        {
          "id": "IC_kwDODQzyOs5p5Uhs",
          "body": "我觉得上面两个节流函数有点问题, 我的理解是节流函数执行的是用户点击的第一次, 以上的节流函数都是延迟执行的, 其实都属于防抖函数, 如有错误, 请指正\r\n```javascript\r\nfunction throttle(f, wait){\r\n  let isThrottled = false; \r\n  return (...args) => { \r\n    if (!isThrottled) { \r\n       f(...args);\r\n       isThrottled = true; \r\n       setTimeout(() => { isThrottled = false; }, wait); \r\n    } \r\n  };\r\n}\r\n``` ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xylon001",
            "url": "https://github.com/xylon001"
          }
        },
        {
          "id": "IC_kwDODQzyOs5p5ZzC",
          "body": "用时间戳的实现\r\n```javascript\r\nfunction throttle(func, delay) {\r\n  let lastExecTime = 0;\r\n\r\n  return function (...args) {\r\n    const currentTime = Date.now();\r\n\r\n    if (currentTime - lastExecTime >= delay) {\r\n      func.apply(this, args);\r\n      lastExecTime = currentTime;\r\n    }\r\n  };\r\n}\r\n``` ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xylon001",
            "url": "https://github.com/xylon001"
          }
        },
        {
          "id": "IC_kwDODQzyOs5p5r8U",
          "body": "@xylon001 其实没有问题，你这个是实现的 leading=true，而上边实现的是 trailing=true，可以参考 https://lodash.com/docs/4.17.15#throttle API。\r\n\r\n而且你实现时，先执行函数，再加锁，这时会存在竟态问题，当你这个函数执行时间为十分钟的话，那十分钟会进来很多操作。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5p6GjB",
          "body": "> @xylon001 其实没有问题，你这个是实现的 leading=true，而上边实现的是 trailing=true，可以参考 https://lodash.com/docs/4.17.15#throttle API。\r\n> \r\n> 而且你实现时，先执行函数，再加锁，这时会存在竟态问题，当你这个函数执行时间为十分钟的话，那十分钟会进来很多操作。\r\n\r\n确实, 会有竟态问题, 而且之前对于throttle 的理解有误, throttle 的定义应该是在事件触发后设定一个定时器，在定时器设定的时间间隔内，无论事件触发多少次，都只执行一次操作。只有当定时器计时结束后，才会再次触发事件并执行操作。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xylon001",
            "url": "https://github.com/xylon001"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTU2NzM=",
    "number": 4,
    "title": "【Q004】如何获取一个进程的内存并监控",
    "body": "在编写脚本时，有时会出现内存过大发生 OOM 的事情，那我们如何得知某个进程的内存？另外又如何监控它",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MjE4MQ==",
          "body": "通过 `ps` 可以获知一个进程所占用的内存\r\n\r\n``` bash\r\n$ ps -O rss -p 3506\r\n  PID   RSS S TTY          TIME COMMAND\r\n 3506  6984 S pts/1    00:00:00 vim\r\n```\r\n\r\n如果要**监控**内存，需要使用对进程万能的命令 `pidstat` （PS: 这名字一听就知道是干嘛的）\r\n\r\n``` bash\r\n# -r 显示内存信息\r\n# -p 指定 pid\r\n# 1: 每个一秒打印一次\r\n$ pidstat -r -p 3506 1\r\nLinux 3.10.0-957.21.3.el7.x86_64 (shanyue)      11/04/19        _x86_64_        (2 CPU)\r\n\r\n20:47:35      UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command\r\n20:47:36        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:37        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:38        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:39        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:40        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:41        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n```\r\n\r\n`pidstat` 是属于 `sysstat` 下的 linux 性能工具，但在 mac 中，如何定位内存的变化？此时可以使用万能的 `top/htop`\r\n\r\n ``` bash\r\n $ htop -p 31796\r\n ```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/86353210-7b210080-bc99-11ea-9885-8e5ca1b909b5.png)\r\n\r\n## 总结\r\n\r\n简而言之，有以下三个命令\r\n\r\n1. `pidstat -r`，只在 linux 环境下使用\r\n1. `htop/top -p`\r\n1. `ps -O rss -p`\r\n\r\n关于更多指标的监控可以参考我的文章: [linux 各项监控指标小记](https://shanyue.tech/op/linux-monitor.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTY0NDM=",
    "number": 6,
    "title": "【Q005】生产环境的某个接口报错，如何定位",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0NTU1Ng==",
          "body": "通常按照以下步骤进行定位\r\n\r\n1. 测试环境是否能够复现，若复现在测试环境测试并修复\r\n1. 有没有异常报警系统，如 `sentry`，如果有在 `sentry` 中查看异常堆栈信息以及相关上下文，定位代码\r\n1. 如果堆栈信息不足够找到问题，看有没有链路追踪工具，如 `zipkin`。从 `sentry` 中找到 `requestId/traceId`，通过 `requestId` 结合 `kibana` / `ElasticSearch` 定位相关的数据库日志/上下游服务链路日志\r\n1. 如果以上都不行，查看接口相关代码\r\n\r\n既然报错，那么一定会在异常上报系统中找到这条问题进行定位。如果在报警系统中没有定位到问题，可以查看\r\n\r\n1. 报警系统是否已限流，致使无法上报\r\n1. 复现异常时，抓包查看报警相关的 API，查看是否已上报\r\n\r\n最怕的是那种接口没报错，但是业务方反馈数据有误的问题了，只能开了 debug，进行代码调试了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc2NTMxMQ==",
          "body": "zipkin sleuth",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangxiaokun",
            "url": "https://github.com/zhangxiaokun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5MjM2NzU=",
    "number": 7,
    "title": "【Q006】如何写一个 SQL 获取分组 top n 的数据",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前三名",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTIzNDQxOQ==",
          "body": "通过一个自连接可以获取到\r\n\r\n``` sql\r\nselect id, class_id, score from student s1 where (\r\n  -- 对比每行 student，通过自连接找到该班中比该 student 分数要高与等于的人数，即排名\r\n  select count(*) from student s2 where s2.class_id = s1.class_id and s2.score >= s1.score\r\n) = 1\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMDI0NjUzMA==",
          "body": "```sql\r\nselect id, class_id, score from student s1 where exists(select count(*) from student s2 where s2.score >= s1.score and s2.class_id=s1.class_id group by s2.class_id having count(*)<=3) order by class_id, score desc;\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Skylor-Tang",
            "url": "https://github.com/Skylor-Tang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5ODg0NTQ=",
    "number": 8,
    "title": "【Q007】如何写一个 SQL 获取分组 top 1 的数据 ",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前一名\r\n\r\n与 [Top n](https://github.com/shfshanyue/Daily-Question/issues/7) 类似，不过有更简单的方法\r\n\r\n（当然考虑到并列情况就会复杂很多",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MzI2OA==",
          "body": "单纯的获取 Top 1，只需要 `group by` 加聚合函数，不过复杂的还是参考 [top n](https://github.com/shfshanyue/Daily-Question/issues/7)\r\n\r\n``` sql\r\nselect class_id, max(score) from student group by class_id\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5OTQ0NTk=",
    "number": 9,
    "title": "【Q008】当新入职一家公司时，如何快速搭建开发环境并让应用跑起来",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM1MTAyOA==",
          "body": "新人入职新上手项目，如何把它跑起来，这是所有人都会碰到的问题：所有人都是从新手开始的。\r\n\r\n有可能你会脱口而出：`npm run dev/npm start`，但实际工作中，处处藏坑，往往没这么简单。\r\n\r\n1. 查看是否有 `CI/CD`，如果有跟着 `CI/CD` 部署的脚本跑命令\r\n1. 查看是否有 `dockerfile`，如果有跟着 `dockerfile` 跑命令\r\n1. 查看 npm scripts 中是否有 dev/start，尝试 `npm run dev/npm start`\r\n1. 查看是否有文档，如果有跟着文档走。为啥要把文档放到最后一个？原因你懂的\r\n\r\n但即便是十分谨慎，也有可能遇到以下几个叫苦不迭、浪费了一下午时间的坑:\r\n\r\n1. 前端有可能在**本地环境启动时需要依赖前端构建时所产生的文件**，所以有时需要**先正常部署一遍，再试着按照本地环境启动 (即需要先 `npm run build` 一下，再 `npm run dev/npm start`)**。(比如，一次我们的项目 npm run dev 时需要 webpack DllPlugin 构建后的东西）\r\n1. 别忘了设置环境变量或者配置文件 (.env/consul/k8s-configmap)\r\n\r\n因此，设置一个少的 script，可以很好地避免后人踩坑，更重要的是，可以避免后人骂你，\r\n\r\n此时可设置 script hooks，如 `prepare`、`postinstall` 自动执行脚本，来完善该项目的基础设施\r\n\r\n``` json\r\n{\r\n  \"scripts\": {\r\n    \"start\": \"npm run dev\",\r\n    \"config\": \"node assets && node config\",\r\n    \"build\": \"webpack\",\r\n    // 设置一个钩子，在 npm install 后自动执行，此处有可能不是必须的\r\n    \"prepare\": \"npm run build\",\r\n    \"dev\": \"webpack-dev-server --inline --progress\"\r\n  }\r\n}\r\n```\r\n\r\n## npm run dev 与 npm start 的区别\r\n\r\n对于一个**纯生成静态页面打包**的前端项目而言，它们是没有多少区别的：生产环境的部署只依赖于构建生成的资源，更不依赖 npm scripts。可见 [如何部署前端项目](https://shanyue.tech/frontend-engineering/docker.html)。\r\n\r\n使用 `create-react-app` 生成的项目，它的 npm script 中只有 `npm start`\r\n\r\n``` json\r\n{\r\n  \"start\": \"react-scripts start\",\r\n  \"build\": \"react-scripts build\",\r\n  \"test\": \"react-scripts test\",\r\n  \"eject\": \"react-scripts eject\"\r\n}\r\n```\r\n\r\n使用 `vuepress` 生成的项目，它的 npm script 中只有 `npm run dev`\r\n\r\n``` json\r\n{\r\n  \"dev\": \"vuepress dev\",\r\n  \"build\": \"vuepress build\"\r\n}\r\n```\r\n\r\n在一个**面向服务端**的项目中，如 `next`、`nuxt` 与 `nest`。dev 与 start 的区别趋于明显，一个为生产环境，一个为开发环境\r\n\r\n+ dev: 在开发环境启动项目，一般带有 watch 选项，监听文件变化而重启服务，此时会耗费大量的 CPU 性能，不宜放在生产环境\r\n+ start: 在生产环境启动项目\r\n\r\n在 `nest` 项目中进行配置\r\n\r\n``` json\r\n{\r\n  \"start\": \"nest start\",\r\n  \"dev\": \"nest start --watch\"\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs47iwQL",
          "body": "我的意见和楼上相反，应该先大概看一遍文档…… 文档中会描述本地环境的配置方法\r\n\r\n```\r\n查看是否有 CI/CD，如果有跟着 CI/CD 部署的脚本跑命令\r\n查看是否有 dockerfile，如果有跟着 dockerfile 跑命令\r\n查看 npm scripts 中是否有 dev/start，尝试 npm run dev/npm start\r\n```\r\n\r\n大部分公司的开发环境都是本地环境，所以什么 CI/CD、Docker 可以先放到一边\r\n\r\nnpm run dev/npm start 这个是一般的约定，但不是所有的项目都是这样。所以需要先看 package.json 中的 script 来确定\r\n\r\n### npm run dev 和 npm start 的区别？\r\n\r\n1. npm start 是 npm run start 的别名，支持 prestart 和 poststart 钩子",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "IC_kwDODQzyOs4-dZ2t",
          "body": "> 我的意见和楼上相反，应该先大概看一遍文档…… 文档中会描述本地环境的配置方法\r\n> \r\n> ```\r\n> 查看是否有 CI/CD，如果有跟着 CI/CD 部署的脚本跑命令\r\n> 查看是否有 dockerfile，如果有跟着 dockerfile 跑命令\r\n> 查看 npm scripts 中是否有 dev/start，尝试 npm run dev/npm start\r\n> ```\r\n> \r\n> 大部分公司的开发环境都是本地环境，所以什么 CI/CD、Docker 可以先放到一边\r\n> \r\n> npm run dev/npm start 这个是一般的约定，但不是所有的项目都是这样。所以需要先看 package.json 中的 script 来确定\r\n> \r\n> ### npm run dev 和 npm start 的区别？\r\n> 1. npm start 是 npm run start 的别名，支持 prestart 和 poststart 钩子\r\n\r\n你是真没吃过文档的亏。。。管他什么公司，文档都有坑。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DOFl6",
          "body": "先看readme啊，node版本之类的都不知道，待会node-sass之类的东西都装不上岂不是搞笑了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Gumplefik",
            "url": "https://github.com/Gumplefik"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc1ODAwMTc=",
    "number": 10,
    "title": "【Q009】如何实现一个元素的水平垂直居中",
    "body": "要求对行内元素、块状元素及不定宽高的块状元素均可适用：\r\n\r\n可打开 codepen 进行调试: <https://codepen.io/shanyue/pen/XWMdabg>，以下是布局代码\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\" style=\"width: 100px; height: 100px; background: #999;\">\r\n    块状元素\r\n  </div>\r\n</div>\r\n\r\n<div class=\"container\">\r\n  <div class=\"item\">不定高宽的块状元素</div>\r\n</div>\r\n\r\n<div class=\"container\">\r\n  <span class=\"item\">行内元素</span>\r\n</div>\r\n```\r\n\r\n``` scss\r\n.container {\r\n   // 把代码写在这里\r\n}\r\n\r\n.container {\r\n  height: 20rem;\r\n  background: #ccc;\r\n  margin: 1rem;\r\n}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTEzMjAxNw==",
          "body": "绝对定位方法：\r\n```\r\n.box {\r\n  postion: absolute;\r\n  top: 50%;\r\n  bottom: 50%;\r\n  width: 50px;\r\n  height: 50px;\r\n  transform: translate(-50%, -50%);\r\n}\r\n<body>\r\n<div class=\"box\"><div>\r\n</body>\r\n```\r\n\r\nflex方法：\r\n```\r\nbody {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n.box {\r\n  width: 50px;\r\n  height: 50px;\r\n}\r\n\r\n<body>\r\n<div class=\"box\"><div>\r\n</body>\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "woohs",
            "url": "https://github.com/woohs"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTM1MTM2Nw==",
          "body": "提供一些现代浏览器下使用 `flex/grid` 的方法，不仅支持块状元素，而且支持行内元素，对固定高宽与不固定高宽皆可使用。\r\n\r\n使用 `flex`，以下是经典的垂直居中。\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n使用 `grid`，它是做二维布局的，但是只有一个子元素时，一维布局与二维布局就一样了。\r\n\r\n结合 `justify-content`/`justify-items` 和 `align-content/align-items` 就有四种方案\r\n\r\n效果可以见 [codepen](https://codepen.io/shanyue/pen/XWMdabg)\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-content: center;\r\n  align-content: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-items: center;\r\n  align-content: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-items: center;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n三个属性略显啰嗦，其实只需两个属性即可:\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  place-items: center;\r\n}\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  place-content: center;\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTUzMTA5NQ==",
          "body": "引自：https://css-tricks.com/centering-css-complete-guide/\r\n1 该元素的宽高固定吗？\r\n在将元素绝对定位为top: 50%; left: 50%;后，可以使用值为宽的一半和高的一半的负margin实现垂直水平居中。（跨浏览器支持很不错）\r\n```\r\n.parent {\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  width: 300px;\r\n  height: 100px;\r\n  padding: 20px;\r\n\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n\r\n  margin: -70px 0 0 -170px;\r\n}\r\n```\r\n2 该元素宽高未知？\r\n（1）如果宽高未知，在将元素绝对定位为top: 50%; left: 50%;后，可以使用transform属性来做负的50%移动（基于当前元素宽高）。\r\n```\r\n.parent {\r\n  position: relative;\r\n}\r\n.child {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n（2）也可以元素相对父容器绝对定位(left: 0;right: 0;top: 0;bottom: 0;)并margin: auto，不需要提前知道尺寸兼容性好。\r\n```\r\n.container {\r\n  position: relative;\r\n  height: 300px;\r\n  border: 1px solid red;\r\n}\r\n.item {\r\n  width: 100px;\r\n  height: 50px;\r\n  position: absolute;\r\n  left: 0;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  border: 1px solid green;\r\n}\r\n```\r\n3 你要用flexbox吗？\r\n对flexbox进行垂直水平居中，只需设置两个属性为center: align-items、justify-content。\r\n```\r\n.parent {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n4 你要用grid布局吗？\r\n父容器设置为grid布局后，子元素直接margin: auto;即可实现垂直水平居中。\r\n```\r\nbody, html {\r\n  height: 100%;\r\n  display: grid;\r\n}\r\nspan { /* thing to center */\r\n  margin: auto;\r\n}\r\n```\r\n详细案例解释可参考：https://zhuanlan.zhihu.com/p/87134477",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5NDgyMzc1NQ==",
          "body": "你不知道的 flex 布局～\r\n\r\n```\r\n.box {\r\n  display: flex;\r\n}\r\n\r\n.item {\r\n  margin: auto;\r\n}\r\n```",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "lastSeries",
            "url": "https://github.com/lastSeries"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MTA3MTYzNQ==",
          "body": "> 你不知道的 flex 布局～\r\n> \r\n> ```\r\n> .box {\r\n>   display: flex;\r\n> }\r\n> \r\n> .item {\r\n>   margin: auto;\r\n> }\r\n> ```\r\n\r\n这个方法眼前一亮，试了一下: 行内元素与块状元素均可，学习了！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs43jiJZ",
          "body": "> > 你不知道的 flex 布局～\r\n> > ```\r\n> > .box {\r\n> >   display: flex;\r\n> > }\r\n> > \r\n> > .item {\r\n> >   margin: auto;\r\n> > }\r\n> > ```\r\n> \r\n> 这个方法眼前一亮，试了一下: 行内元素与块状元素均可，学习了！\r\n\r\nhttps://css-tricks.com/the-peculiar-magic-of-flexbox-and-auto-margins/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "babycannotsay",
            "url": "https://github.com/babycannotsay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTA0MTY=",
    "number": 11,
    "title": "【Q010】了解 React 中的 ErrorBoundary 吗，它有那些使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4Mjg3OQ==",
          "body": "待答",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzAzNjkwMw==",
          "body": "从其他文章里看到的 避免错误渲染白屏做异常中间处理的嵌套组件\r\nclass ErrorBoundary extends Component {\r\n  static getDerivedStateFromError() {\r\n    return { hasError: true };\r\n  }\r\n  state = {\r\n    hasError: false,\r\n  };\r\n  componentDidCatch(error, info) {\r\n    // reportError(error, info);\r\n  }\r\n  render() {\r\n    const { hasError } = this.state;\r\n    const { children } = this.props;\r\n    if (hasError) {\r\n      return <div>系统异常，请稍后再试</div>;\r\n    }\r\n    return children;\r\n  }\r\n}\r\nfunction render(Component, props) {\r\n  const rootElement = document.getElementById(\"root\");\r\n  ReactDOM.render(\r\n    <ErrorBoundary>\r\n      <Component {...props} />\r\n    </ErrorBoundary>,\r\n    rootElement\r\n  );\r\n}\r\n\r\n作者：蚂蚁保险体验技术\r\n链接：https://juejin.im/post/5de91d0f51882512400acafd\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "geekftz",
            "url": "https://github.com/geekftz"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk1OTE0Mw==",
          "body": "是 react 内的一个钩子，用于在组件内发生了 js 错误时候的错误处理。\r\n使用场景是在发生 js 报错的时候不至于说白屏，可以转去别的页面提示用户这里报了错，转用别的去到去继续操作。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "BertieGo",
            "url": "https://github.com/BertieGo"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTAxODEyMw==",
          "body": "这不就是try catch么。。。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "baihech",
            "url": "https://github.com/baihech"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTAxODI3NQ==",
          "body": "错误不抛出，交给catch处理，然鹅并不能预先知道错误类型。。。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "baihech",
            "url": "https://github.com/baihech"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3MjM1MA==",
          "body": "[前端防御性编程](https://juejin.im/post/5de91d0f51882512400acafd#heading-9)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUyOTQ2Nw==",
          "body": "了解，在推出之前报错会直接白屏，总是需要我们前端进行手动try catch，react16新增了两个生命周期componentdidcatch和static getDerivedStateFromError从框架级别让我们更方便捕捉异常并显示备用ui。其实就是在整个workloop外面包一层try catch，报错时候遍历父组件找到这两个生命周期并把堆栈信息塞给生命周期进行判断。",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUyOTYyNA==",
          "body": "顺带一句suspense的原理好像也是这个",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DgQnF",
          "body": "嵌套的比较深的组件存在出错的风险，组件自身没有容错机制，会逐层交给外层组件处理。这个过程会导致整个组件树销毁。页面结果就是白屏。而且生产环境不会报出有效的错误信息，不好定位问题。\r\n使用ErrorBoundary 就是在可能出错的组件上套一层组件，在这个新的组件中去容错",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Murraya-paniculata",
            "url": "https://github.com/Murraya-paniculata"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTIxNTM=",
    "number": 12,
    "title": "【Q011】vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTk0OQ==",
          "body": "简单描述就是: 性能更好，解决无法监听数组变化问题",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xiaoai7904",
            "url": "https://github.com/xiaoai7904"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MzUwOTUzNw==",
          "body": "1. 可以提高实例初始化启动速度，优化数据响应式系统，由全部监听改为惰性监听（lazy by default)。\r\n2. 数据响应式系统全语言特性支持，添加数组索引修改监听，对象的属性增加和删除。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "konglingwen94",
            "url": "https://github.com/konglingwen94"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczNDEyNTk0Mw==",
          "body": "1. Vue2.x通过给每个对象添加`getter setter`属性去改变对象,实现对数据的观测,Vue3.x通过Proxy代理目标对象,且一开始只代理最外层对象,嵌套对象`lazy by default` ,性能会更好\r\n2. 支持数组索引修改,对象属性的增加,删除\r\n",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "hefeng1208",
            "url": "https://github.com/hefeng1208"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxODk2MDQ=",
    "number": 13,
    "title": "【Q012】helm v3 中为什么要弃用 tiller",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc3NjMxNA==",
          "body": "`helm` v2 中，`helm client` 通过 gRPC 把 `Chart` 交给 `tiller`。`tiller` 是 k8s 中的一个 `pod`，在 `k8s` 集群中根据 `Chart` 以及配置信息部署资源，架构图如下\r\n\r\n![https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg](https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg)\r\n\r\n这有一个问题，`tiller` 有一个最高权限的 RBAC，而运维，开发众多权限不同的人都可以通过 `tiller` 这个最高权限来部署新的应用，会产生相应的安全问题。\r\n\r\n于是，`helm v3` 去掉了 `tiller`，它的权限控制基于操作人员的 `kubeconfig`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTIzNTg=",
    "number": 14,
    "title": "【Q013】有没有使用过 react hooks，它带来了那些便利",
    "body": "有没有使用过 react hooks，它有哪些优缺点？",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODI0NDg1NA==",
          "body": "依我的看法，`React hooks` 主要解决了状态以及副作用难以复用的场景，除此之外，他对我最大的好处就是在 `Console` 中不会看到重重叠叠相同名字的组件了(HOC)。\r\n\r\n目前使用感觉最爽的两个hook，都是关于请求的。一个是 `apollo-client` 的 `useQuery`，一个是 [swr](https://github.com/zeit/swr)。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3MjYxMw==",
          "body": "1.HOC嵌套地狱\r\n2.this\r\n3.逻辑复用\r\n3.tree-shaking",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2ODUyOTM1OQ==",
          "body": "个人最喜欢的两个点\r\n1， 再也不用操心讨厌的this的问题\r\n2，逻辑复用更加方便，代码逻辑更加清晰",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JeffWong16",
            "url": "https://github.com/JeffWong16"
          }
        },
        {
          "id": "IC_kwDODQzyOs40krPB",
          "body": "不用去写生命周期了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Muralitob",
            "url": "https://github.com/Muralitob"
          }
        },
        {
          "id": "IC_kwDODQzyOs5bhy4i",
          "body": "1.类组件比起函数组件更难以理解。\r\n\r\n2.无需修改组件结构的情况下复用状态逻辑，状态管理更加清晰。\r\n\r\n3.不用写类函数就可以使用更多的 React 特性。 \r\n\r\n4.更符合 React 本身的思想，函数式、组件化。\r\n\r\n5.组件树层级变浅 （原本的HOC/render props 等方式增加了组件树层数及渲染，在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”，这些功能都可以通过强大的自定义的 Hooks 来实现。）\r\n\r\n6.不用再去考虑 this 的指向、生命周期问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yangzi0210",
            "url": "https://github.com/yangzi0210"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTU3NDc=",
    "number": 15,
    "title": "【Q014】如何使用 react hooks 实现一个计数器的组件",
    "body": "如何使用 react hooks 实现最简单一个计数器的组件\r\n\r\n为了保证最最简单化，不需要暂停与开始状态",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk0NjY4MQ==",
          "body": "```\r\nimport React, { useState, useEffect } from 'react'\r\nimport useCountDown from './useCountDown'\r\n\r\nconst useCountDown = (num) => {\r\n    const [seconds, setSecond] = useState(num)\r\n\r\n    useEffect(() => {\r\n        setTimeout(() => {\r\n            if (seconds > 0) {\r\n                setSecond(c => c - 1);\r\n            }\r\n        }, 1000);\r\n    }, [seconds]);\r\n\r\n    return [seconds, setSecond]\r\n}\r\n\r\n// use it\r\nconst Demo = () => {\r\n    const [seconds, setSecond] = useCountDown(0)\r\n    return (\r\n             <Button \r\n                disable={seconds !== 0} \r\n                onClick={() => setSecond(59)} \r\n            >\r\n                {seconds > 0 ? `${seconds}s后可点击` : '点击开始倒计时'}\r\n            </Button>\r\n        )\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "Hack-Jay",
            "url": "https://github.com/Hack-Jay"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk0NzQ2Mw==",
          "body": "``` js\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    useEffect(() => {\r\n        setInterval(() => {\r\n            setCount(count => count + 1)\r\n        }, 1000)\r\n    }, [])\r\n\r\n    return <h1>{count}</h1>\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bWhirring",
            "url": "https://github.com/bWhirring"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk2MjY4Mg==",
          "body": "```js\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    useEffect(() => {\r\n        const timer = setInterval(() => {\r\n            setCount(count => count + 1)\r\n        }, 1000)\r\n\r\n        return () => {\r\n           clearInterval(timer)\r\n        }\r\n    }, [])\r\n\r\n    return <h1>{count}</h1>\r\n}\r\n```",
          "star": {
            "totalCount": 14
          },
          "author": {
            "login": "shaul-xu",
            "url": "https://github.com/shaul-xu"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MTI2Nzc4NA==",
          "body": "代码见 [如何使用 React Hooks 实现计数器组件 - codesandbox](https://codesandbox.io/s/shiyong-react-hooks-ruheshixianyigejishuqi-counter-tc5u1?file=/src/App.js) \r\n\r\n可使用 `setTimeout` 与 `setInterval` 实现。\r\n\r\n其中，使用 setTimeout 实现时，当页面处于不可见 (`document.hidden = false`) 状态时，将可能会停止计时，建议使用 `setInterval` 实现\r\n\r\n``` js\r\nimport { useEffect, useState } from \"react\";\r\nimport \"./styles.css\";\r\n\r\nfunction CounterWithTimeout() {\r\n  const [count, setCount] = useState(0);\r\n  useEffect(() =>\r\n    setTimeout(() => {\r\n      setCount(count + 1);\r\n    }, 1000)\r\n  );\r\n  return <h1>{count}</h1>;\r\n}\r\n\r\nfunction CounterWithInterval() {\r\n  const [count, setCount] = useState(0);\r\n  useEffect(() => {\r\n    const timer = setInterval(() => {\r\n      setCount((count) => count + 1);\r\n    }, 1000);\r\n\r\n    return () => {\r\n      clearInterval(timer);\r\n    };\r\n  }, []);\r\n\r\n  return <h1>{count}</h1>;\r\n}\r\n\r\nexport default function App() {\r\n  return (\r\n    <div>\r\n      <CounterWithTimeout />\r\n      <CounterWithInterval />\r\n    </div>\r\n  );\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DOJiy",
          "body": "这题不要想当然的就超时1s加或者减1，要记录开始时间戳，重新set时检查剩余多少秒，去set对应的值。\r\n定时器都是指定时间后开始执行，不是指定时间执行",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Gumplefik",
            "url": "https://github.com/Gumplefik"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTkxNjI4Nzg=",
    "number": 16,
    "title": "【Q015】你们的前端项目是如何在线上部署的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTA3MDkyMA==",
          "body": "> 今天正好写了一篇长文来回答这个问题\r\n\r\n前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 `react`/`vue`/`angular`，`es6+`，`webpack`，`babel`，`typescript` 以及 `node` 的发展，前端已经在逐渐替代过去 script 引 cdn 开发的方式了，掀起了工程化这一大浪潮。得益于工程化的发展与开源社区的良好生态，前端应用的可用性与效率得到了很大提高。\r\n\r\n前端以前是刀耕火种，那前端应用部署在以前也是刀耕火种。那前端应用部署的发展得益于什么，随前端工程化带来的副产品？\r\n\r\n这只是一部分，而更重要的原因是 `devops` 的崛起。\r\n\r\n为了更清晰地理解前端部署的发展史，了解部署时运维和前端（或者更广泛地说，业务开发人员）的职责划分，当每次前端部署发生改变时，可以思考两个问题\r\n\r\n1. 缓存，前端应用中http 的 `response header` 由谁来配？得益于工程化发展，可以对打包后得到带有 hash 值的文件可以做永久缓存\r\n1. 跨域，`/api` 的代理配置由谁来配？在开发环境前端可以开个小服务，启用 `webpack-dev-server` 配置跨域，那生产环境呢\r\n\r\n这两个问题都是前端面试时的高频问题，但话语权是否掌握在前端手里\r\n\r\n时间来到 `React` 刚刚发展起来的这一年，这时已经使用 `React` 开发应用，使用 `webpack` 来打包。但是前端部署，仍是刀耕火种\r\n\r\n## 刀耕火种\r\n\r\n一台跳板机\r\n\r\n一台生产环境服务器\r\n\r\n一份部署脚本\r\n\r\n前端调着他的 `webpack`，开心地给运维发了部署邮件并附了一份部署脚本，想着第一次不用套后端的模板，第一次前端可以独立部署。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n运维照着着前端发过来的部署邮件，一遍又一遍地拉着代码，改着配置，写着 `try_files`， 配着 `proxy_pass`。\r\n\r\n这时候，前端静态文件由 `nginx` 托管，`nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    # 避免非root路径404\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  # 解决跨域\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n\r\n  # 为带 hash 值的文件配置永久缓存\r\n  location ~* \\.(?:css|js)$ {\r\n      try_files $uri =404;\r\n      expires 1y;\r\n      add_header Cache-Control \"public\";\r\n  }\r\n\r\n  location ~ ^.+\\..+$ {\r\n      try_files $uri =404;\r\n  }\r\n}\r\n```\r\n\r\n不过...经常有时候跑不起来\r\n\r\n运维抱怨着前端的部署脚本没有标好 `node` 版本，前端嚷嚷着测试环境没问题\r\n\r\n这个时候运维需要费很多心力放在部署上，甚至测试环境的部署上，前端也要操心放在运维如何部署上。这个时候由于怕影响线上环境，上线往往选择在深夜，前端和运维身心俱疲\r\n\r\n不过向来如此\r\n\r\n鲁迅说，向来如此，那便对么。\r\n\r\n**这个时候，无论跨域的配置还是缓存的配置，都是运维来管理，运维不懂前端。但配置方式却是前端在提供，而前端并不熟悉 nginx**\r\n\r\n## 使用 docker 构建镜像\r\n\r\n`docker` 的引进，很大程度地解决了部署脚本跑不了这个大BUG。**`dockerfile` 即部署脚本，部署脚本即 `dockerfile`**。也很大程度缓解了前端运维的摩擦，毕竟前端越来越靠谱了，至少部署脚本没有问题了 (笑\r\n\r\n这时候，前端不再提供静态资源，而是提供服务，一个 `http` 服务\r\n\r\n前端写的 `dockerfile` 大致长这个样子\r\n\r\n``` dockerfile\r\nFROM node:alpine\r\n\r\n# 代表生产环境\r\nENV PROJECT_ENV production\r\n# 许多 package 会根据此环境变量，做出不同的行为\r\n# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量\r\nENV NODE_ENV production\r\nWORKDIR /code\r\nADD . /code\r\nRUN npm install && npm run build && npm install -g http-server\r\nEXPOSE 80\r\n\r\nCMD http-server ./public -p 80\r\n```\r\n\r\n单单有 `dockerfile` 也跑不起来，另外前端也开始维护一个 `docker-compose.yaml`，交给运维执行命令 `docker-compose up -d` 启动前端应用。前端第一次写 `dockerfile` 与 `docker-compose.yaml`，在部署流程中扮演的角色越来越重要。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n``` yaml\r\nversion: \"3\"\r\nservices:\r\n  shici:\r\n    build: .\r\n    expose:\r\n      - 80\r\n```\r\n\r\n\r\n运维的 `nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    proxy_pass http://static.shanyue.tech;\r\n  }\r\n\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n}\r\n```\r\n\r\n运维除了配置 `nginx` 之外，还要执行一个命令: `docker-compose up -d`\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，由于从静态文件转换为服务，缓存开始交由前端控制 (但是镜像中的 `http-server` 不太适合做这件事情)\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n前端可以做他应该做的事情中的一部分了，这是一件令人开心的事情\r\n\r\n当然，前端对于 `dockerfile` 的改进也是一个慢慢演进的过程，那这个时候镜像有什么问题呢？\r\n\r\n1. 构建镜像体积过大\r\n1. 构建镜像时间过长\r\n\r\n## 使用多阶段构建优化镜像\r\n\r\n这中间其实经历了不少坎坷，其中过程如何，详见我的另一篇文章: [如何使用 docker 部署前端应用](https://juejin.im/post/5c83cbaa6fb9a04a0f65fdaa)。\r\n\r\n其中主要的优化也是在上述所提到的两个方面\r\n\r\n1. 构建镜像体积由 1G+ 变为 10M+\r\n1. 构建镜像时间由 5min+ 变为 1min (视项目复杂程度，大部分时间在构建时间与上传静态资源时间)\r\n\r\n``` dockerfile\r\nFROM node:alpine as builder\r\n\r\nENV PROJECT_ENV production\r\nENV NODE_ENV production\r\n\r\nWORKDIR /code\r\n\r\nADD package.json /code\r\nRUN npm install --production\r\n\r\nADD . /code\r\n\r\n# npm run uploadCdn 是把静态资源上传至 oss 上的脚本文件，将来会使用 cdn 对 oss 加速\r\nRUN npm run build && npm run uploadCdn\r\n\r\n# 选择更小体积的基础镜像\r\nFROM nginx:alpine\r\nCOPY --from=builder code/public/index.html code/public/favicon.ico /usr/share/nginx/html/\r\nCOPY --from=builder code/public/static /usr/share/nginx/html/static\r\n```\r\n\r\n那它怎么做的\r\n\r\n1. 先 `ADD package.json /code`, 再 `npm install --production` 之后 `Add` 所有文件。充分利用镜像缓存，减少构建时间\r\n1. 多阶段构建，大大减小镜像体积\r\n\r\n另外还可以有一些小优化，如\r\n\r\n+ `npm cache` 的基础镜像或者 `npm` 私有仓库，减少 `npm install` 时间，减小构建时间\r\n+ `npm install --production` 只装必要的包\r\n\r\n前端看着自己优化的 `dockerfile`，想着前几天还被运维吵，说什么磁盘一半的空间都被前端的镜像给占了，想着自己节省了前端镜像几个数量级的体积，为公司好像省了不少服务器的开销，想着自己的基础盘进一步扩大，不禁开心的笑了\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制，缓存在oss上设置，将会使用 cdn 对 oss 加速。此时缓存由前端写脚本控制\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n## CI/CD 与 gitlab\r\n\r\n此时前端成就感爆棚，运维呢？运维还在一遍一遍地上线，重复着一遍又一遍的部署三个动作\r\n\r\n1. 拉代码\r\n1. `docker-compose up -d`\r\n1. 重启 nginx\r\n\r\n运维觉得再也不能这么下去了，于是他引进了 `CI`: 与现有代码仓库 `gitlab` 配套的 `gitlab ci`\r\n\r\n+ `CI`，`Continuous Integration`，持续集成\r\n+ `CD`，`Continuous Delivery`，持续交付\r\n\r\n重要的不是 `CI/CD` 是什么，重要的是现在运维不用跟着业务上线走了，不需要一直盯着前端部署了。这些都是 `CI/CD` 的事情了，它被用来做自动化部署。上述提到的三件事交给了 `CI/CD`\r\n\r\n`.gitlab-ci.yml` 是 `gitlab` 的 CI 配置文件，它大概长这个样子\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker-compose up --build -d\r\n  tags:\r\n    - shell\r\n```\r\n\r\n`CI/CD` 不仅仅更解放了业务项目的部署，也在交付之前大大加强了业务代码的质量，它可以用来 `lint`，`test`，`package` 安全检查，甚至多特性多环境部署，我将会在我以后的文章将这部分事情\r\n\r\n我的一个服务器渲染项目 [shfshanyue/shici](https://github.com/shfshanyue/shici) 以前在我的服务器中就是以 `docker`/`docker-compose/gitlab-ci` 的方式部署，有兴趣的可以看看它的配置文件\r\n\r\n+ [shfshanyue/shici:Dockerfile](https://github.com/shfshanyue/shici/blob/master/Dockerfile)\r\n+ [shfshanyue/shici:docker-compose.yml](https://github.com/shfshanyue/shici/blob/master/docker-compose.yml)\r\n+ [shfshanyue/shici:gitlab-ci.yml](https://github.com/shfshanyue/shici/blob/master/.gitlab-ci.yml)\r\n\r\n如果你有个人服务器的话，也建议你做一个自己感兴趣的前端应用和配套的后端接口服务，并且配套 `CI/CD` 把它部署在自己的自己服务器上\r\n\r\n而你如果希望结合 `github` 做 `CI/CD`，那可以试一试 `github` + `github action`\r\n\r\n另外，也可以试试 `drone.ci`，如何部署可以参考我以前的文章: [github 上持续集成方案 drone 的简介及部署](https://juejin.im/post/5dc0b563f265da4cef190b8a)\r\n\r\n## 使用 kubernetes 部署\r\n\r\n随着业务越来越大，镜像越来越多，`docker-compose` 已经不太能应付，`kubernetes` 应时而出。这时服务器也从1台变成了多台，多台服务器就会有分布式问题\r\n\r\n**一门新技术的出现，在解决以前问题的同时也会引进复杂性。**\r\n\r\nk8s 部署的好处很明显: 健康检查，滚动升级，弹性扩容，快速回滚，资源限制，完善的监控等等\r\n\r\n那现在遇到的新问题是什么？\r\n\r\n**构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**\r\n\r\n需要一个私有的镜像仓库，这是运维的事情，`harbor` 很快就被运维搭建好了，但是对于前端部署来说，复杂性又提高了\r\n\r\n先来看看以前的流程:\r\n\r\n1. 前端配置 `dockerfile` 与 `docker-compose`\r\n1. 生产环境服务器的 `CI runner` 拉代码(可以看做以前的运维)，`docker-compose up -d` 启动服务。然后再重启 `nginx`，做反向代理，对外提供服务\r\n\r\n以前的流程有一个问题: **构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**，所以需要一个私有的镜像仓库，一个能够访问 `k8s` 集群的持续集成服务器\r\n\r\n流程改进之后结合 `k8s` 的流程如下\r\n\r\n1. 前端配置 `dockerfile`，构建镜像，推到镜像仓库\r\n1. 运维为前端应用配置 `k8s` 的资源配置文件，`kubectl apply -f` 时会重新拉取镜像，部署资源\r\n\r\n运维问前端，需不需要再扩大下你的基础盘，写一写前端的 `k8s` 资源配置文件，并且列了几篇文章\r\n\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n\r\n前端看了看后端十几个 k8s 配置文件之后，摇摇头说算了算了\r\n\r\n这个时候，`gitlab-ci.yaml` 差不多长这个样子，配置文件的权限由运维一人管理\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker build -t harbor.shanyue.tech/fe/shanyue\r\n    - docker push harbor.shanyue.tech/fe/shanyue\r\n    - kubectl apply -f https://k8s-config.default.svc.cluster.local/shanyue.yaml\r\n  tags:\r\n    - shell\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域仍由运维控制，在后端 `k8s` 资源的配置文件中控制 `Ingress`\r\n\r\n## 使用 helm 部署\r\n\r\n这时前端与运维已不太往来，除了偶尔新起项目需要运维帮个忙以外\r\n\r\n但好景不长，突然有一天，前端发现自己连个环境变量都没法传！于是经常找运维修改配置文件，运维也不胜其烦\r\n\r\n于是有了 `helm`，如果用一句话解释它，那它就是一个带有模板功能的 `k8s` 资源配置文件。作为前端，你只需要填参数。更多详细的内容可以参考我以前的文章 [使用 helm 部署 k8s 资源](https://juejin.im/post/5dbf7909f265da4d4b5fe7b4)\r\n\r\n假如我们使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 作为 `helm chart`，前端可能写的配置文件长这个样子\r\n\r\n``` yaml\r\nimage:\r\n  registry: harbor.shanyue.tech\r\n  repository: fe/shanyue\r\n  tag: 8a9ac0\r\n\r\ningress:\r\n  enabled: true\r\n  hosts:\r\n  - name: shanyue.tech\r\n    path: /\r\n\r\n  tls:\r\n  - hosts:\r\n      - shanyue.tech\r\n    secretName: shanyue-tls\r\n\r\n    # livenessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 30\r\n    #   timeoutSeconds: 5\r\n    #   failureThreshold: 6\r\n    # \r\n    # readinessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 5\r\n    #   timeoutSeconds: 3\r\n    #   periodSeconds: 5\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域由后端控制，配置在后端 Chart 的配置文件 `values.yaml` 中\r\n\r\n到了这时前端和运维的职责所在呢？\r\n\r\n前端需要做的事情有:\r\n\r\n1. 写前端构建的 `dockerfile`，这只是一次性的工作，而且有了参考\r\n1. 使用 `helm` 部署时指定参数\r\n\r\n那运维要做的事情呢\r\n\r\n1. 提供一个供所有前端项目使用的 `helm chart`，甚至不用提供，如果运维比较懒那就就使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 吧。也是一次性工作\r\n1. 提供一个基于 `helm` 的工具，禁止业务过多的权限，甚至不用提供，如果运维比较懒那就直接使用 `helm`\r\n\r\n这时前端可以关注于自己的业务，运维可以关注于自己的云原生，职责划分从未这般清楚\r\n\r\n## 统一前端部署平台\r\n\r\n后来运维觉得前端应用的本质是一堆静态文件，较为单一，容易统一化，来避免各个前端镜像质量的参差不齐。于是运维准备了一个统一的 `node` 基础镜像\r\n\r\n前端再也不需要构建镜像，上传 CDN 了，他只需要写一份配置文件就可以了，大致长这个样子\r\n\r\n``` yaml\r\nbuild:\r\n  command: npm run build\r\n  dist: /dist\r\n\r\nhosts:\r\n- name: shanyue.tech\r\n  path: /\r\n\r\nheaders:\r\n- location: /*\r\n  values:\r\n  - cache-control: max-age=7200\r\n- location: assets/*\r\n  values:\r\n  - cache-control: max-age=31536000\r\n\r\nredirects:\r\n- from : /api\r\n  to: https://api.shanyue.tech\r\n  status: 200\r\n```\r\n\r\n此时，前端只需要写一份配置文件，就可以配置缓存，配置 `proxy`，做应该属于前端做的一切，而运维也再也不需要操心前端部署的事情了\r\n\r\n前端看着自己刚刚写好的配置文件，怅然若失的样子...\r\n\r\n不过一般只有大厂会有这么完善的前端部署平台，如果你对它有兴趣，你可以尝试下 `netlify`，可以参考我的文章: [使用 netlify 部署你的前端应用](https://shanyue.tech/op/deploy-fe-with-netlify.html)\r\n\r\n## 服务端渲染与后端部署\r\n\r\n大部分前端应用本质上是静态资源，剩下的少部分就是服务端渲染了，服务端渲染的本质上是一个后端服务，它的部署可以视为后端部署\r\n\r\n后端部署的情况更为复杂，比如\r\n\r\n1. 配置服务，后端需要访问敏感数据，但又不能把敏感数据放在代码仓库。你可以在 `environment variables`， `consul` 或者 `k8s configmap` 中维护\r\n1. 上下链路服务，你需要依赖数据库，上游服务\r\n1. 访问控制，限制 IP，黑白名单\r\n1. RateLimit\r\n1. 等等\r\n\r\n我将在以后的文章分享如何在 k8s 中部署一个后端\r\n\r\n## 小结\r\n\r\n随着 `devops` 的发展，前端部署越来越简单，可控性也越来越高，建议所有人都稍微学习一下 `devops` 的东西。\r\n\r\n道阻且长，行则将至。\r\n\r\n## 相关文章\r\n\r\n+ [个人服务器运维指南](https://juejin.im/post/5db7a9e2f265da4cf85d6fb9)\r\n+ [如果你想搭建一个博客](https://juejin.im/post/5db78500f265da4d0a68cef7)\r\n+ [当我有一台服务器时我做了什么](https://juejin.im/post/5c9232a8e51d45729b3b71e1)\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk1OTg4MDg=",
    "number": 17,
    "title": "【Q016】后端的敏感数据在生产环境是如何配置的",
    "body": "后端的敏感数据在生产环境是如何配置的，如数据库的账号密码，jwt 的 secret，联调上游服务的 token 等",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTM0NjI1OA==",
          "body": "目前我们的方式是在每次部署之前，在 [vault](https://github.com/hashicorp/vault) 和 [consul](https://github.com/hashicorp/consul) 拉取敏感数据，写在配置文件中\r\n\r\n另外，还有几种可选的方案\r\n\r\n1. 跟随 `CI/CD` 的环境变量，敏感配置放在 CI 平台\r\n1. 跟随 k8s `secret`/`configMap`，敏感配置放在 k8s 集群\r\n1. 跟随专有的配置服务，如 `consul`/`vault`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTY3NjQ=",
    "number": 18,
    "title": "【Q017】css 如何实现左侧固定300px，右侧自适应的布局",
    "body": "问题追问：\r\n\r\n+ 如果使用 flex 布局回答 `flex: 1` 时，则追问它是那几个属性的简写，最主要配置的是哪一个属性",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjQxMzkzMA==",
          "body": "css---\r\n .box{\r\n            width:100%;;\r\n            height:100%;\r\n            display:flex;\r\n        }\r\n        .one{\r\n            width:300px;\r\n            height:300px;\r\n            background-color: #afa;\r\n        }\r\n        .two{\r\n            flex:1;\r\n            height:300px;\r\n            background-color: #ae5aca;\r\n        }\r\nhtml----\r\n <div class=\"box\">\r\n        <div class=\"one\">12312313</div>\r\n        <div class=\"two\">123</div>\r\n    </div>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhaochongzi",
            "url": "https://github.com/zhaochongzi"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODY1NTA5NQ==",
          "body": "> 代码见 [左侧固定，右侧自适应 - Codepen](https://codepen.io/shanyue/pen/GRWmbyb)\r\n\r\n使用 `flex` 布局，左侧 `300px`，右侧 `flex-grow: 1`。`pug` 代码及 `css` 代码示例如下\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```\r\n\r\n如果只使用 Grid 布局，则代码会更加简单，只需要控制容器的 CSS 属性\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  grid-template-columns: 300px 1fr;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5MzcyNjI0MA==",
          "body": "左侧300px；右侧flex: 1; 采用flex的固比模型",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Uwah",
            "url": "https://github.com/Uwah"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwMzYwMjA2OQ==",
          "body": "使用calc方法\r\n.left{width:330px;}\r\n.right{width: calc(100% - 330px)}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bohancen",
            "url": "https://github.com/bohancen"
          }
        },
        {
          "id": "IC_kwDODQzyOs42iuOw",
          "body": "圣杯布局吧， float也可以，不过很少用了  \r\n.container{padding-left: 300px;}\r\n.left,.main { float: left;position: relative;}  \r\n.left{width: 300px;right: 300px;margin-left: -100%}  \r\n.main{width: 100%;}  ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "szc-sun",
            "url": "https://github.com/szc-sun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JRxzq",
          "body": "浮动+BFC\r\n\r\n```html\r\n<div class=\"box\">\r\n  <div class=\"box1\"></div>\r\n  <div class=\"box2\"></div>\r\n</div>\r\n```\r\n\r\n```css\r\n.box {\r\n    height: 400px;\r\n    background-color: skyblue;\r\n}\r\n.box1 {\r\n    float: left;\r\n    width: 300px;\r\n    height: 200px;\r\n    background-color: red;\r\n} \r\n.box2 {\r\n    height: 200px;\r\n    background-color: blue;\r\n   overflow:hidden;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTk0MTI=",
    "number": 19,
    "title": "【Q018】当你使用 docker 部署应用时，如何查看应用日志",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjQ0MjU4NA==",
          "body": "在docker中使用 `docker logs CONTAINER`\r\n\r\n如果在k8s中使用 `kubectl logs POD`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0MjExNDI=",
    "number": 20,
    "title": "【Q019】浏览器中如何实现剪切板复制内容的功能",
    "body": "在一些博客系统，如掘金的博客中，可以复制代码，它是如何实现的",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjA5OTE2NQ==",
          "body": "它一般可以使用第三方库 [clipboard-copy](https://github.com/feross/clipboard-copy/blob/master/index.js) 来实现，源码很简单，可以读一读\r\n\r\n目前最为推荐的方式是使用 `Clipboard API` 进行实现\r\n\r\n``` js\r\nnavigator.clipboard.writeText(text)\r\n```\r\n\r\n而对于一些不支持 `Clipboard API` 的浏览器，使用以下 API 进行复制\r\n\r\n1. 选中: `Selection API`\r\n1. 复制: `document.execCommand` (已被废弃)\r\n\r\n## 选中: Selection API/Range API\r\n\r\n选中主要利用了 [Selection API](https://developer.mozilla.org/en-US/docs/Web/API/Selection) 与 Range API\r\n\r\n选中的代码如下\r\n\r\n``` js\r\nconst selection = window.getSelection();\r\nconst range = document.createRange();\r\n\r\n// RangeAPI: 制造区域\r\nrange.selectNodeContents(element);\r\n\r\n// Selection: 选中区域\r\nselection.addRange(range);\r\n\r\nselectedText = selection.toString();\r\n```\r\n\r\n取消选中的代码如下\r\n\r\n``` js\r\nwindow.getSelection().removeAllRanges();\r\n```\r\n\r\n它有现成的第三方库可以使用: [select.js](https://github.com/zenorocha/select)\r\n\r\n## 复制: execCommand\r\n\r\n复制就比较简单了，`execCommand`\r\n\r\n``` js\r\ndocument.execCommand('copy')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0Mjc1NzU=",
    "number": 21,
    "title": "【Q020】如何实现一个分布式锁",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc2NTk0NA==",
          "body": "mysql,redis,zk redis效率较高\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangxiaokun",
            "url": "https://github.com/zhangxiaokun"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc3OTIwMg==",
          "body": "多节点部署就会产生分布式问题，分布式锁由两个词组成，**分布式**和**锁**\r\n\r\n1. 分布式: 解决分布式问题就要找一个大家都能够访问到的中介，比如 `Redis`，`Consul`，`Zookeeper`\r\n2. 锁: 解决原子问题，当不存在时便加锁，**不存在** 和 **加锁** 要作为原子进行操作\r\n\r\n以下是一个 `redis` 实现的操作\r\n\r\n``` bash\r\n# EX 100：100s 的过期时间\r\n# NX: 如果不存在 User:10086，设置成功返回 OK，否则返回 nil，也就是说 100s 之内只有第一次操作返回 OK\r\nset User:10086 Random:shanyue EX 100 NX\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjU4MDk=",
    "number": 22,
    "title": "【Q021】React 中，cloneElement 与 createElement 各是什么，有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODc0MQ==",
          "body": "``` js\r\nReact.cloneElement(\r\n  element,\r\n  [props],\r\n  [...children]\r\n)\r\n\r\nReact.createElement(\r\n  type,\r\n  [props],\r\n  [...children]\r\n)\r\n```\r\n\r\n直接上 API，很容易得出结论：首参不一样。这也是他们的最大区别：\r\n\r\n1. `cloneElement`，根据 Element 生成新的 Element\r\n1.  `createElement`，根据 Type 生成新的 Element\r\n\r\n然而，此时估计还是云里雾里，含糊不清，需要弄清它，首先要明白俩概念\r\n\r\n1. Type\r\n1. Element\r\n\r\n## React.cloneElement 的使用场景",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JQsos",
          "body": "`createElement`：\r\n- 第一个参数是 type 简单来说就是各种 标签名字（包括 HTML 自身的，还有 React 组件名字）\r\n- 第二个参数是传入的属性\r\n- 第三个参数以及之后的参数就是作为组件的子组件\r\nJSX 编写的代码就是转换为这个方法，一般用了 JSX 写法都不会再需要自己直接调用 该方法\r\n\r\n`cloneElement` \r\n- 第一个参数是 一个 React 元素\r\n- 新添加的属性会并入原有的属性\r\n一般配合 `React.children.map`使用，如用于动态地给子组件添加更多 props 信息、样式\r\n\r\n更深一点的原因在于，React 元素是 不可变对象\r\n例如 props.children 获取到的只是一个 描述符，不能直接修改它的任何属性，只能读取他的信息。\r\n所以我们可以选择拷贝它们，然后再修改、添加",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "okkjoo",
            "url": "https://github.com/okkjoo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY4MzA=",
    "number": 23,
    "title": "【Q022】如何实现一个简单的 Promise",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjA0Mg==",
          "body": "一个简单的 `Promise` 的粗糙实现，关键点在于\r\n\r\n1. 当 `pending` 时， `thenable` 函数由一个队列维护\r\n1. 当状态变为 `resolved(fulfilled)` 时，队列中所有 `thenable` 函数执行\r\n1. 当 `resolved` 时， `thenable` 函数直接执行\r\n\r\n<!--more-->\r\n\r\n`rejected` 状态同理\r\n\r\n```javascript\r\nclass Prom {\r\n  static resolve (value) {\r\n    if (value && value.then) {\r\n      return value \r\n    }\r\n    return new Prom(resolve => resolve(value))\r\n  }\r\n\r\n  constructor (fn) {\r\n    this.value = undefined\r\n    this.reason = undefined\r\n    this.status = 'PENDING'\r\n\r\n    // 维护一个 resolve/pending 的函数队列\r\n    this.resolveFns = []\r\n    this.rejectFns = []\r\n\r\n    const resolve = (value) => {\r\n      // 注意此处的 setTimeout\r\n      setTimeout(() => {\r\n        this.status = 'RESOLVED'\r\n        this.value = value\r\n        this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) => res(fn(value)))\r\n      })\r\n    }\r\n\r\n    const reject = (e) => {\r\n      setTimeout(() => {\r\n        this.status = 'REJECTED'\r\n        this.reason = e\r\n        this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) => rej(fn(e)))\r\n      })\r\n    }\r\n\r\n    fn(resolve, reject)\r\n  }\r\n\r\n\r\n  then (fn) {\r\n    if (this.status === 'RESOLVED') {\r\n      const result = fn(this.value)\r\n      // 需要返回一个 Promise\r\n      // 如果状态为 resolved，直接执行\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      // 也是返回一个 Promise\r\n      return new Prom((resolve, reject) => {\r\n        // 推进队列中，resolved 后统一执行\r\n        this.resolveFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n\r\n  catch (fn) {\r\n    if (this.status === 'REJECTED') {\r\n      const result = fn(this.value)\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      return new Prom((resolve, reject) => {\r\n        this.rejectFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nProm.resolve(10).then(o => o * 10).then(o => o + 10).then(o => {\r\n  console.log(o)\r\n})\r\n\r\nreturn new Prom((resolve, reject) => reject('Error')).catch(e => {\r\n  console.log('Error', e)\r\n})\r\n```\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs407jTL",
          "body": "```javascript\r\nfunction MyPromise (executor) {\r\n    if (typeof executor !== 'function') {\r\n        // throw new Error('Promise resolver 1 is not a function')\r\n    }\r\n    if (this instanceof MyPromise) {\r\n        // throw new Error(`${this} is not a promise`)\r\n    }\r\n    this.PromiseState = 'pending'\r\n    this.PromiseFulfillReactions = []\r\n    this.PromiseRejectReactions = []\r\n    this.PromiseIsHandled = false\r\n    this.AlreadyResolved = false\r\n\r\n    let resolve = _Resolve(this)\r\n    let reject = _Reject(this)\r\n\r\n    try {\r\n        executor(resolve, reject)\r\n    } catch (e) {\r\n        reject(e)\r\n    }\r\n}\r\n\r\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\r\n    let promise = this\r\n    let capability = NewPromiseCapability()\r\n    return PerformPromiseThen(promise, onFulfilled, onRejected, capability)\r\n}\r\n\r\nfunction _Resolve (promise) {\r\n    return function __Resolve (resolution) {\r\n        if (promise.AlreadyResolved) {\r\n            return undefined\r\n        }\r\n        promise.AlreadyResolved = true\r\n        if (resolution === promise) {\r\n            return RejectPromise(promise, TypeError('is same'))\r\n        }\r\n        if ((typeof resolution !== 'function' && typeof resolution !== 'object') || resolution === null) {\r\n            return FulfillPromise(promise, resolution)\r\n        }\r\n        let then\r\n        try {\r\n            then = resolution.then\r\n        } catch (e) {\r\n            return RejectPromise(promise, e)\r\n        }\r\n        if (typeof then !== 'function') {\r\n            return FulfillPromise(promise, resolution)\r\n        } else {\r\n            let job = NewPromiseResolveThenableJob(promise, resolution, then)\r\n            HostEnqueuePromiseJob(job)\r\n        }\r\n        return undefined\r\n    }\r\n}\r\n\r\nfunction _Reject (promise) {\r\n    return function __Reject (reason) {\r\n        if (promise.AlreadyResolved) {\r\n            return undefined\r\n        }\r\n        promise.AlreadyResolved = true\r\n        RejectPromise(promise, reason)\r\n    }\r\n}\r\n\r\nfunction executor (resolve, reject) {\r\n    this.resolve = resolve\r\n    this.reject = reject\r\n}\r\n\r\nfunction NewPromiseCapability () {\r\n    let capability = {\r\n        resolve: undefined,\r\n        reject: undefined,\r\n        promise: undefined\r\n    }\r\n    capability.promise = new MyPromise(executor.bind(capability))\r\n    return capability\r\n}\r\n\r\nfunction PerformPromiseThen (promise, onFulfilled, onRejected, resultCapability) {\r\n    let fulfillReaction = {\r\n        Capability: resultCapability,\r\n        Type: 'Fulfill',\r\n        Handler: onFulfilled\r\n    }\r\n    let rejectReaction = {\r\n        Capability: resultCapability,\r\n        Type: 'Reject',\r\n        Handler: onRejected\r\n    }\r\n    if (promise.PromiseState === 'pending') {\r\n        promise.PromiseFulfillReactions.push(fulfillReaction)\r\n        promise.PromiseRejectReactions.push(rejectReaction)\r\n    } else if (promise.PromiseState === 'fulfilled') {\r\n        let resolution = promise.PromiseResult\r\n        let job = NewPromiseReactionJob(fulfillReaction, resolution)\r\n        HostEnqueuePromiseJob(job)\r\n    } else {\r\n        if (!promise.PromiseIsHandled) {\r\n\r\n        }\r\n        let reason = promise.PromiseResult\r\n        let job = NewPromiseReactionJob(rejectReaction, reason)\r\n        HostEnqueuePromiseJob(job)\r\n    }\r\n    promise.PromiseIsHandled = true\r\n    if (!resultCapability) return undefined\r\n    return resultCapability.promise\r\n}\r\n\r\nfunction FulfillPromise (promise, resolution) {\r\n    if (promise.PromiseState !== 'pending') {\r\n        return undefined\r\n    }\r\n    let reactions = promise.PromiseFulfillReactions\r\n    promise.PromiseResult = resolution\r\n    promise.PromiseRejectReactions = []\r\n    promise.PromiseFulfillReactions = []\r\n    promise.PromiseState = 'fulfilled'\r\n    TriggerPromiseReactions(reactions, resolution)\r\n}\r\n\r\nfunction RejectPromise (promise, reason) {\r\n    if (promise.PromiseState !== 'pending') {\r\n        return undefined\r\n    }\r\n    let reactions = promise.PromiseRejectReactions\r\n    promise.PromiseResult = reason\r\n    promise.PromiseRejectReactions = []\r\n    promise.PromiseFulfillReactions = []\r\n    promise.PromiseState = 'rejected'\r\n    if (!promise.PromiseIsHandled) {\r\n\r\n    }\r\n    TriggerPromiseReactions(reactions, reason)\r\n}\r\n\r\nfunction TriggerPromiseReactions (reactions, argument) {\r\n    reactions.forEach(curr => {\r\n        let job = NewPromiseReactionJob(curr, argument)\r\n        HostEnqueuePromiseJob(job)\r\n    })\r\n}\r\n\r\nfunction NewPromiseReactionJob (reaction, argument) {\r\n    return function () {\r\n        let capability = reaction.Capability\r\n        let type = reaction.Type\r\n        let handler = reaction.Handler\r\n        let handlerResult\r\n        let isError = false\r\n        if (typeof handler !== 'function') {\r\n            if (type === 'Fulfill') {\r\n                handlerResult = argument\r\n            } else {\r\n                isError = true\r\n                handlerResult = argument\r\n            }\r\n        } else {\r\n            try {\r\n                handlerResult = handler(argument)\r\n            } catch (e) {\r\n                isError = true\r\n                handlerResult = e\r\n            }\r\n        }\r\n        if (!capability) return undefined\r\n        let status\r\n        if (!isError) {\r\n            status = capability.resolve(handlerResult)\r\n        } else {\r\n            status = capability.reject(handlerResult)\r\n        }\r\n        return status\r\n    }\r\n}\r\n\r\nfunction NewPromiseResolveThenableJob (promiseToResolve, thenable, then) {\r\n    return function () {\r\n        let resolve = _Resolve(promiseToResolve)\r\n        let reject = _Reject(promiseToResolve)\r\n        promiseToResolve.AlreadyResolved = false\r\n        let result\r\n        try {\r\n            result = then.call(thenable, resolve, reject)\r\n        } catch (e) {\r\n            return reject(e)\r\n        }\r\n        return result\r\n    }\r\n}\r\n\r\nfunction HostEnqueuePromiseJob (job) {\r\n    setTimeout(job, 0)\r\n}\r\n\r\n\r\nMyPromise.deferred = function () {\r\n    let dfd = {};\r\n    dfd.promise = new MyPromise((resolve,reject)=>{\r\n        dfd.resolve = resolve;\r\n        dfd.reject = reject;\r\n    })\r\n    return dfd;\r\n}\r\n\r\nmodule.exports = MyPromise\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BHkaH",
          "body": "> 一个简单的 `Promise` 的粗糙实现，关键点在于\r\n> \r\n> 1. 当 `pending` 时， `thenable` 函数由一个队列维护\r\n> 2. 当状态变为 `resolved(fulfilled)` 时，队列中所有 `thenable` 函数执行\r\n> 3. 当 `resolved` 时， `thenable` 函数直接执行\r\n> \r\n> `rejected` 状态同理\r\n> \r\n> ```js\r\n> class Prom {\r\n>   static resolve (value) {\r\n>     if (value && value.then) {\r\n>       return value \r\n>     }\r\n>     return new Prom(resolve => resolve(value))\r\n>   }\r\n> \r\n>   constructor (fn) {\r\n>     this.value = undefined\r\n>     this.reason = undefined\r\n>     this.status = 'PENDING'\r\n> \r\n>     // 维护一个 resolve/pending 的函数队列\r\n>     this.resolveFns = []\r\n>     this.rejectFns = []\r\n> \r\n>     const resolve = (value) => {\r\n>       // 注意此处的 setTimeout\r\n>       setTimeout(() => {\r\n>         this.status = 'RESOLVED'\r\n>         this.value = value\r\n>         this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) => res(fn(value)))\r\n>       })\r\n>     }\r\n> \r\n>     const reject = (e) => {\r\n>       setTimeout(() => {\r\n>         this.status = 'REJECTED'\r\n>         this.reason = e\r\n>         this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) => rej(fn(e)))\r\n>       })\r\n>     }\r\n> \r\n>     fn(resolve, reject)\r\n>   }\r\n> \r\n> \r\n>   then (fn) {\r\n>     if (this.status === 'RESOLVED') {\r\n>       const result = fn(this.value)\r\n>       // 需要返回一个 Promise\r\n>       // 如果状态为 resolved，直接执行\r\n>       return Prom.resolve(result)\r\n>     }\r\n>     if (this.status === 'PENDING') {\r\n>       // 也是返回一个 Promise\r\n>       return new Prom((resolve, reject) => {\r\n>         // 推进队列中，resolved 后统一执行\r\n>         this.resolveFns.push({ fn, resolve, reject }) \r\n>       })\r\n>     }\r\n>   }\r\n> \r\n>   catch (fn) {\r\n>     if (this.status === 'REJECTED') {\r\n>       const result = fn(this.value)\r\n>       return Prom.resolve(result)\r\n>     }\r\n>     if (this.status === 'PENDING') {\r\n>       return new Prom((resolve, reject) => {\r\n>         this.rejectFns.push({ fn, resolve, reject }) \r\n>       })\r\n>     }\r\n>   }\r\n> }\r\n> \r\n> Prom.resolve(10).then(o => o * 10).then(o => o + 10).then(o => {\r\n>   console.log(o)\r\n> })\r\n> \r\n> return new Prom((resolve, reject) => reject('Error')).catch(e => {\r\n>   console.log('Error', e)\r\n> })\r\n> ```\r\n\r\ncatch里面应该是`return Prom.reject(result)`吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hsq777",
            "url": "https://github.com/hsq777"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FOM0U",
          "body": "话不多说，看码！\r\n\r\n```js\r\n// 1、基本架构：\r\n//   状态\r\n//   then\r\n//   执行器函数 executor\r\n\r\n// 2、executor、resolve、reject\r\n// 3、then 同步下调用\r\n// 4、then 异步下调用\r\n// 5、then 链式调用\r\n//   返回 Promise\r\n//   then 函数递归返回常量结果，供下个 then 使用\r\n//   考虑 then 成功的回调为 null 的情况\r\n\r\nclass Promise {\r\n  static PENDING = 'pending';\r\n  static RESOLVED = 'resolved';\r\n  static REJECTED = 'rejected';\r\n\r\n  static resolve(value) {\r\n    return new Promise((resolve, reject) => {\r\n      resolve(value);\r\n    });\r\n  }\r\n\r\n  static reject(reason) {\r\n    return new Promise((resolve, reject) => {\r\n      reject(reason);\r\n    });\r\n  }\r\n\r\n  constructor(executor) {\r\n    this.state = Promise.PENDING;\r\n    this.value = undefined;\r\n    this.reason = undefined;\r\n\r\n    this.onResolvedCallbacks = [];\r\n    this.onRejectedCallbacks = [];\r\n\r\n    const resolve = value => {\r\n      if (value instanceof Promise) {\r\n        return value.then(resolve, reject);\r\n      }\r\n\r\n      if (this.state === Promise.PENDING) {\r\n        this.state = Promise.RESOLVED;\r\n        this.value = value;\r\n\r\n        this.onResolvedCallbacks.forEach(fn => fn());\r\n      }\r\n    };\r\n    const reject = reason => {\r\n      this.state = Promise.REJECTED;\r\n      this.reason = reason;\r\n      this.onRejectedCallbacks.forEach(fn => fn());\r\n    };\r\n\r\n    try {\r\n      executor(resolve, reject);\r\n    } catch (error) {\r\n      reject(error);\r\n    }\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    onFulfilled =\r\n      typeof onFulfilled === 'function' ? onFulfilled : value => value;\r\n    onRejected =\r\n      typeof onRejected === 'function'\r\n        ? onRejected\r\n        : reason => {\r\n            throw reason;\r\n          };\r\n\r\n    let promise = new Promise((resolve, reject) => {\r\n      if (this.state === Promise.PENDING) {\r\n        this.onResolvedCallbacks.push(() => {\r\n          setTimeout(() => {\r\n            try {\r\n              let x = onFulfilled(this.value);\r\n              resolvePromise(promise, x, resolve, reject);\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          });\r\n        });\r\n        this.onRejectedCallbacks.push(() => {\r\n          setTimeout(() => {\r\n            try {\r\n              let x = onRejected(this.reason);\r\n              resolvePromise(promise, x, resolve, reject);\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          });\r\n        });\r\n      }\r\n\r\n      if (this.state === Promise.RESOLVED) {\r\n        setTimeout(() => {\r\n          try {\r\n            let x = onFulfilled(this.value);\r\n            resolvePromise(promise, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error);\r\n          }\r\n        });\r\n      }\r\n\r\n      if (this.state === Promise.REJECTED) {\r\n        setTimeout(() => {\r\n          try {\r\n            let x = onRejected(this.reason);\r\n            resolvePromise(promise, x, resolve, reject);\r\n          } catch (error) {\r\n            reject(error);\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  catch(onRejected) {\r\n    return this.then(null, onRejected);\r\n  }\r\n\r\n  all(arr) {\r\n    let count = 0;\r\n    let result = [];\r\n\r\n    return new Promise((resolve, reject) => {\r\n      for (let i = 0; i < arr.length; i++) {\r\n        Promise.resolve(arr[i])\r\n          .then(res => {\r\n            result[i] = res;\r\n            if (++count === arr.length) {\r\n              resolve(res);\r\n            }\r\n          })\r\n          .catch(error => {\r\n            reject(error);\r\n          });\r\n      }\r\n    });\r\n  }\r\n\r\n  race(arr) {\r\n    return new Promise((resolve, reject) => {\r\n      arr.forEach(item => Promise.resolve(item).then(resolve, reject));\r\n    });\r\n  }\r\n\r\n  finally(callback) {\r\n    return this.then(\r\n      value => {\r\n        return Promise.resolve(callback()).then(() => value);\r\n      },\r\n      reason => {\r\n        return Promise.resolve(callback()).then(() => {\r\n          throw reason;\r\n        });\r\n      },\r\n    );\r\n  }\r\n\r\n  allSettled(arr) {\r\n    let count = 0;\r\n    let result = [];\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const fn = (i, data) => {\r\n        if (count === arr.length) {\r\n          resolve(result);\r\n        }\r\n\r\n        result[i] = data;\r\n        count++;\r\n      };\r\n\r\n      for (let i = 0; i < arr.length; i++) {\r\n        Promise.resolve(arr[i])\r\n          .then(res => {\r\n            fn(i, { status: 'fulfilled', value: res });\r\n          })\r\n          .catch(error => {\r\n            fn(i, { status: 'rejected', reason: error });\r\n          });\r\n      }\r\n    });\r\n  }\r\n\r\n  // from Node Util.promisify\r\n  promisify(f) {\r\n    return function(...args) {\r\n      return new Promise((resolve, reject) => {\r\n        function callback(error, result) {\r\n          if (error) {\r\n            reject(error);\r\n          } else {\r\n            resolve(result);\r\n          }\r\n        }\r\n\r\n        args.push(callback);\r\n\r\n        f.call(this, ...args);\r\n      });\r\n    };\r\n  }\r\n\r\n  // from Node Util.promisifyAll\r\n  promisifyAll(obj) {\r\n    for (let key in obj) {\r\n      if (typeof obj[key] === 'function') {\r\n        obj[key] = this.promisify(obj[key]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction resolvePromise(promise, x, resolve, reject) {\r\n  // let promise = new Promise((resolve) => {\r\n  //   resolve(1);\r\n  // }).then((res) => {\r\n  //   return promise;\r\n  // });\r\n\r\n  if (x === promise) {\r\n    throw TypeError('循环引用');\r\n  }\r\n\r\n  if ((typeof x === 'object' && x !== null) || typeof x === 'function') {\r\n    let called;\r\n\r\n    try {\r\n      let then = x.then;\r\n\r\n      if (typeof then === 'function') {\r\n        then.call(\r\n          x,\r\n          y => {\r\n            if (called) return;\r\n            called = true;\r\n            resolvePromise(promise, y, resolve, reject);\r\n          },\r\n          r => {\r\n            if (called) return;\r\n            called = true;\r\n            reject(r);\r\n          },\r\n        );\r\n      } else {\r\n        // x: { then: {} }\r\n        if (called) return;\r\n        called = true;\r\n        resolve(x);\r\n      }\r\n    } catch (error) {\r\n      if (called) return;\r\n      called = true;\r\n      reject(error);\r\n    }\r\n  } else {\r\n    // 返回了常量，直接 resolve\r\n    resolve(x);\r\n  }\r\n}\r\n\r\nconst p = new Promise((resolve, reject) => {\r\n  reject(1);\r\n});\r\n\r\np.catch(error => {\r\n  console.log('error + ', error);\r\n  return error;\r\n}).then(res => {\r\n  console.log(res);\r\n});\r\n\r\nPromise.deferred = function() {\r\n  let dfd = {};\r\n  dfd.promise = new Promise((resolve, reject) => {\r\n    dfd.resolve = resolve;\r\n    dfd.reject = reject;\r\n  });\r\n  return dfd;\r\n};\r\n\r\nmodule.exports = Promise;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hefeng6500",
            "url": "https://github.com/hefeng6500"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FOv-7",
          "body": "在作者代码基础上做了一些修改\r\n基本功能够用了\r\n```javascript\r\nclass myPromise {\r\n    static PENDING = 'pending'\r\n    static FULFILLED = 'fulfilled'\r\n    static REJECTED = 'rejected'\r\n\r\n    static resolve (value) {\r\n        if (value && value.then) {\r\n            return value\r\n        }\r\n        return new myPromise((resolve) => resolve(value))\r\n    }\r\n\r\n    static reject (value) {\r\n        return new myPromise((_, reject) => reject(value))\r\n    }\r\n\r\n    constructor (fn) {\r\n        this.status = myPromise.PENDING\r\n        this.result = null\r\n\r\n        this.resFns = []\r\n        this.rejFns = []\r\n\r\n        const resolve = (value) => {\r\n            if (this.status === myPromise.PENDING) {\r\n                setTimeout(() => {\r\n                    this.status = myPromise.FULFILLED\r\n                    this.result = value\r\n                    this.resFns.forEach(({fn, resolve, reject}) => resolve(fn(value)))\r\n                })\r\n            }\r\n        }\r\n\r\n        const reject = (reason) => {\r\n            if (this.status === myPromise.PENDING) {\r\n                setTimeout(() => {\r\n                    this.status = myPromise.REJECTED\r\n                    this.result = reason\r\n                    this.rejFns.forEach(({fn, resolve, reject}) => reject(fn(reason)))\r\n                })\r\n            }\r\n        }\r\n\r\n        try {\r\n            fn(resolve, reject)\r\n        } catch (err) {\r\n            reject(err)\r\n        }\r\n    }\r\n\r\n    then (resFn, rejFn) {\r\n        resFn = typeof resFn === 'function' ? resFn : value => value\r\n        rejFn = typeof rejFn === 'function' ? rejFn : reason => reason\r\n\r\n        const _promise = {\r\n            [myPromise.PENDING]: () => {\r\n                return new myPromise((resolve, reject) => {\r\n                    this.resFns.push({fn: resFn, resolve, reject})\r\n                    this.rejFns.push({fn: rejFn, resolve, reject})\r\n                })\r\n            },\r\n            [myPromise.FULFILLED]: () => myPromise.resolve(resFn(this.result)),\r\n            [myPromise.REJECTED]: () => myPromise.reject(rejFn(this.result))\r\n        }[this.status]\r\n\r\n        return _promise()\r\n    }\r\n\r\n    catch (fn) {\r\n        return this.then(undefined, fn)\r\n    }\r\n\r\n    finally(cb) {\r\n        return this.then(cb, cb)\r\n    }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yu-Lxy",
            "url": "https://github.com/Yu-Lxy"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY5ODI=",
    "number": 24,
    "title": "【Q023】websocket 服务多节点部署时会有什么问题，怎么解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4NzQ4MA==",
          "body": "## 多节点问题\r\n\r\n在开始思考分布式会有什么问题时，先来回答一个问题: 服务端如何与客户端交流？\r\n\r\n在 ws 服务端，当与客户端连接成功后，会生成一个对象 `connection`，ws 会维护一个与客户端所有连接的 `connections`。如果想要主动推送消息到客户端，只需要调用API `connection.sendText(message)`。\r\n\r\n那如何给所有人广播消息呢？\r\n\r\n服务器只需要与它自身的所有连接 `server.connections` 挨个发消息就是广播，所以它只是一个伪广播：我要给群里所有人发消息，但我不能在群里发，只能挨个私发。\r\n\r\n### 单节点\r\n\r\n当单节点时所有用户都能正常受到通知，流程如下\r\n\r\n![ws 单节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-single-node.jpg)\r\n\r\n这时所有用户都能收到消息通知\r\n\r\n### 多节点\r\n\r\n当多节点时，就会有部分用户无法正常受到通知，从以下流程图中可以很清楚地看到问题所在\r\n\r\n![ws 多节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-multi-node.jpg)\r\n\r\n**负载到节点2的所有用户都没有收到消息通知**\r\n\r\n## 如何解决\r\n\r\n多节点服务器就会有分布式问题，解决分布式问题就找一个大家都能找到的地，比如说 `Redis`，比如说 `Kafka` 等消息件\r\n\r\n改进后流程图如下\r\n\r\n1. 需要向所有用户推送消息，请求 websocket 服务\r\n1. 负载均衡到某个节点\r\n1. 该节点向 redis/kafka 推送消息: 向所有用户推送消息通知\r\n1. 所有节点在 redis/kafka 上订阅消息\r\n1. 订阅成功后所有节点向客户端 push 消息\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n\r\n## redis PUBSUB\r\n\r\n其中有一个细节是 pub/sub 那里，redis 的 `pubsub` 较 `Kafka` 等消息中间件更为轻便，**最主要的是与ws集成的社区方案比较成熟，这点很重要**，如 Node 中的以下两个\r\n\r\n+ [graphql subscriptions - redis](https://github.com/davidyaha/graphql-redis-subscriptions)\r\n+ [socket.io-redis](https://github.com/socketio/socket.io-redis)\r\n\r\n`pubsub` 在 redis 中的命令如下\r\n\r\n+ pub: `publish channel message`\r\n+ sub: `subscribe`\r\n\r\n如果我们要订阅 `eat` 这个 `channel` 的话，图示如下\r\n\r\n![redis pubsub example](https://raw.githubusercontent.com/shfshanyue/Daily-Question/master/assets/pubsub.png)\r\n\r\n## 进一步追问\r\n\r\n面试官见我回答完问题后，又一次追问\r\n\r\n**那 websocket 如何向特定的用户组推送消息？**\r\n\r\n假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现\r\n\r\n欢迎在 Issue 中讨论: [【Q029】websocket 如何向特定用户组推送消息](https://github.com/shfshanyue/Daily-Question/issues/30)\r\n\r\n## 小结\r\n\r\n借用解决方案的图作为小结\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA4MDYxMTU=",
    "number": 25,
    "title": "【Q024】在 postgres 中，查询时如何对 jsonb 数据格式化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjM0MDU0Ng==",
          "body": "使用 `jsonb_pretty` 函数，示例如下\r\n\r\n``` sql\r\n> select jsonb_pretty('{\"a\": {\"b\": 4}}'::jsonb)\r\n+----------------+\r\n| jsonb_pretty   |\r\n|----------------|\r\n| {              |\r\n|     \"a\": {     |\r\n|         \"b\": 4 |\r\n|     }          |\r\n| }              |\r\n+----------------+\r\nSELECT 1\r\nTime: 0.018s\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA5NTU1MDI=",
    "number": 26,
    "title": "【Q025】简述 TCP socket 建立的过程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjMyNQ==",
          "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/68817970-5e11d000-06be-11ea-85ee-5d2496d14c63.png)\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEyOTc0OTU=",
    "number": 27,
    "title": "【Q026】如何对接口进行压力测试",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjE0NQ==",
          "body": "``` bash\r\n$ ab\r\n\r\n$ wrk\r\n\r\n$ siege\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTIxNjA2NQ==",
          "body": "Jmeter",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wanming001",
            "url": "https://github.com/wanming001"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzNzA0Mjg=",
    "number": 28,
    "title": "【Q027】在前端开发中，如何获取浏览器的唯一标识",
    "body": "如何获取浏览器的唯一标识，原理是什么",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc4NDQ1Ng==",
          "body": "由于不同的系统显卡绘制 `canvas` 时渲染参数、抗锯齿等算法不同，因此绘制成图片数据的 `CRC` 校验也不一样。\r\n\r\n``` js\r\nfunction getCanvasFp () {\r\n  const canvas = document.getElementById('canvas')\r\n  const ctx = canvas.getContext('2d')\r\n  ctx.font = '14px Arial'\r\n  ctx.fillStyle = '#ccc'\r\n  ctx.fillText('hello, shanyue', 2, 2)\r\n  return canvas.toDataURL('image/jpeg')\r\n}\r\n```\r\n\r\n因此根据 `canvas` 可以获取浏览器指纹信息。\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n但是对于常见的需求就有成熟的解决方案，若在生产环境使用，可以使用以下库\r\n\r\n+ [fingerprintjs2](https://github.com/Valve/fingerprintjs2)\r\n\r\n它依据以下信息，获取到浏览器指纹信息，**而这些信息，则成为 `component`**\r\n\r\n1. `canvas`\r\n1. `webgl`\r\n1. `UserAgent`\r\n1. `AudioContext`\r\n1. 对新式 API 的支持程度等\r\n\r\n``` js\r\nrequestIdleCallback(function () {\r\n  Fingerprint2.get((components) => {\r\n    const values = components.map((component) => component.value)\r\n    const fp = Fingerprint2.x64hash128(values.join(''), 31)\r\n  })\r\n})\r\n```\r\n\r\n在 `fingerprintjs2` 中，对于 `component` 也有分类\r\n\r\n+ [browser independent component](https://github.com/Valve/fingerprintjs2/wiki/Browser-independent-components)：有些 `component` 同一设备跨浏览器也可以得到相同的值，有些独立浏览器，得到不同的值\r\n+ [stable component](https://github.com/Valve/fingerprintjs2/wiki/Stable-components): 有些 `component` 刷新后值就会发生变化，称为不稳定组件\r\n\r\n在实际业务中，可根据业务选择合适的组件\r\n\r\n``` js\r\nconst options = {\r\n  excludes: {userAgent: true, language: true}\r\n}\r\n```\r\n\r\n## 简答\r\n\r\n根据 `canvas` 可以获取浏览器指纹信息\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n若在生产环境使用，可以使用 [fingerprintjs2](https://github.com/Valve/fingerprintjs2)，根据业务需求，如单设备是否可跨浏览器，以此选择合适的 `component`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDk5NDUyOA==",
          "body": "canvas指纹",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "minza",
            "url": "https://github.com/minza"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzOTk3ODA=",
    "number": 29,
    "title": "【Q028】在linux中如何获取登录的用户",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MTg2OQ==",
          "body": "``` bash\r\n$ who\r\n\r\n$ last\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjE5MjExMTQ=",
    "number": 30,
    "title": "【Q029】websocket 如何向特定的用户组推送消息",
    "body": "假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNjQzOA==",
          "body": "在 `redis` 处维护一个对象，记录每个 group 所对应的 `connections`/`sockets`\r\n\r\n``` js\r\n{\r\n  'Class:201901': [student1Socket, student2Socket]\r\n}\r\n```\r\n\r\n当 client 刚连入 server 时，便加入某个特定的组，或者叫 room，比如 student01，刚开始连入 server，可能要加入 room：`Student:01`，`Class:201901`，`Group:10086`",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjI2MDI3MTU=",
    "number": 31,
    "title": "【Q030】linux 中如何打印所有网络接口",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mzc0MjYyOA==",
          "body": "## ifconfig\r\n\r\n`ifconfig` 是最简单最常用，但是打印信息太多了\r\n\r\n``` bash\r\n$ ifconfig\r\ncni0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450\r\n        inet 10.244.0.1  netmask 255.255.255.0  broadcast 0.0.0.0\r\n        ether 9e:f3:9e:47:9d:55  txqueuelen 1000  (Ethernet)\r\n        RX packets 14733665  bytes 1007493238 (960.8 MiB)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 15040396  bytes 4534954611 (4.2 GiB)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n\r\ndocker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\r\n        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255\r\n        ether 02:42:09:fe:1d:e5  txqueuelen 0  (Ethernet)\r\n        RX packets 0  bytes 0 (0.0 B)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 0  bytes 0 (0.0 B)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n```\r\n\r\n## netstat\r\n\r\n`netstat` 与 `ip` 也挺好用，特别是它们还可以打印路由表\r\n\r\n``` bash\r\n$ netstat -i\r\nKernel Interface table\r\nIface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\r\ncni0             1450 14733471      0      0 0      15040202      0      0      0 BMRU\r\ndocker0          1500        0      0      0 0             0      0      0      0 BMU\r\neth0             1500 42833038      0      0 0      40961577      0      0      0 BMRU\r\nflannel.1        1450  4761436      0      0 0       4091581      0      0      0 BMRU\r\nlo              65536 376447249      0      0 0      376447249      0      0      0 LRU\r\nveth2052e2d6     1450  7358995      0      0 0       7518642      0      0      0 BMRU\r\nveth3190806e     1450  7363232      0      0 0       7510100      0      0      0 BMRU\r\n```\r\n\r\n## ip\r\n\r\n``` bash\r\n$ ip link\r\n\r\n$ ip addr\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        },
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTY3MTM=",
    "number": 32,
    "title": "【Q031】js 中如何实现 bind",
    "body": "提供以下测试用例，注意第二条测试用例，因此 bind 可实现 `_.partial(func, [partials])` 类似功能\r\n\r\n``` js\r\nfunction f (b) {\r\n  console.log(this.a, b)\r\n}\r\n\r\n//=> 3, 4\r\nf.fakeBind({ a: 3 })(4)\r\n\r\n//=> 3, 10\r\nf.fakeBind({ a: 3 }, 10)(11)\r\n```\r\n\r\n\r\n相关问题:\r\n\r\n+ [【Q032】js 中什么是 softbind，如何实现](https://github.com/shfshanyue/Daily-Question/issues/33)\r\n+ [【Q656】JS 中如何实现 call/apply (代码集合)](https://github.com/shfshanyue/Daily-Question/issues/674)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNzg0NA==",
          "body": "**最简单的 `bind` 一行就可以实现，而在实际面试过程中也不会考察你太多的边界条件**\r\n\r\n``` js\r\nFunction.prototype.fakeBind = function(obj, ...args) {\r\n  return (...rest) => this.call(obj, ...args, ...rest)\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n``` js\r\nfunction f (arg) {\r\n  console.log(this.a, arg)\r\n}\r\n\r\n// output: 3, 4\r\nf.bind({ a: 3 })(4)\r\n\r\n// output: 3, 4\r\nf.fakeBind({ a: 3 })(4)\r\n```\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjc1NzYwNA==",
          "body": "那我再抄一个加强版吧嘻嘻\r\n《JavaScript权威指南》P191 ES3实现bind\r\n```\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function(o /*, args */) {\r\n    var self = this, boundArgs = arguments;\r\n    return function () {\r\n      var i, args = [];\r\n      for (i = 1; i < boundArgs.length; i++) {\r\n        args.push(boundArgs[i])\r\n      }\r\n      for (i = 0; i < arguments.length; i++) {\r\n        args.push(arguments[i])\r\n     }\r\n     return self.apply(o, args)\r\n    }\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DL2FL",
          "body": "```ts\r\nFunction.prototype.fakeBind = function (target, ...args) {\r\n  return (...rest) => this.apply(target, args.concat(rest).slice(0, this.length));\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5E-Tg8",
          "body": "bind 优化版本：考虑 bind 后返回的函数作为构造函数被 new \r\n\r\n```js\r\nFunction.prototype.bind = function(context, ...args) {\r\n  const self = this;\r\n  const fn = function(...newArgs) {\r\n    self.apply(this instanceof fn ? this : context, args.concat(newArgs));\r\n  };\r\n\r\n  fn.prototype = Object.create(this.prototype);\r\n\r\n  return fn;\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hefeng6500",
            "url": "https://github.com/hefeng6500"
          }
        },
        {
          "id": "IC_kwDODQzyOs5T2UXu",
          "body": "```javascript\r\nFunction.prototype.myBind = function (ctx) {\r\n    ctx ??= globalThis\r\n    ctx = Object(ctx)\r\n\r\n    const self = this\r\n    const args = [...arguments].slice(1)\r\n\r\n    function bound() {\r\n        self.call(new.target ? this : ctx, ...args)\r\n    }\r\n\r\n    bound.prototype = self.prototype\r\n    return bound\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangtuo1999",
            "url": "https://github.com/zhangtuo1999"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ZBcNc",
          "body": "```js\r\nFunction.prototype._bind(obj,...args){\r\n  obj.fn = this\r\n  return function(...args){\r\n    const r = obj.fn(...args)\r\n    delete obj.fn\r\n    return  r\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yinzhuo19970516",
            "url": "https://github.com/Yinzhuo19970516"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTgxNDI=",
    "number": 33,
    "title": "【Q032】js 中什么是 softbind，如何实现",
    "body": "相关问题:\r\n\r\n+ [如何实现 bind](https://github.com/shfshanyue/Daily-Question/issues/32)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0ODczMjQwNw==",
          "body": "bind函数多次调用会已第一次绑定的this为准，softbind已最后一次绑定传入的this为准；",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "newwangyiyang",
            "url": "https://github.com/newwangyiyang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NDUyNDYwMg==",
          "body": "      Function.prototype.softBind = function(obj, ...rest) {\r\n        const fn = this\r\n        const bound = function(...args) {\r\n          const o = !this || this === (window || global) ? obj : this\r\n          return fn.apply(o, [...rest, ...args])\r\n        }\r\n\r\n        bound.prototype = Object.create(fn.prototype)\r\n        return bound\r\n      }\r\n\r\n\r\nfunction foo() {\r\n        console.log(`name: ${this.name}`);\r\n    }\r\n\r\n    let obj = {name: \"obj\"};\r\n    obj2 = {name: \"obj2\"};\r\n    obj3 = {name: \"obj3\"};\r\n\r\n    let fooBJ = foo.softBind(obj);\r\n    fooBJ();  // name: obj   这个时候软绑定已经生效了，this绑定到obj上\r\n    obj2.foo = foo.softBind(obj);\r\n    obj2.foo(); //name: obj2   这里已经的this隐式绑定到obj2上了\r\n    fooBJ.call(obj3); // name: obj3  这里this被硬绑定到obj3上了\r\n    setTimeout(obj2.foo, 100); // name: obj  软绑定了最初的obj",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "miaooow",
            "url": "https://github.com/miaooow"
          }
        },
        {
          "id": "IC_kwDODQzyOs41B_hM",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5G6cz_",
          "body": "bound.prototype = Object.create(fn.prototype);    为什么要有这一句，不是很懂",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shuangcherry",
            "url": "https://github.com/shuangcherry"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JxKVH",
          "body": "```js\r\n  Function.prototype.softBind = function (obj, ...args) {\r\n     const fn = this;\r\n     return function (...args2) {\r\n        return fn.apply(this === global ? obj : this, args.concat(args2));\r\n     };\r\n  };\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shen076",
            "url": "https://github.com/shen076"
          }
        },
        {
          "id": "IC_kwDODQzyOs5T2kBn",
          "body": "```javascript\r\nFunction.prototype.softBind = function (ctx) {\r\n    ctx ??= globalThis\r\n    ctx = Object(ctx)\r\n\r\n    const self = this\r\n    const args = [...arguments].slice(1)\r\n\r\n    function bound() {\r\n        fn.call(new.target || this !== globalThis ? this : ctx, ...args)\r\n    }\r\n\r\n    bound.prototype = self.prototype\r\n    return bound\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangtuo1999",
            "url": "https://github.com/zhangtuo1999"
          }
        },
        {
          "id": "IC_kwDODQzyOs5XWOid",
          "body": "> bound.prototype = Object.create(fn.prototype); 为什么要有这一句，不是很懂\r\n是要考虑到new的情况来着",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rujptw",
            "url": "https://github.com/rujptw"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Yb6LA",
          "body": "实现一个Bind:\r\n```\r\nfunction person(a, b, c, d, e) {\r\n    console.log(this.name, a + b + c);\r\n    console.log(d,e);\r\n}\r\n\r\nconst yeti = {\r\n    name: 'yeti'\r\n}\r\n\r\n// 实现一个bind\r\nFunction.prototype.newmyBind = function (obj, ...args) {\r\n    const that = this\r\n    return function (...rest) {  //返回一个修改好this的函数\r\n        // ...rest来自返回函数传入的参数  ...args是调用Bind时传入的参数\r\n        that.call(obj, ...args, ...rest)\r\n    }\r\n\r\n}\r\n\r\nconst resBind = person.newmyBind(yeti, 1, 2, 6) //1 2 6 就是...args\r\nresBind(5, 6)   //传入...rest\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yeti-xxx",
            "url": "https://github.com/Yeti-xxx"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTkyNDM=",
    "number": 34,
    "title": "【Q033】如何对接口进行限流",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDYzMDg2MQ==",
          "body": "一般采用漏桶算法：\r\n\r\n1. 漏桶初始为空\r\n1. API 调用是在往漏桶里注水\r\n1. 漏桶会以一定速率出水\r\n1. 水满时 API 拒绝调用\r\n\r\n![漏桶算法](https://d33wubrfki0l68.cloudfront.net/e737eb0be9176ca74d03344f082281154f90f12c/c0076/assets/img/leaky-bucket.f8cb8f08.png)\r\n\r\n可以使用 `redis` 的计数器实现\r\n\r\n1. 计数器初始为空\r\n1. API 调用计数器增加\r\n1. 给计数器设置过期时间，隔段时间清零，视为一定速率出水\r\n1. 计数器达到上限时，拒绝调用\r\n\r\n当然，这只是大致思路，这时会有两个问题要注意\r\n\r\n1. 最坏情况下的限流是额定限流速率的2倍\r\n1. 条件竞争问题\r\n\r\n不过实际实现时注意以下就好了（话说一般也是调用现成的三方库做限流...)，可以参考我以前的文章 <https://shanyue.tech/post/rate-limit/>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjg0NTU=",
    "number": 35,
    "title": "【Q034】如何实现一个 loading 动画",
    "body": "如何实现一个 loading 动画，可用 css 或 svg",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDgyMjkzMQ==",
          "body": "svg比较实在",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "chen-rongliang",
            "url": "https://github.com/chen-rongliang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDQ3MDkwMg==",
          "body": "## svg实现方案\r\n\r\n```xml\r\n<svg classname=\"loading\" viewbox=\"25 25 50 50\">\r\n  <circle cx=\"50\" cy=\"50\" r=\"25\" classname=\"path\" fill=\"none\" />\r\n</svg>\r\n```\r\n```css\r\n.loading {\r\n  width: 50px;\r\n  height: 50px;\r\n  animation: rotate 2s linear 0s infinite;\r\n}\r\n.path {\r\n  animation: dash 2s ease-in-out infinite;\r\n  stroke: #00b390;\r\n  stroke-width: 2;\r\n  stroke-dasharray: 90 150;\r\n  stroke-dashoffset: 0;\r\n  stroke-linecap: round;\r\n}\r\n\r\n@keyframes rotate {\r\n  from {\r\n    tranform: rotate(0deg);\r\n  } \r\n  to {\r\n    tranform: rotate(360deg);\r\n  }\r\n}\r\n\r\n@keyframes dash {\r\n  0% {\r\n    stroke-dasharray:  1 150;\r\n    stroke-dashoffset: 0;\r\n  } \r\n  50% {\r\n    stroke-dasharray: 90 150;\r\n    stroke-dashoffset: -40px;\r\n  }\r\n  100% {\r\n    stroke-dasharray: 90 150;\r\n    stroke-dashoffset: -120px;\r\n  }\r\n}\r\n```\r\n\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "hellojackhui",
            "url": "https://github.com/hellojackhui"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODcxNzUyOA==",
          "body": "transform 单词写错了吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jak983464779",
            "url": "https://github.com/jak983464779"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODcxODYyNg==",
          "body": "> transform 单词写错了吧\r\n\r\n应该是，随手写的，没留意拼写。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "chen-rongliang",
            "url": "https://github.com/chen-rongliang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODc0ODkwOQ==",
          "body": "我直接copy，把错的单词更改了也不效果",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "02220",
            "url": "https://github.com/02220"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODc1MjE5MQ==",
          "body": "> 我直接copy，把错的单词更改了也不效果\r\n\r\nIDE补全多填了些文字....你把svg和circle的classname改成class就好了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "chen-rongliang",
            "url": "https://github.com/chen-rongliang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODc1MzI0Ng==",
          "body": "> > 我直接copy，把错的单词更改了也不效果\r\n> \r\n> IDE补全多填了些文字....你把svg和circle的classname改成class就好了\r\n\r\n尴尬了，这么低级的错误",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "02220",
            "url": "https://github.com/02220"
          }
        },
        {
          "id": "IC_kwDODQzyOs42eTC8",
          "body": "通过svg实现的简单Loading动画 \\\r\nhttps://codepen.io/hwb2017/pen/XWgNVyr",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DwL6l",
          "body": "用的伪元素\r\nhttps://codepen.io/indusy/pen/BaYmBXo",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Indusy",
            "url": "https://github.com/Indusy"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4MjkxMDQ=",
    "number": 36,
    "title": "【Q035】http 常见的状态码有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDgxODIzMw==",
          "body": "* 1XX 表示消息\r\n* 2XX 表示成功\r\n* 3XX 表示重定向\r\n* 4XX 表示客户端错误\r\n* 5XX 表示服务端错误\r\n\r\n#### 常见的状态码\r\n\r\n* 200\r\n> 最喜欢见到的状态码，表示请求成功\r\n\r\n* 301\r\n> 永久重定向\r\n\r\n* 302\r\n> 临时重定向\r\n\r\n* 304\r\n> 自上次请求，未修改的文件\r\n\r\n* 400\r\n> 错误的请求\r\n\r\n* 401\r\n> 未被授权，需要身份验证，例如token信息等等\r\n\r\n* 403\r\n> 请求被拒绝\r\n\r\n* 404\r\n> 资源缺失，接口不存在，或请求的文件不存在等等\r\n\r\n* 500\r\n> 服务器端的未知错误\r\n\r\n* 502\r\n> 网关错误\r\n\r\n* 503\r\n> 服务暂时无法使用\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jiayankai",
            "url": "https://github.com/jiayankai"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNzI5NjU1MA==",
          "body": "原文地址: <https://shanyue.tech/post/http-status.html>\r\n\r\n*   肯定会碰到: 101/200/301/302/304/400/404/502\r\n*   可能会碰到: 101/200/201/204/206/301/304/307/400/401/403/404/405/413/418/422/429/500/501/502/503/504\r\n\r\n101 Switch Protocol\r\n-------------------\r\n\r\n升级协议，如从 http 到 ws，此时需要反向代理支持，如 Nginx，在 Nginx 配置 websockt 如下:\r\n\r\n```\r\nlocation / {\r\n  proxy_http_version 1.1;\r\n  proxy_set_header Upgrade $http_upgrade;\r\n  proxy_set_header Connection  $connection_upgrade;\r\n}\r\n\r\n\r\n```\r\n\r\n示例:\r\n\r\n![101](https://shanyue.tech/assets/img/101.071b734b.png)\r\n\r\n200 Ok\r\n------\r\n\r\n表示资源请求成功，也是最常见到的状态码\r\n\r\n示例:\r\n\r\n```\r\n$ curl https://shanyue.tech --head\r\nHTTP/2 200\r\n\r\n\r\n```\r\n\r\n201 Created\r\n-----------\r\n\r\n资源创建成功，多用于 POST 请求\r\n\r\n204 No Content\r\n--------------\r\n\r\n响应不会返回 Body，一般由以下两种情况\r\n\r\n1.  与 Options/Delete 请求搭配\r\n2.  打点类\r\n\r\n示例一: 掘金为 Options 请求的状态码设置为 204\r\n\r\n![掘金为 Options 请求的状态码设置为 204](https://shanyue.tech/assets/img/204.5355a3b7.png)\r\n\r\n示例二: 知乎为 Delete 请求的状态码设置为 204，以下请求为取消关注\r\n\r\n![掘金为 Delete 请求的状态码设置为 204](https://shanyue.tech/assets/img/204-del.ee530dd7.png)\r\n\r\n示例三: 当你在知乎看段子时，不妨打开控制台，会发现一个是 204 的状态码\r\n\r\n```\r\n\r\ncurl 'https://www.zhihu.com/sc-profiler' \\\r\n  -H 'content-type: application/json' \\\r\n  --data-binary '[[\"i\",\"production.heifetz.main.desktop.v1.Collector.screen.1536_960.count\",1,1]]' \\\r\n  --compressed -vvv\r\n< HTTP/2 204\r\n< server: CLOUD ELB 1.0.0\r\n< date: Thu, 22 Oct 2020 07:46:30 GMT\r\n< content-type: text/html\r\n< vary: Accept-Encoding\r\n< x-backend-response: 0.002\r\n< cache-control: no-cache, no-store, must-revalidate, private, max-age=0\r\n\r\n\r\n```\r\n\r\n206 Partial Content\r\n-------------------\r\n\r\n当请求多媒体数据数据较大时，会进行分片传输。当你在B站观看视频，打开开发者工具，会发现许多 206 状态码以及响应头 Content-Range\r\n\r\n示例:\r\n\r\n![B站上的视频资源请求状态码为206](https://shanyue.tech/assets/img/206.94474e79.png)\r\n\r\n301 Moved Permanently\r\n---------------------\r\n\r\n永久重定向。http 转向 https时，有时会使用 301，如 B 站。\r\n\r\n```\r\n$ curl www.bilibili.com -vvv\r\n< HTTP/1.1 301 Moved Permanently\r\n< Server: Tengine\r\n< Date: Thu, 22 Oct 2020 08:04:59 GMT\r\n< Content-Type: text/html\r\n< Content-Length: 239\r\n< Connection: keep-alive\r\n< Location: https://www.bilibili.com/\r\n\r\n\r\n```\r\n\r\n302 Found\r\n---------\r\n\r\n暂时重定向。http 转向 https时，有时也会使用 302，如知乎\r\n\r\n```\r\n$ curl www.zhihu.com -vvv\r\n< HTTP/1.1 302 Found\r\n< Location: https://www.zhihu.com/\r\n< Content-Length: 0\r\n< X-NWS-LOG-UUID: 16068764905156850032\r\n< Connection: keep-alive\r\n< Server: Lego Server\r\n< Date: Thu, 22 Oct 2020 08:20:29 GMT\r\n< X-Cache-Lookup: Return Directly\r\n\r\n\r\n```\r\n\r\n304 Not Modified\r\n----------------\r\n\r\n资源已被缓存，与之相关的响应头部有：\r\n\r\n*   `ETag`\r\n*   `last-modified`/`if-modified-since`\r\n\r\n一般用作 `index.html` 等不带 hash 的资源，由于示例太多，这里就不举例了\r\n\r\n307 Temporary Redirect\r\n----------------------\r\n\r\n暂时重定向。也可作为 http 到 https 的重定向。还有一种用途用作 HSTS，当谷歌浏览器发现某 http 资源已被加入到 HSTS 列表，浏览器内部会通过 307 作重定向\r\n\r\n示例:\r\n\r\n![山月个人博客网站的 HSTS](https://shanyue.tech/assets/img/307-shanyue.5f2e9bb3.png)\r\n\r\n![Stackoverflow 中的307](https://shanyue.tech/assets/img/307-stack.914347b0.png)\r\n\r\n> [http 状态码中 301，302和307有什么区别](https://github.com/shfshanyue/Daily-Question/issues/37)\r\n\r\n*   301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\r\n*   302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\r\n*   307，Temporary Redirect。临时重定向，在重定向时不会改变 method\r\n\r\n400 Bad Request\r\n---------------\r\n\r\n对于服务器无法理解的参数，将会使用 400 作为返回码\r\n\r\n示例一: 当 Content-Type: JSON 时，服务器解析 JSON 却失败\r\n\r\n```\r\nHTTP/1.1 400 Bad Request\r\nContent-Length: 35\r\n\r\n{\"message\":\"Problems parsing JSON\"}\r\n\r\n\r\n```\r\n\r\n401 Unauthorized\r\n----------------\r\n\r\n当没有权限的用户请求需要带有权限的资源时，会返回 401，此时携带正确的权限凭证再试一次可以解决问题\r\n\r\n有时认证失败也会返回 401\r\n\r\n示例一: 知乎登录时密码不正确\r\n\r\n![知乎登录失败时](https://shanyue.tech/assets/img/401.bd2d099f.png)\r\n\r\n示例二: Github中错误的凭证信息请求带权限资源\r\n\r\n```\r\n$ curl -i https://api.github.com -u foo:bar\r\n> HTTP/1.1 401 Unauthorized\r\n\r\n> {\r\n>   \"message\": \"Bad credentials\",\r\n>   \"documentation_url\": \"https://developer.github.com/v3\"\r\n> }\r\n\r\n\r\n```\r\n\r\n403 Forbidden\r\n-------------\r\n\r\n我就是不想让你访问，不管你的权限凭证是否正确！\r\n\r\n> In summary, a 401 Unauthorized response should be used for missing or bad authentication, and a 403 Forbidden response should be used afterwards, when the user is authenticated but isn’t authorized to perform the requested operation on the given resource.\r\n\r\n*   [403与401状态码有什么区别](https://stackoverflow.com/questions/3297048/403-forbidden-vs-401-unauthorized-http-responses)\r\n\r\n404 Not Found\r\n-------------\r\n\r\n未找到资源\r\n\r\n405 Method Not Allowed\r\n----------------------\r\n\r\n我需要 POST 这条资源，你去 GET 个锤子\r\n\r\n413 Payload Too Large\r\n---------------------\r\n\r\n不要给我扔这么大的 Body，我处理不过来\r\n\r\n418 I'm A Teapot\r\n----------------\r\n\r\n我是一个茶壶\r\n\r\n我要抛咖啡，你却扔给我一个茶壶？\r\n\r\n也可以用来处理不合法的参数校验，我想要个字符串，你给了我一个整数？\r\n\r\n422 Unprocessable Entity\r\n------------------------\r\n\r\n常用来处理不合法的参数校验。\r\n\r\nGithub 上给某个项目点赞时，故意设置一个不正确的参数命名，会返回状态码 422\r\n\r\n![422](https://shanyue.tech/assets/img/422.c4c88739.png)\r\n\r\n429 Too Many Request\r\n--------------------\r\n\r\n请求过多被限流。\r\n\r\n超过某一个 API 的 Rate Limit 规则，会被限流，返回 429 状态码\r\n\r\n示例: 在 Sentry 中异常上报过于频繁被限流\r\n\r\n500 Internal Server Error\r\n-------------------------\r\n\r\n服务器内部错误，很有可能是应用层未捕获错误而导致整个服务挂掉\r\n\r\n502 Bad Gateway\r\n---------------\r\n\r\nNginx 上常见，从上游应用层未返回响应，上游应用层挂了\r\n\r\n## 503 Service Unavailable\r\n\r\n由于大量流量造成服务忙，稍等一下说不定就能用了\r\n\r\n## 504 Gateway Timeout\r\n\r\n网关超时，上游应用层迟迟未响应\r\n\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjk0MTg=",
    "number": 37,
    "title": "【Q036】http 状态码中 301，302和307有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODQ3NA==",
          "body": "+ 301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\r\n+ 302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\r\n+ 307，Temporary Redirect。临时重定向，在重定向时不会改变 method\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM5NTQ1NjY=",
    "number": 38,
    "title": "【Q037】linux 有哪些发行版，你最喜欢哪一个",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NTAwNjY1Mw==",
          "body": "我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangzl419",
            "url": "https://github.com/zhangzl419"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NTkzMDg0Nw==",
          "body": "> 我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。\r\n\r\n用的人多，就好用了。（不过我装 `tmux` 和 `vim` 都需要从源码编译",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI0NzU5MQ==",
          "body": "linux 的发行版，可以在 https://distrowatch.com 查询\r\n\r\n因为平常工作都在 windows 环境下，只有部署的时候才会用到 linux\r\n我司用到的 linux 为 centos 7 版本，比较稳定\r\n我最喜欢的是 deepin，在业余时间接触过这个，图形化的界面很舒服，唯二的缺点是驱动问题和软件源问题",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQzMDM3ODE=",
    "number": 39,
    "title": "【Q038】使用 react 实现一个通用的 message 组件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5IJEoB",
          "body": "这个没人回答的吗",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HXML",
            "url": "https://github.com/HXML"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQzNjE1ODQ=",
    "number": 40,
    "title": "【Q039】redis 的持久化方案有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTAyNjM1MQ==",
          "body": " rdb aof 主从复制+哨兵\r\nrdb是全量  aof 是增量 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMDczOQ==",
          "body": "两种方案\r\n\r\n+ RDB，备份数据本身。因此粒度不够细，数据完整性也不是能够很好的保证。但是简单粗暴，适合大量数据\r\n+ AOF，备份命令本身。当恢复数据时，把所有写命令执行一遍即可恢复，粒度细，完整性好。正因为是命令，所以恢复速度慢\r\n\r\n如果需要持久化时，两种方案全开。\r\n\r\nPS：一般 redis 只用到缓存功能，无重要数据，如不涉及消息队列，则持久化可以关掉",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQ4MzAwODA=",
    "number": 41,
    "title": "【Q040】k8s 由那些组件组成",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5TUplP",
          "body": "Control Plane Components,Node,Addons\r\nDetail in following website:\r\nhttps://kubernetes.io/zh-cn/docs/concepts/overview/components/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzhejia",
            "url": "https://github.com/wuzhejia"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQ5ODUyMzY=",
    "number": 42,
    "title": "【Q041】CoW 策略指什么，docker 中有哪些应用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5TUsS8",
          "body": "写时复制\r\n优点：\r\n共享镜像层，减少镜像大小、占用存储空间大小\r\n减少容器大小\r\n减少容器的启动时间\r\n当多个容器使用相同镜像时，只需创建可写层\r\n转自：https://www.cnblogs.com/chuanzhang053/p/16612286.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzhejia",
            "url": "https://github.com/wuzhejia"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU3NzExNTQ=",
    "number": 43,
    "title": "【Q042】docker 中如何查看某个容器消耗的内存和CPU",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NTk4MjU5MA==",
          "body": "``` bash\r\n$ docker stats postgres\r\nCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS\r\nadb85849e229        postgres            0.00%               3.328MiB / 1.796GiB   0.18%               0B / 0B             874GB / 2.6GB       7\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDc3NjY=",
    "number": 44,
    "title": "【Q043】如何使用命令查看一个文件有多少字符以及多少行",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxMzIzMTc2NQ==",
          "body": "wc，及 `word count`，用以统计一个文件的行数、单词数、字符数及文件大小\r\n\r\n``` bash\r\n# 97 - lines\r\n# 177 - words\r\n# 5087 - bytes\r\n$ wc Readme.md\r\n97  177 5087 Readme.md\r\n\r\n# -m 用以统计字符数\r\n$ wc -m Readme.md\r\n3107 Readme.md\r\n```\r\n\r\n\r\n相关问题：\r\n\r\n+ [Vim 中如何查看文件的行数及字符数](https://github.com/shfshanyue/Daily-Question/issues/45)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDkzNzk=",
    "number": 45,
    "title": "【Q044】如何使用vim查看文件有多少个字符以及多少行",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxMzIzMDA1OA==",
          "body": "在 `Normal` 模式下，可以通过快捷键 `g + <Ctrl-g>` 查看文件行数、列数、字符数及所占字节大小，此时状态栏(即 vim 最底下一行)显示如下：\r\n\r\n``` txt\r\nCol 1 of 10; Line 28 of 161; Word 71 of 377; Char 636 of 4315; Byte 768 of 4969\r\n```\r\n\r\n如果**仅仅想要了解文件行数及列数**，可以通过快捷键 `<Ctrl-g>` 查看，此时状态栏如下\r\n\r\n``` txt\r\n\"package.json\" 行 14 / 42 --33%-- 列 5\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/97083635-f725c680-1643-11eb-8716-75a88ad14edc.png)\r\n\r\n如果**仅仅想要了解文件行数**，可以通过快捷键 `G` 直接移动到文件最后一行来查看行数\r\n\r\n## 相关问题：\r\n\r\n+ [Linux 中如何使用命令查看文件的行数及字符数](https://github.com/shfshanyue/Daily-Question/issues/44)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg3OTAxMzk2",
          "name": "vim"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjAwNDE=",
    "number": 46,
    "title": "【Q045】如何把一个 CIDR 地址转化为IP地址范围段",
    "body": "如 `172.16.0.0/27` 的IP范围是多少",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5vqPSD",
          "body": "172.16.0.0/27中的“27”表示网络前缀的位数为27，ipv4总地址位数为32，所以用于子网的位数为32 - 27 = 5。\r\n\r\n5位二进制数的大小范围是0～31，故ip地址范围段是172.16.0.0 ～ 172.16.0.31。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "enmida",
            "url": "https://github.com/enmida"
          }
        },
        {
          "id": "IC_kwDODQzyOs5vqPUq",
          "body": "这是来自QQ邮箱的假期自动回复邮件。你好，我最近正在休假中，无法亲自回复你的邮件。我将在假期结束后，尽快给你回复。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "loveminxo",
            "url": "https://github.com/loveminxo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjcwODc=",
    "number": 47,
    "title": "【Q046】docker 中的网络隔离是如何实现的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NjAxODkxNQ==",
          "body": "参考: https://docs.docker.com/network/iptables/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTA3NDk=",
    "number": 48,
    "title": "【Q047】如何设计一个高并发系统",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sdENM",
          "body": "设计高并发系统主要围绕以下三个方面：\r\n1. 分布式架构\r\n    由于采用分布式架构，所以相比于单体应用就要围绕分布式架构做一系列的调整，所以在数据一致性上必须引用分布式锁来防止资源竞争，所以就需要用到Redis或者zookeeper这种保证原子性的软件，这里通常会采用Redis，因为Redis同时会作为缓存使用，同时由于一个服务对应有多个机器，所以我们就需要有服务治理的软件，如etcd, eureka, zookeeper等作为服务注册发现，那服务与服务之间内部的调用一般采用远程调用协议，常用的是gRPC，因为它支持服务发现机制，非常适合分布式架构。由于分布式架构，服务与服务之间如果靠同步请求将会造成请求极度缓慢，所以就必须采用消息队列来实现异步请求，那就需要用到Kafka, Pulsar和RabbitMQ这些消息队列服务；\r\n\r\n2. 负载均衡\r\n    我们采用分布式架构进行平行扩展，减轻单个机器承载的并发量，那并发量具体怎么分配就会涉及到负载均衡，常用的如nginx的负债均衡，云平台的网关或者第三方网关等；\r\n\r\n3. 数据库优化\r\n    数据库常常是高并发下最大的瓶颈，首先最常用的是采用Redis来缓存从而减少直接对数据库的请求，另外就是根据业务性质选择合适的数据库，如对于大量历史数据的存储可以采用NoSQL的数据库，如MongoDB等，而对于事务性数据才存储在关系型数据库如MySQL，如果使用的MySQL还可以针对MySQL进行读写分离，分库分表，优化连接数，优化索引等优化措施；\r\n\r\n而除了以上三个方面，还需要在日志记录，链路追踪，服务监控，容错等等方面考虑更细节的问题。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTM0MTI=",
    "number": 49,
    "title": "【Q048】如何实现一个优先级队列",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs48wSTf",
          "body": "// 封装优先级队列\r\nfunction PriorityQueue() {\r\n    // 在PriorityQueue中重新创建一个类，和java中的内部类很相似\r\n    function QueueElement(element, priority) {\r\n     this.element = element;\r\n     this.priority = priority;\r\n    }\r\n    // 封装属性，用数组来存储队列\r\n    this.items = [];\r\n    \r\n    // 入队\r\n    PriorityQueue.prototype.enQueue = function (element, priority) {\r\n     // 1.创建对象\r\n     var queueElement = new QueueElement(element, priority);\r\n     // 2.判断队列是否为空\r\n     if(this.items.length == 0) \r\n       this.items.push(queueElement);\r\n     else {\r\n       var flag = false;\r\n       for(var i = 0; i< this.items.length; i++){\r\n         if(queueElement.priority < this.items[i].priority){\r\n           this.items.splice(i,0,queueElement);\r\n           flag = true;\r\n           break;\r\n         }\r\n       }\r\n       if(!flag) \r\n         this.items.push(queueElement);\r\n     }\r\n    }\r\n    \r\n    // 2.出队\r\n    PriorityQueue.prototype.deQueue = function () {\r\n     return this.items.shift();\r\n    }\r\n    \r\n    // 3.查看队头元素\r\n    PriorityQueue.prototype.front = function() {\r\n     return this.items[0];\r\n    }\r\n    \r\n    // 4.判断队列是否为空\r\n    PriorityQueue.prototype.isEmpty = function() {\r\n     return this.items.length == 0;\r\n    }\r\n    \r\n    // 5.查看队列中元素的个数\r\n    PriorityQueue.prototype.size = function() {\r\n     return this.items.length;\r\n    }\r\n    \r\n    // 6.将队列元素按字符串格式输出\r\n    PriorityQueue.prototype.toString = function() {\r\n     var result = \"\";\r\n     for(var i = 0; i < this.items.length; i++)\r\n       result += this.items[i].element + \"  \";\r\n     return result;\r\n    }\r\n    }\r\n    ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hx-code",
            "url": "https://github.com/hx-code"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-I_sd",
          "body": "基于最大堆实现优先队列\r\n````js\r\nclass MaxHeap {\r\n  constructor(arr = []) {\r\n    this.heap = [] // 用数组表示堆结构\r\n    arr.forEach(item => this.add(item))\r\n  }\r\n\r\n  add(value) { // O(logK) 插入节点值: 放入数组末尾并上浮到合适位置\r\n    this.heap.push(value)\r\n    this.shiftUp(this.heap.length - 1)\r\n  }\r\n\r\n  pop() { // O(logK) 提取最大值/堆顶: 提取 heap[0] 并用 heap[-1] 进行代替，然后从顶部开始下沉到合适位置\r\n    const max = this.heap[0]\r\n    this.swap(0, this.size() - 1)\r\n    this.heap.pop()\r\n    this.shiftDown(0)\r\n    return max\r\n  }\r\n\r\n  peek() { // 获取最值/堆顶\r\n    return this.heap[0]\r\n  }\r\n\r\n  size() { // 获取当前堆大小\r\n    return this.heap.length\r\n  }\r\n\r\n  // ↓私有属性↓\r\n  swap(index1, index2) { // 交换节点位置\r\n    const temp = this.heap[index1]\r\n    this.heap[index1] = this.heap[index2]\r\n    this.heap[index2] = temp\r\n  }\r\n\r\n  parentIndex(index) { // 获取父节点的位置 (index - 1) / 2 向下取整\r\n    return (index - 1) >> 1\r\n  }\r\n\r\n  leftChildIndex(index) { // 获取左子节点\r\n    return index * 2 + 1\r\n  }\r\n\r\n  rightChildIndex(index) { // 获取右子节点\r\n    return index * 2 + 2\r\n  }\r\n\r\n  shiftUp(index) { // 上浮节点，当前值小于父节点值时停止，使当前堆保持最大堆的性质\r\n    let parentIndex = this.parentIndex(index)\r\n    while (index > 0 && this.heap[parentIndex] < this.heap[index]) {\r\n      this.swap(index, parentIndex)\r\n      parentIndex = this.parentIndex(index = parentIndex)\r\n    }\r\n  }\r\n\r\n  shiftDown(index) { // 下沉节点，当前值大于子节点值时停止，使当前堆保持最大堆的性质\r\n    const leftIndex = this.leftChildIndex(index)\r\n    const rightIndex = this.rightChildIndex(index)\r\n    //  先比较左子节点值，当前值小于左子节点，则交换,并递归进行下沉\r\n    if (this.heap[index] < this.heap[leftIndex]) {\r\n      this.swap(leftIndex, index)\r\n      this.shiftDown(leftIndex)\r\n    }\r\n    if (this.heap[index] < this.heap[rightIndex]) {\r\n      this.swap(rightIndex, index)\r\n      this.shiftDown(rightIndex)\r\n    }\r\n  }\r\n}\r\n\r\n// ==TEST==\r\nconst priorityQueue = new MaxHeap([2, 5, 3])\r\nconsole.log(priorityQueue.peek()) // 5\r\npriorityQueue.add(7)\r\nconsole.log(priorityQueue.peek()) // 7\r\npriorityQueue.pop()\r\npriorityQueue.add(1)\r\nconsole.log(priorityQueue.peek()) // 5\r\n\r\n````",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "someGenki",
            "url": "https://github.com/someGenki"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY5MjA3MTI=",
    "number": 50,
    "title": "【Q049】什么是守护进程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzYyOQ==",
          "body": "守护进程，可以被认为是后台进程，当你把控制台关闭时，它仍然还会运行。\r\n\r\n当然 - 这只是表面，从更深层次看呢？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjcwNjMyNjg=",
    "number": 51,
    "title": "【Q050】http 状态码 502 和 504 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NzQ3NTAyNw==",
          "body": "* 502 Bad Gateway\r\nThe server was acting as a gateway or proxy and received an invalid response from the upstream server.\r\n收到了上游响应但无法解析\r\n\r\n* 504 Gateway Timeout\r\nThe server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\r\n上游响应超时\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "sjfkai",
            "url": "https://github.com/sjfkai"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNTkyMTk3Mg==",
          "body": "这两种异常状态码都与网关 Gateway 有关，首先明确两个概念\r\n\r\n+ Proxy (Gateway)，反向代理层或者网关层。在公司级应用中一般使用 Nginx 扮演这个角色\r\n+ Application (upstream serrver)，应用层服务，作为 Proxy 层的上游服务。在公司中一般为各种语言编写的服务器应用，如 Go/Java/Python/PHP/Node 等\r\n\r\n此时关于 502 与 504 的区别就很显而易见\r\n\r\n+ `502 Bad Gateway`。一般表现为你自己写的应用层服务(Java/Go/PHP)挂了，网关层无法接收到响应\r\n+ `504 Gateway Timeout`。一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间",
          "star": {
            "totalCount": 7
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQxMDI=",
    "number": 52,
    "title": "【Q051】简述一下 graphql，它的引进有什么好处",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5DQjX-",
          "body": "GraphQL是一种新的API标准，本质是一个用于 API 的查询语言；它提供了一种高效、强大和灵活的数据查询方式。它主要目的是使用简单描述数据需求和交互的灵活语法和系统。\r\nGraphQL的引进降低了API接口数据冗余，响应过慢的情况，使得接口返回数据与数据请求预期结果保持一致性。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ChenJuo",
            "url": "https://github.com/ChenJuo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQ0MTc=",
    "number": 53,
    "title": "【Q052】graphql 的引进有什么风险，以及性能问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sfyLS",
          "body": "引入 GraphQL 带来了很多优势，但同时也可能面临一些挑战和风险。以下是一些可能的风险和性能问题：\r\n\r\n风险：\r\n复杂性： GraphQL 查询可以非常灵活，但也可能变得复杂，特别是当查询涉及到嵌套关系和多个数据源时。管理复杂的查询可能需要更多的时间和资源。\r\n过度获取： 如果前端开发者不小心，他们可能请求过多的数据，导致过度获取。这可能会对性能产生负面影响，因为服务器可能需要检索并传输更多的数据。\r\n安全性： 不正确的查询可能导致安全漏洞，例如查询敏感数据或通过查询暴露敏感信息。正确配置和验证 GraphQL 查询是确保安全性的关键。\r\n维护成本： GraphQL 的引入可能需要更多的培训和学习成本。团队需要了解 GraphQL 查询语言以及如何有效地设计和管理 GraphQL Schema。\r\n\r\n性能问题：\r\nN+1 查询问题： 在关联数据的情况下，可能出现 N+1 查询问题，即对于每个主记录，需要额外发出 N 个附加查询。这可能导致数据库负担增加，性能下降。\r\n深度嵌套查询： 如果允许无限深度的嵌套查询，可能会导致性能问题，因为每个嵌套层级都需要额外的数据库查询。\r\n缓存难题： 由于 GraphQL 查询可以是动态的，可能更难有效地使用缓存。缓存的粒度和有效性需要更仔细地考虑。\r\n网络开销： 一次大型查询可能会导致大量的数据传输，增加网络开销。这对于移动设备和慢速网络连接可能是一个问题。\r\n\r\n为了解决这些问题，团队可以采取以下措施：\r\n查询优化： 确保查询是有效的，不会导致过度获取或 N+1 查询问题。可以使用 DataLoader 等工具来优化数据库查询。\r\n缓存策略： 有效地使用缓存，考虑缓存的粒度和过期策略。\r\n安全性措施： 实施合适的权限和验证措施，确保只有授权用户能够访问和修改特定的数据。\r\n性能监控： 使用性能监控工具来跟踪查询的性能，并及时发现和解决性能问题。\r\n\r\n总体而言，GraphQL 引入了灵活性和易用性，但在使用时需要仔细考虑和解决潜在的风险和性能问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc1MzEwMDA=",
    "number": 54,
    "title": "【Q053】什么是对象存储，与块存储和文件存储有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc3MDM1MTU=",
    "number": 55,
    "title": "【Q054】简述TCP 的三次握手",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNTkzMw==",
          "body": "我：你在吗？\r\n他： 我在的。\r\n我： 那开始聊天吧",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "WenHaiYana",
            "url": "https://github.com/WenHaiYana"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTUyNTk0NA==",
          "body": "一图胜千言\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Tcp-handshake.svg/537px-Tcp-handshake.svg.png)\r\n\r\n三次握手之后，客户端与服务器端的两个 socket 处于 `ESTABSHED` 状态",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_QP54",
          "body": "第一次：服务端知道客户端有发送能力\r\n第二次：客户端知道服务端有发送和接受的能力\r\n第三次：服务端知道客户端有接受能力",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "changshou83",
            "url": "https://github.com/changshou83"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BJSBk",
          "body": "第一次握手：发送方请求连接\r\n客户端状态: (syn_send)\r\n具体行为：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机\r\n目的：确定客户端能够正常发送信息\r\n第二次握手：服务方发送应答报文\r\n服务端状态:(syn_recv)\r\n具体行为：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包\r\n目的：确定服务端能够正常收取信息 发送信息\r\n第三次握手：服务方发送应答报文\r\n服务端状态:(establish)\r\n具体行为：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包\r\n目的：确定服务端能够正常收取信息 发送信息",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SunshineHusky",
            "url": "https://github.com/SunshineHusky"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc3ODA5MDQ=",
    "number": 56,
    "title": "【Q055】如何在 linux 中打印所有环境变量",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTY3OTYxNA==",
          "body": "``` shell\r\n$ printenv\r\nXDG_SESSION_ID=10536\r\nHOSTNAME=shanyue\r\nTERM=xterm-256color\r\nSHELL=/bin/bash\r\nHISTSIZE=1000\r\nSSH_CLIENT=124.200.184.74 16003 22\r\nSSH_TTY=/dev/pts/0\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzYwMjU=",
    "number": 57,
    "title": "【Q056】什么是服务降级",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4-Wu0x",
          "body": "服务降级就是将某些服务停掉或者不进行业务处理，释放资源来维持主要服务的功能。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "18820227745",
            "url": "https://github.com/18820227745"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzkzNzE=",
    "number": 58,
    "title": "【Q057】什么是熔断机制，微服务如何做熔断",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODU0OA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5sf3QR",
          "body": "熔断机制是分布式架构中用来防止服务雪崩的策略，因为服务之间可能存在依赖，假如某个服务存在高延迟造成大量请求拥挤，将会导致后续的服务无法进行，熔断机制这时会在请求进来的时候根据设定的策略判断该服务是否有异常，当存在异常时，熔断器会直接返回预设的响应，这样不会阻塞整个请求。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc5MzkyNjU=",
    "number": 59,
    "title": "【Q058】什么是负载均衡",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sf5rT",
          "body": "负载均衡是分布式架构里针对流量进行均衡的机制，当多个请求过来时，根据服务器性能，业务实际情况对请求分配给业务相同的机器，负载均衡常用的算法有轮询，基于权重的轮训，随机，和IP Hash，比如一个IP请求某个接口可能会产生token或者其他缓存，如果这些token和缓存没有做远端持久化只是存在内存当中，那负载均衡就需要采用IP Hash来保证这个IP在每次请求的时候都是分配到同一台机器，这样它才能够使用到缓存。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0Njk3NTU=",
    "number": 60,
    "title": "【Q059】四层负载均衡与七层负载均衡有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ5OQ==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5sf8Vs",
          "body": "四层负载均衡和七层负载均衡指的是负载均衡是工作在OSI的第几层，即四层负载均衡是传输层负载均衡，它是根据传输层的信息，主要是IP和端口来进行分发，而七层负载均衡是应用层负载均衡，它是根据应用层的信息，主要是URL，cookie，报文头等来进行分发，像nginx是支持两种负载均衡模式的，而CDN则是基于七层负载均衡的。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzAzNTI=",
    "number": 61,
    "title": "【Q060】你们项目中的计划任务是如何组织的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzU1NQ==",
          "body": "TODO\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNTQ0OTkyMQ==",
          "body": "计划任务？这种？\r\n![image](https://user-images.githubusercontent.com/57755075/97030224-0f88d900-1591-11eb-8194-73ef01955e2f.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzE0MDg=",
    "number": 62,
    "title": "【Q061】如何判断两个链表是否相交",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzA5MDI0MQ==",
          "body": "只判断链表相交，好一点的方式是用双指针+哈希表。\r\n同时遍历a，b链表，如果当前a和b所在元素不在哈希表，则将元素加入哈希表。知道找到哈希表里面重复元素则算相交。时间复杂度o(max(a, b))是a，b不想交部分的较大值。空间复杂度是o(a + b)，a和b不想交部分。\r\n\r\n第二种是遍历a和b，判断尾指针是否相等。时间复杂度o(a + b)，空间复杂度o(1)。\r\n\r\n进阶问题是，找到相交链表的第一个相交点",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wython",
            "url": "https://github.com/wython"
          }
        },
        {
          "id": "IC_kwDODQzyOs41Ec27",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzQxMDE=",
    "number": 63,
    "title": "【Q062】RPC 与 REST 有什么优劣",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ1Mw==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OJnkb",
          "body": "rest的劣势可太多了。。\r\n1. 路由冲突，这个非常常见，尤其在层级很深的情况\r\n2. utils类的路由命名没有规范\r\n3. crud resource，但是批量的接口 没有路由规范，批量创建，删除，或者批量关联。\r\n4. 有时候资源之间的关系很难界定，写路由的时候很难清楚的表达两者的关系。\r\n\r\nrpc不太了解，直接调用方法？\r\n1. 能想到的是 调用起来还是比rest麻烦的，\r\n2. 没有行业规范，命名之类的\r\n3. 文档可能比rest更麻烦一点，跟实现的语言有关，rest可以说是语言无关的。\r\n\r\n两者场景\r\nrest适合暴露给外部，作为外部的服务。\r\n\r\nrpc更适合企业内部服务之间的调用。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "grace-shi",
            "url": "https://github.com/grace-shi"
          }
        },
        {
          "id": "IC_kwDODQzyOs5sf_9z",
          "body": "REST：\r\n优势：编写简单，易于外部调用，浏览器支持，基于文本的响应可读性强，灵活性强\r\n劣势：文本传输性能较差，不像RPC那样在使用上有严格的标准，所以不同人使用上差异化比较大\r\n\r\nRPC：\r\n优势：基于二进制协议的传输，性能比REST好，使用上有严格的标准以及强类型限制使可靠性增强，请求和响应必需借用相关的RPC库，这一特性天然适用于内部服务的的请求，安全性较强\r\n劣势：使用上比REST复杂，需提前定义好请求和响应的结构，传输的数据由于是二进制必须进行序列化才可阅读\r\n\r\n总体来说外部请求采用REST更为简单和兼容性强，内部请求采用RPC性能更强，可靠性高，更安全。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzc1Mzk=",
    "number": 64,
    "title": "【Q063】SIGINT SIGTERM SIGKILL 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM5OA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE0MzU=",
    "number": 65,
    "title": "【Q064】如何实现服务发现 (Service Discovery)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM0NQ==",
          "body": "TODO: k8s 的服务发现是如何实现的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE4MzI=",
    "number": 66,
    "title": "【Q065】有没有使用过 oss，对象存储相比块存储和文件存储有什么优缺点",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzIzOA==",
          "body": "OSS 兼具分布式与读取速度的平衡吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxMzEzOTk=",
    "number": 67,
    "title": "【Q066】如何使用 react hooks 实现 useFetch 请求数据",
    "body": "比如设计成 `useFetch` 这种形式，它的 API 应该如何设计",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0NDYyMg==",
          "body": "可以参考 [How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5HJ-XW",
          "body": "import React, { Fragment, useState, useEffect } from \"react\";\r\n\r\nfunction App() {\r\n  const [data, setData] = useState([]);\r\n  useEffect(() => {\r\n    async function fetchData() {\r\n      // You can await here\r\n      const response = await MyAPI.getData(someId);\r\n      setData(response);\r\n    }\r\n    fetchData();\r\n  }, []);\r\n  return (\r\n    <Fragment>\r\n      <input type=\"text\" />\r\n      <ul>\r\n        {data.map((item) => (\r\n          <li key={item.objectID}>\r\n            <a href={item.url}>{item.title}</a>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </Fragment>\r\n  );\r\n}\r\n\r\nexport default App;\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zfy171",
            "url": "https://github.com/zfy171"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxNDIxODg=",
    "number": 68,
    "title": "【Q067】react 如何使用 render prop component 请求数据",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODM4Mg==",
          "body": "参考: <https://www.robinwieruch.de/react-fetching-data#how-to-fetch-data-in-render-props>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjYxNzA=",
    "number": 69,
    "title": "【Q068】React Portal 有哪些使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTY0ODY2MQ==",
          "body": "> Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.\r\n\r\n在以前， `react` 中所有的组件都会位于 `#app` 下，而使用 `Portals` 提供了一种脱离 `#app` 的组件。\r\n\r\n因此 `Portals` 适合脱离文档流(out of flow) 的组件，特别是 `position: absolute` 与 `position: fixed` 的组件。比如模态框，通知，警告，goTop 等。\r\n\r\n以下是官方一个模态框的示例，可以在以下地址中测试效果 <https://codepen.io/gaearon/pen/jGBWpE?editors=1010>\r\n\r\n\r\n``` html\r\n<html>\r\n  <body>\r\n    <div id=\"app\"></div>\r\n    <div id=\"modal\"></div>\r\n    <div id=\"gotop\"></div>\r\n    <div id=\"alert\"></div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n\r\n``` jsx\r\nconst modalRoot = document.getElementById('modal');\r\n\r\nclass Modal extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.el = document.createElement('div');\r\n  }\r\n\r\n  componentDidMount() {\r\n    modalRoot.appendChild(this.el);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    modalRoot.removeChild(this.el);\r\n  }\r\n\r\n  render() {\r\n    return ReactDOM.createPortal(\r\n      this.props.children,\r\n      this.el,\r\n    );\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjY5OTE=",
    "number": 70,
    "title": "【Q069】什么是 virtual DOM，它的引入带了什么好处",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDAyNQ==",
          "body": "- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。\r\n-  vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。\r\n\r\n\r\n- Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。\r\n实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。\r\n- 打开了函数式 UI 编程的大门。\r\n- 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。\r\n- 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。\r\n- 组件的高度抽象化。\r\n\r\n> 虚拟 DOM 的缺点\r\n- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\r\n- 虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。\r\n- 如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。\r\n",
          "star": {
            "totalCount": 10
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTQ1MjM0Mg==",
          "body": "同意楼上",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "eEmpty",
            "url": "https://github.com/eEmpty"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTU5MzUwOQ==",
          "body": "react初次render或协调后所生成的一个对象，react16前是通过组件递归遍历而来，react16是以fiber为节点构建成的单链表结构树，其作为真实dom的映射。\r\n优点：大大地提高了开发效率，解放生产力，通过计算这两棵树之间的差别来判断如何有效率的更新。\r\n缺点：初次需要构建遍历深层次的组件树，耗费性能，所以有普遍首屏渲染慢的问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk5MzIxOTA=",
    "number": 71,
    "title": "【Q070】如何用 linux 命令输出文件的特定行",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTYzNTA3Mg==",
          "body": "通常使用 `sed` 命令打印特定行，如\r\n\r\n``` bash\r\n# -n: 按特定格式打印\r\n# 100p: 指打印第一百行\r\n$ sed -n 100p Readme.md\r\n```\r\n\r\n但 `sed` 打印的本领，远不止于此，除了打印特定行，还可以打印一段范围的行，如\r\n\r\n``` bash\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,120p Readme.md\r\n\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,+20p Readme.md\r\n```\r\n\r\n还有一种本办法，`head`/`tail` 的组合命令，以要输出第100行为例\r\n\r\n``` bash\r\n# 输出前100行，再通过 pipe，输出最后一行\r\n$ head -100 Readme.md | tail -1\r\n```\r\n\r\n关于 `sed` 更多的用法可以参考我的文章: [sed 命令详解及示例](https://shanyue.tech/op/linux-sed.html)\r\n\r\n## 总结\r\n\r\n两种方法\r\n\r\n1. `sed -n 100p Readme.md`\r\n1. `head -100 Readme.md | tail -1`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1Nzc4MjA=",
    "number": 72,
    "title": "【Q071】react 与 vue 数组中 key 的作用是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxOTMwODgxNQ==",
          "body": "diff算法需要比对虚拟dom的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode会首先判断key和标签名是否一致，如果一致再去判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快消耗更少",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "suImagine",
            "url": "https://github.com/suImagine"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODYyNDI=",
    "number": 73,
    "title": "【Q072】webpack 是用来做什么的，原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTE3MTUzNg==",
          "body": "https://juejin.im/post/5e01de37f265da33ab637daf?utm_source=gold_browser_extension",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lf75152798",
            "url": "https://github.com/lf75152798"
          }
        },
        {
          "id": "IC_kwDODQzyOs47U_ei",
          "body": "感觉没有怎么说到原理的东西哇",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "spicylemonhaha",
            "url": "https://github.com/spicylemonhaha"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODgzMTQ=",
    "number": 74,
    "title": "【Q073】webpack 中的 loader 的作用是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTQ5Mw==",
          "body": "哎  lodaer 的作用就是处理单个文件的  跳到这啥都没有",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wang120140",
            "url": "https://github.com/wang120140"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3MzIzODEzNA==",
          "body": "`webpack `是基于node的，只能处理 `JS `和 `JSON `文件，loader 的作用是用来处理其他类型的文件（less\\vue....等）\r\n可以将 less 转成 css 文件，将 `jsx `处理成 `JS `文件，将其他版本的ES处理成浏览器能识别的ES版本\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Linya-IronMan",
            "url": "https://github.com/Linya-IronMan"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MTE1NzI1NQ==",
          "body": "`loader` 用以对某个文件进行 `import` 或者 `require`，在此过程中可能会涉及到解析与编译，如 `js` 通过 `babel` 进行编译。\r\n\r\n以下是 `url-loader` 的源码，用以转化为 Base64 URL 的一个 loader，从中可以看出它把源代码 `content` 转化为被 webpack 支持的模块 `module.exports = ***`\r\n\r\n``` js\r\nfunction getEncodedData(generator, mimetype, encoding, content, resourcePath) {\r\n  if (generator) {\r\n    return generator(content, mimetype, encoding, resourcePath);\r\n  }\r\n\r\n  return `data:${mimetype}${encoding ? `;${encoding}` : ''},${content.toString(\r\n    // eslint-disable-next-line no-undefined\r\n    encoding || undefined\r\n  )}`;\r\n}\r\n\r\nexport default function loader(content) {\r\n  // Loader Options\r\n  const options = getOptions(this) || {};\r\n\r\n  validate(schema, options, {\r\n    name: 'URL Loader',\r\n    baseDataPath: 'options',\r\n  });\r\n\r\n  if (shouldTransform(options.limit, content.length)) {\r\n    const { resourcePath } = this;\r\n    const mimetype = getMimetype(options.mimetype, resourcePath);\r\n    const encoding = getEncoding(options.encoding);\r\n\r\n    if (typeof content === 'string') {\r\n      // eslint-disable-next-line no-param-reassign\r\n      content = Buffer.from(content);\r\n    }\r\n\r\n    const encodedData = getEncodedData(\r\n      options.generator,\r\n      mimetype,\r\n      encoding,\r\n      content,\r\n      resourcePath\r\n    );\r\n\r\n    const esModule =\r\n      typeof options.esModule !== 'undefined' ? options.esModule : true;\r\n\r\n    return `${\r\n      esModule ? 'export default' : 'module.exports ='\r\n    } ${JSON.stringify(encodedData)}`;\r\n  }\r\n\r\n  // 忽略\r\n}\r\n\r\n// Loader Mode\r\nexport const raw = true;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg1MTY=",
    "number": 75,
    "title": "【Q074】有没有自己写过一个webpack的loader",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTUyOA==",
          "body": "我看过源码 没有写过",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "wang120140",
            "url": "https://github.com/wang120140"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg2MTQ=",
    "number": 76,
    "title": "【Q075】webpack 中plugin的作用是什么，有没有自己写过",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5BxKa1",
          "body": "loaders的作用是转换其他类型的语言到JS语言, plugins可以做其他所有loaders做不了的事情, 比如: \r\n* bundle optimization(bundle优化)\r\n* assets management(assets管理)\r\n* injection of environment variables(注入环境变量)\r\n* etc.\r\n\r\n实际上plugins是webpack的基石, webpack就是在plugin system上建立起来的.\r\n\r\n为了使用plugins, 我们需要 **require()** 并将它加入 **plugins** 数组. \r\n\r\n``` js\r\n// webpack.config.js\r\n\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\nconst webpack = require('webpack'); //to access built-in plugins\r\n\r\nmodule.exports = {\r\n  module: {\r\n    rules: [{ test: /\\.txt$/, use: 'raw-loader' }],\r\n  },\r\n  plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],\r\n};\r\n```\r\n\r\n在上面的例子中, **html-webpack-plugin**为我们的应用程序生成了一个html文件并自动注入所有生成的bundle.\r\n\r\n[webpack提供的plugin列表](https://webpack.js.org/plugins/)\r\n\r\nreference: [webpack官方文档](https://webpack.js.org/concepts/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "swingpenguin",
            "url": "https://github.com/swingpenguin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODkyODU=",
    "number": 77,
    "title": "【Q076】如何设计一个短网址生成服务",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNDU3OTY5Mg==",
          "body": "建立一张表存储长链和短链接的对应关系，把长链接按照规则或随机生成短链接，且要保证短链接生成后唯一\r\n每次点击短链接的时候，就去查询长链接出来替换就可以了\r\n\r\n工作需要，用过百度提供的转短链接服务！！！\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maqiang123",
            "url": "https://github.com/maqiang123"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjMzNzQ=",
    "number": 78,
    "title": "【Q077】使用 webpack 时如何优化项目体积",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDEzMzg3Mg==",
          "body": "使用用uglyfly进行代码压缩，使用commonsChunk分离第三方代码",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangjinzhepro",
            "url": "https://github.com/zhangjinzhepro"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MjM0ODI2NQ==",
          "body": "按需加载，代码压缩，代码分割，CDN优化，gzip加速",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Michael-lzg",
            "url": "https://github.com/Michael-lzg"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTUyMTU3Nw==",
          "body": "多入口情况下，使用 CommonsChunkPlugin 来提取公共代码\r\n通过externals配置来提取常用库\r\n使用 Happypack 实现多线程加速编译\r\n使用 Tree-shaking剔除多余代码",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wjw-gavin",
            "url": "https://github.com/wjw-gavin"
          }
        },
        {
          "id": "IC_kwDODQzyOs5iKK3z",
          "body": "1、提取第三方库或通过引用外部文件的方式引入第三方库\r\n2、代码压缩插件UglifyJsPlugin\r\n3、服务器启用gzip压缩\r\n4、剥离css文件，单独打包\r\n5、Tree Shaking 在构建打包过程中，移除那些引入但未被使用的无效代码",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ajiaosong",
            "url": "https://github.com/ajiaosong"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjM4NTA=",
    "number": 79,
    "title": "【Q078】webpack 中什么是 HMR，原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTUyMDc5OA==",
          "body": "HMR（Hot Module Replacement），热更新又称热替换，基于 webpack-dev-server。\r\n第一步：webpack 对文件系统进行 watch 打包到内存中\r\n第二步：devServer 通知浏览器端文件发生改变，在这一阶段，sockjs 是服务端和浏览器端之间的桥梁，在启动 devServer 的时候，sockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器\r\n第三步：webpack-dev-server/client 接收到服务端消息做出响应\r\n第四步：webpack 接收到最新 hash 值验证并请求模块代码\r\n第五步：HotModuleReplacement.runtime 对模块进行热更新\r\n第六步：调用accept 方法，及时将新后的内容插入到页面中",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wjw-gavin",
            "url": "https://github.com/wjw-gavin"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyMzI5NTM1Mw==",
          "body": "@wjw-gavin 可以把其中的 npm 包列出来，比如 webpack 如何对 fs 进行watch的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44faCz",
          "body": "HMR，Hot Module Replacement，热模块替换，见名思意，即无需刷新在内存环境中即可替换掉过旧模块。与 Live Reload 相对应。\r\n\r\n> PS: Live Reload，当代码进行更新后，在浏览器自动刷新以获取最新前端代码。\r\n\r\n在 webpack 的运行时中 `__webpack__modules__` 用以维护所有的模块。\r\n\r\n而热模块替换的原理，即通过 `chunk` 的方式加载最新的 `modules`，找到 `__webpack__modules__` 中对应的模块逐一替换，并删除其上下缓存。\r\n\r\n其精简数据结构用以下代码表示:\r\n\r\n``` js\r\n// webpack 运行时代码\r\nconst __webpack_modules = [\r\n  (module, exports, __webpack_require__) => { __webpack_require__(0)  },\r\n  () => { console.log(\"这是一号模块\") }\r\n]\r\n\r\n// HMR Chunk 代码\r\n// JSONP 异步加载的所需要更新的 modules，并在 __webpack_modules__ 中进行替换\r\nself[\"webpackHotUpdate\"](0, {\r\n  1: () => {\r\n     console.log('这是最新的一号模块')\r\n  }\r\n})\r\n```\r\n\r\n其下为更具体更完整的流程，每一步都涉及众多，有兴趣的可阅读 `webpack-dev-server` 及开发环境 webpack 运行时的源码。\r\n\r\n1. `webpack-dev-server` 将打包输出 bundle 使用内存型文件系统控制，而非真实的文件系统。此时使用的是 [memfs](https://github.com/streamich/memfs) 模拟 node.js `fs` API\r\n1.  每当文件发生变更时，`webpack` 将会重新编译，`webpack-dev-server` 将会监控到此时文件变更事件，并找到其对应的 `module`。此时使用的是 [chokidar](https://github.com/paulmillr/chokidar) 监控文件变更\r\n1.  `webpack-dev-server` 将会把变更模块通知到浏览器端，此时使用 `websocket` 与浏览器进行交流。此时使用的是 [ws](https://github.com/websockets/ws)\r\n1. 浏览器根据 `websocket` 接收到 hash，并通过 hash 以 JSONP 的方式请求更新模块的 chunk\r\n1. 浏览器加载 chunk，并使用新的模块对旧模块进行热替换，并删除其缓存",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ0NjY=",
    "number": 80,
    "title": "【Q079】简述 http 的缓存机制",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTg5MTI5OA==",
          "body": "强缓存 协商缓存",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jianxing-xu",
            "url": "https://github.com/jianxing-xu"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyMDg4ODE1OA==",
          "body": "Http 缓存分为以下两种，两者都是通过 HTTP 响应头控制缓存\r\n\r\n1. 强制缓存\r\n1. 协商缓存\r\n\r\n## 强制缓存\r\n\r\n再次请求时无需再向服务器发送请求\r\n\r\n``` bash\r\n              client         server\r\nGET /a.ab389z.js ------->\r\n                      <------- 200 OK\r\n(再也不会发请求)\r\n```\r\n\r\n与之相关的 Response Headers 有以下几个\r\n\r\n+ `Expires`\r\n\r\n  这个头部也是丧心病狂：使用绝对时间，且有固定的格式 <https://tools.ietf.org/html/rfc822#section-5.1>\r\n\r\n  ``` bash\r\n  Expires: Mon, 25 Oct 2021 20:11:12 GMT\r\n  ```\r\n\r\n+ `Cache-Control`，具有强大的缓存控制能力\r\n\r\n  常用的有以下两个\r\n\r\n  + `no-cache`，每次请求需要校验服务器资源的新鲜度\r\n  + `max-age=31536000`，浏览器在一年内都不需要向服务器请求资源\r\n\r\n## 协商缓存\r\n\r\n再次请求时，需要向服务器校验新鲜度，如果资源是新鲜的，返回 304，从浏览器获取资源\r\n\r\n``` bash\r\n           client         server\r\nGET /a.js   ----------->\r\n                   <----------- 200 OK\r\nGET /a.js   ----------->\r\n                   <----------- 304 Not Modified\r\n```\r\n\r\n与之相关的 Request/Response Headers 有以下几个\r\n\r\n+ `Last-Modified`/`If-Modified-Since`\r\n+ `Etag`/`If-None-Match`",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc2MjcwMDIxMg==",
          "body": "今天在看这个问题的时候，发现一个关于强制缓存的意外情况。在刷新页面时，有的浏览器会重新验证缓存资源的新鲜度，有的不会。\r\n\r\n假设第一次请求资源的Response Heades包含下列强制缓存信息\r\n```\r\nDate: Tue, 19 Jan 2021 08:37:05 GMT\r\nExpires: Tue, 26 Jan 2021 08:37:05 GMT\r\n```\r\n\r\n在有效期内，按照强制缓存的概念解释，再次请求资源时，不会发送请求，直接返回200。\r\n但是在firefox中(使用版本：84.0.2)，Request Headers中包含`If-Modified-Since`头部，所以仍然会发送请求，返回304。\r\n在chrome中(使用版本：87.0.4280.141)，不会发送请求，会直接使用缓存的资源，返回200。\r\n\r\n在stackoverflow找到了一些关于这个问题的回答https://stackoverflow.com/questions/45829055/why-doesnt-chrome-re-validate-in-memory-cache-when-doing-a-normal-reload/57281076#57281076",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Harry3014",
            "url": "https://github.com/Harry3014"
          }
        },
        {
          "id": "IC_kwDODQzyOs51O24L",
          "body": "补充一张图和一个链接，\r\n![162db635ed5f6d26~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75](https://github.com/shfshanyue/Daily-Question/assets/53259809/18f43f9c-e85a-44ae-bf38-5382c66bbdf8)\r\n\r\nhttps://juejin.cn/post/6844903593275817998",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hututuQWQ",
            "url": "https://github.com/hututuQWQ"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ2Mzk=",
    "number": 81,
    "title": "【Q080】使用 webpack 打包时，如何更好地利用 long term cache",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjM2MjM1NQ==",
          "body": "查阅了很多前辈的资料，总结大致如下：（最后附上链接）\r\nlong term cache即“持久性缓存”\r\nUse [chunkhash] to add a content-dependent cache-buster to each file.\r\nUse compiler stats to get the file names when requiring resources in HTML.\r\nGenerate the chunk-manifest JSON and inline it into the HTML page before loading resources.\r\nEnsure that the entry point chunk containing the bootstrapping code doesn’t change its hash over time for the same set of dependencies.\r\n\r\n1.使用 [chunkhash] 为每个文件增加一个内容相关的缓存清道夫；\r\nSeparate development and production configs and use [name].js for development and [name].[chunkhash].js in production.\r\n\r\n2.使用编译统计在 HTML 中获取资源时取得文件名；[html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)\r\n\r\n3.生成 JSON 格式的模块清单文件，并在 HTML 页面加载资源之前内联进去；\r\nTo fix that, we should use [chunk-manifest-webpack-plugin](https://github.com/diurnalist/chunk-manifest-webpack-plugin) which will extract that manifest to a separate JSON file. \r\n\r\n4.保证包含启动代码的入口块不会对于同样的依赖生成不同的哈希值；（3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的——将公共库(vendor)和应用程序代码分离开来，并创建一个显式的vendor chunk以防止它频繁更改。而 webpack 4.x 则是把相关的功能包到了optimization.splitChunks中，直接使用该配置就可以实现代码分离。）\r\n\r\n[代码示例](https://github.com/okonet/webpack-long-term-cache-demo)版本：\"webpack\": \"^1.10.1\"\r\n资料来源：\r\n[webpack中文文档](https://www.webpackjs.com/guides/caching/)\r\n[Webpack Freestyle 之 Long Term Cache](https://zhuanlan.zhihu.com/p/27710902)\r\n[Long-term caching of static assets with Webpack](https://codeburst.io/long-term-caching-of-static-assets-with-webpack-1ecb139adb95#.9ro7cpngr)\r\n[用 webpack 实现持久化缓存](https://sebastianblade.com/using-webpack-to-achieve-long-term-cache/#webpack)\r\n[Webpack 的静态资源持久缓存](https://zcfy.cc/article/long-term-caching-of-static-assets-with-webpack-1204.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs46fIvg",
          "body": "@SageSanyue 目前更推荐使用 `contenthash`，而不是 `chunkhash`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs46fev4",
          "body": "# Long Term Cache\r\n\r\n使用 `webpack` 等打包器进行打包时，每个资源都可生成一个带有 hash 的路径。如\r\n\r\n+ `build/main.071b73.js`\r\n+ `build/main.94474e.css`\r\n+ `build/logo.18bac8.png`\r\n\r\n此处对添加 `hash` 的资源设置永久缓存，可大幅度提高该网站的缓存能力，从而大幅度提高网站的二次加载性能。\r\n\r\n通过在服务器端/网关端对资源设置以下 Response Header，进行强缓存一年时间，称为永久缓存，即 `Long Term Cache`。\r\n\r\n``` bash\r\nCache-Control: public,max-age=31536000,immutable\r\n```\r\n\r\n**而当源文件内容发生变更时，资源的 `hash` 发生变化，生成新的可永久缓存的资源地址。**\r\n\r\n因此在实践中，可对打包处理后带有 hash 资源的所有文件设置永久缓存。\r\n\r\n如果前端通过 docker/k8s/helm 进行部署，可由团队人员自行在构建 nginx 镜像时进行添加响应头字段。此处可作为前端性能优化的 kpi/okr。\r\n\r\n可在浏览器控制台 Network 中查看响应头来验证所属项目是否已成功添加永久缓存。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-29/clipboard-1625.748311.webp)\r\n\r\n## 一个问题与更强的永久缓存\r\n\r\n假设有两个文件: `index.js` 和 `lib.js`，且 index 依赖于 lib，其内容如下。\r\n\r\n**index.js**\r\n\r\n``` js\r\n// index.js\r\nimport('./lib').then(o => console.log(o))\r\n```\r\n\r\n**lib.js**\r\n\r\n``` js\r\nexport const a = 3\r\n```\r\n\r\n由 webpack 等打包器打包后将会生生两个 chunk (为了方便讲解，以下 aaaaaa 为 hash 值)\r\n\r\n+ `index.aaaaaa.js`\r\n+ `lib.aaaaaa.js`\r\n\r\n*问: 假设 lib.js 文件内容发生变更，index.js 由于引用了 lib.js，可能包含其文件名，那么它的 hash 是否会发生变动*\r\n\r\n答: 不一定。打包后的 `index.js` 中引用 lib 时并不会包含 `lib.aaaaaa.js`，而是采用 chunkId 的形式，如果 chunkId 是固定的话，则不会发生变更。\r\n\r\n``` js\r\n// 打包前\r\nimport('./lib')\r\n\r\n// 打包后，201 为固定的 chunkId (chunkIds = deterministic 时)\r\n__webpack_require__.e(/* import() | lib */ 201)\r\n```\r\n\r\n在 webpack 中，通过 `optimization.chunkIds` 可设置确定的 chunId，来增强 Long Term Cache 能力。\r\n\r\n``` bash\r\n{\r\n  optimization: {\r\n    chunkIds: 'deterministic'\r\n  }\r\n}\r\n```\r\n\r\n设置该选项且 `lib.js` 内容发生变更后，打包 chunk 如下，仅仅 `lib.js` 路径发生了变更。\r\n\r\n+ `index.aaaaaa.js`\r\n+ `lib.bbbbbb.js`",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ3OTk=",
    "number": 82,
    "title": "【Q081】http proxy 的原理是什么",
    "body": "如 `webpack-dev-server` 可以设置 proxy，`nginx` 也可以设置",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1NTQyMA==",
          "body": "todo",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs49QRsw",
          "body": "## HTTP代理的原理\r\n\r\n代理服务器会自动提取请求数据包中的`HTTP请求数据`发送给服务端，并服务端的`HTTP响应数据`转发给发送请求的客户端，HTTP代理服务器使用的端口通常是8080。\r\n\r\n-   对于Web客户端来说，代理扮演的服务器角色，接收请求（Request），返回响应（Response）。\r\n-   对于Web服务器来说，代理扮演的客户端角色，发送请求（Request），接收响应（Response）。\r\n\r\n### HTTP 代理步骤\r\n\r\n-   `客户端`向`代理`发起`TCP连接`；\r\n-   代理接收客户端的连接，双方`建立连接`；\r\n-   `客户端`向`代理`发送`HTTP请求`，请求内容和没有HTTP代理的内容完全相同；\r\n-   代理`解析HTTP请求`；\r\n-   `代理`向`服务器`发起`TCP连接`；\r\n-   `服务器`接收`代理`的连接；\r\n-   `代理`向`服务器`发送`HTTP`请求（这个HTTP请求是基于用户的HTTP请求，`可能会有修改`）\r\n-   `服务器`发送`响应`给`代理`；\r\n-   `代理`发送`响应`给发送请求的`客户端`；\r\n\r\n### 不同HTTP代理的区别：\r\n\r\n-   全匿名代理，不改变客户端的request fields（请求信息），使服务器端看来就像有个真正的客户浏览器在访问。客户端的真实IP是隐藏起来的。\r\n-   普通匿名代理，能隐藏客户端的真实IP，但会更改客户端的request fields（请求信息），服务器端有可能会被认为使用了代理。\r\n-   透明代理（简单代理），改变客户端的request fields（请求信息），并会传送真实IP地址。\r\n\r\n## HTTPS代理\r\n\r\nHTTPS代理有多种做法，通常使用`CONNECT method`，通过proxy建立一条隧道(隧道代理)，这样，`proxy无法解密数据`；此外，还有一种类似于中间人攻击的代理手法。\r\n\r\n### CONNECT方法代理步骤\r\n\r\n-   `客户端`向`代理`发起`CONNECT`请求；\r\n-   `代理`向`服务端`发起`TCP`连接请求；\r\n-  当TCP连接建立完成后， `代理`向`客户端`返回`HTTP/1.0 OK`，隧道建立完成；\r\n-   `代理`转发`客户端`的数据给`服务器`，转发`服务器`的数据给`客户端`，直到任何一方连接结束；\r\n\r\n> 内容参考[HTTP、HTTPS代理分析及原理](https://lilywei739.github.io/2017/01/25/principle_for_http_https.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Merlin218",
            "url": "https://github.com/Merlin218"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ5NzM=",
    "number": 83,
    "title": "【Q082】随着 http2 的发展，webpack 有没有更好的打包方案",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUyMDk=",
    "number": 84,
    "title": "【Q083】网站性能优化都有哪些点",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTU0MTQ4NQ==",
          "body": "减少http请求次数：\r\nCSS Sprites, JS、CSS源码压缩、图片大小适当控制；\r\n网页Gzip，CDN托管，data缓存 ，图片服务器。\r\n尽量减少内联样式\r\n将脚本放在底部 \r\n少用全局变量、缓存DOM节点查找的结果\r\n图片预加载\r\n按需加载",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wjw-gavin",
            "url": "https://github.com/wjw-gavin"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyMzI5NDA4NQ==",
          "body": "可参考 Google 的文档 <https://developers.google.com/web/fundamentals/performance/get-started>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs43Hs2z",
          "body": "https://developers.google.com/web/fundamentals/performance/get-started\r\n\r\n根据谷歌Web开发者网站总结的性能优化点:\r\n- 资源加载优化\r\n  - 衡量性能指标\r\n    - Lab Data, 在规范的特定条件下，对Web应用的各项指标进行评估，典型工具如谷歌的 lighthouse\r\n    - RUM，基于真实用户的性能指标监控，包括FCP，FID，CLS等，参考 https://web.dev/user-centric-performance-metrics/\r\n    - 瀑布图，借助 performance API 记录整个站点和各个资源的加载时长\r\n  - 优化资源大小(字节数)\r\n    - 评估各资源的用途并评估是否可以直接移除\r\n    - 通过压缩技术(minimize和compress)减少文本类资源(CSS,JavaScript,HTML)大小\r\n    - 选择合适的图片格式、裁剪图片、懒加载图片等，通过picture标签响应式地返回图片，参考 https://www.jianshu.com/p/607567e488fc\r\n    - 预加载和长期缓存字体，参考 https://web.dev/optimize-webfont-loading/\r\n  - 减少HTTP请求次数\r\n    - 合并文本资源，比如使用webpack这样的bundle技术\r\n    - 合并图片资源，比如雪碧图\r\n    - 内联内容较小的资源到html中，比如data url\r\n  - 善用HTTP缓存\r\n    - 本地缓存命中顺序，内存缓存 => Service Worker 缓存 => HTTP缓存(磁盘缓存) => HTTP/2 Push缓存，参考 https://calendar.perfplanet.com/2016/a-tale-of-four-caches/\r\n    - https://web.dev/http-cache/\r\n  - 优化JavaScript\r\n    - JavaScript的处理过程：下载(fetch) => 解压 => 解析(代码转换为AST) => 编译(AST转换为字节码) => 执行\r\n    - 死代码消除(Tree Shaking)，减小总体传输文件大小\r\n    - Code Spliting + 基于路由的按需加载，减小首次渲染的传输文件大小\r\n  - 优化首次渲染路径\r\n    - 渲染路径: DOM树构建 => CSSOM树构建 => Render Tree构建 => 样式计算 => 布局 => 绘制位图 => 合成图层\r\n    - 通过媒体查询避免首次渲染时加载不必要的CSS文件\r\n    - 将对页面结构无影响的JS文件标记为 async 和 defer，避免阻塞html解析\r\n- 渲染优化\r\n  - 使用 requestAnimationFrame 代替 setTimeout 和 setInterval 来更新视图，减少卡顿\r\n  - 将计算密集型的JavaScript代码移动到 Web Worker 中执行，避免占用主线程\r\n  - 使用复杂度更低、class风格的CSS选择器；减少频繁变动的CSS样式的影响元素个数\r\n  - 使用性能更高的 flex 布局代替 float 布局\r\n  - 避免对 offsetHeight 等dom属性的频繁访问，导致重绘和重排操作队列的频繁同步执行\r\n  - 在 performance profiling 之后，将频繁变动的动画部分所属的dom元素标记为 will-change，独立构成一个图层",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUzODQ=",
    "number": 85,
    "title": "【Q084】随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NjA4MA==",
          "body": "1. 雪碧图\r\n1. 资源文件合并",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODg3NTkyMw==",
          "body": "我有一个不成熟的小想法：iconfont是不是可以取代雪碧图？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "oldDirver001",
            "url": "https://github.com/oldDirver001"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk3MjI3OA==",
          "body": "域名发散\r\n资源内联",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kruzabc",
            "url": "https://github.com/kruzabc"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk4NTE0MQ==",
          "body": "@oldDirver001 可以，不过不能完全替代，比如多色",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU0NzI=",
    "number": 86,
    "title": "【Q085】http2 与 http1.1 有什么改进",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODkxNTczOQ==",
          "body": "1. 二进制分帧\r\n1. 请求多路复用 (Stream/Frame)\r\n1. 头部压缩: (HPack)\r\n1. 服务端推送: (PUSH_PROMISE)\r\n\r\n可参考文章 [http2 详解](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU2Nzk=",
    "number": 87,
    "title": "【Q086】Tree Shaking 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk1MjkwNA==",
          "body": "应该是基于es6 modules的静态分析",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coderyyx",
            "url": "https://github.com/coderyyx"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDM5MA==",
          "body": "AST",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "IC_kwDODQzyOs43_KtL",
          "body": "`Tree Shaking` 指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。\r\n\r\n有例为证:\r\n\r\n> 以下示例可在 [Rollup Repl](https://rollupjs.org/repl/?version=2.58.0&shareable=JTdCJTIybW9kdWxlcyUyMiUzQSU1QiU3QiUyMm5hbWUlMjIlM0ElMjJtYWluLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMiUyRiolMjBUUkVFLVNIQUtJTkclMjAqJTJGJTVDbmltcG9ydCUyMCU3QiUyMGN1YmUlMjAlN0QlMjBmcm9tJTIwJy4lMkZtYXRocy5qcyclM0IlNUNuJTVDbmNvbnNvbGUubG9nKCUyMGN1YmUoJTIwNSUyMCklMjApJTNCJTIwJTJGJTJGJTIwMTI1JTIyJTJDJTIyaXNFbnRyeSUyMiUzQXRydWUlN0QlMkMlN0IlMjJuYW1lJTIyJTNBJTIybWF0aHMuanMlMjIlMkMlMjJjb2RlJTIyJTNBJTIyJTJGJTJGJTIwbWF0aHMuanMlNUNuJTVDbiUyRiUyRiUyMFRoaXMlMjBmdW5jdGlvbiUyMGlzbid0JTIwdXNlZCUyMGFueXdoZXJlJTJDJTIwc28lNUNuJTJGJTJGJTIwUm9sbHVwJTIwZXhjbHVkZXMlMjBpdCUyMGZyb20lMjB0aGUlMjBidW5kbGUuLi4lNUNuZXhwb3J0JTIwZnVuY3Rpb24lMjBzcXVhcmUlMjAoJTIweCUyMCklMjAlN0IlNUNuJTVDdHJldHVybiUyMHglMjAqJTIweCUzQiU1Q24lN0QlNUNuJTVDbiUyRiUyRiUyMFRoaXMlMjBmdW5jdGlvbiUyMGdldHMlMjBpbmNsdWRlZCU1Q25leHBvcnQlMjBmdW5jdGlvbiUyMGN1YmUlMjAoJTIweCUyMCklMjAlN0IlNUNuJTVDdCUyRiUyRiUyMHJld3JpdGUlMjB0aGlzJTIwYXMlMjAlNjBzcXVhcmUoJTIweCUyMCklMjAqJTIweCU2MCU1Q24lNUN0JTJGJTJGJTIwYW5kJTIwc2VlJTIwd2hhdCUyMGhhcHBlbnMhJTVDbiU1Q3RyZXR1cm4lMjB4JTIwKiUyMHglMjAqJTIweCUzQiU1Q24lN0QlMjIlMkMlMjJpc0VudHJ5JTIyJTNBZmFsc2UlN0QlNUQlMkMlMjJvcHRpb25zJTIyJTNBJTdCJTIyZm9ybWF0JTIyJTNBJTIyZXMlMjIlMkMlMjJuYW1lJTIyJTNBJTIybXlCdW5kbGUlMjIlMkMlMjJhbWQlMjIlM0ElN0IlMjJpZCUyMiUzQSUyMiUyMiU3RCUyQyUyMmdsb2JhbHMlMjIlM0ElN0IlN0QlN0QlMkMlMjJleGFtcGxlJTIyJTNBJTIyMDIlMjIlN0Q=) 中进行在线演示\r\n\r\n``` js\r\n/* TREE-SHAKING */\r\nimport { sum } from './maths.js'\r\n\r\nconsole.log( sum( 5, 5 ) )  // 10\r\n```\r\n\r\n``` js\r\n// maths.js\r\n\r\nexport function sum ( x, y ) {\r\n  return x + y\r\n}\r\n\r\n// 由于 sub 函数没有引用到，最终将不会对它进行打包\r\nexport function sub ( x, y ) {\r\n  return x - y\r\n}\r\n```\r\n\r\n最终打包过程中，`sub` 没有被引用到，将不会对它进行打包。以下为打包后代码。\r\n\r\n``` js\r\n// maths.js\r\n\r\nfunction sum ( x, y ) {\r\n  return x + y\r\n}\r\n\r\n/* TREE-SHAKING */\r\n\r\nconsole.log( sum( 5, 5 ) )\r\n```\r\n\r\n## `import *`\r\n\r\n当使用语法 `import *` 时，Tree Shaking 依然生效。\r\n\r\n``` js\r\nimport * as maths from './maths'\r\n\r\n// Tree Shaking 依然生效\r\nmaths.sum(3, 4)\r\nmaths['sum'](3, 4)\r\n```\r\n\r\n`import * as maths`，其中 `maths` 的数据结构是固定的，无复杂数据，通过 AST 分析可查知其引用关系。\r\n\r\n``` js\r\nconst maths = {\r\n  sum () {},\r\n  sub () {}\r\n}\r\n```\r\n\r\n## JSON TreeShaking\r\n\r\n`Tree Shaking` 甚至可对 JSON 进行优化。原理是因为 JSON 格式简单，通过 AST 容易预测结果，不像 JS 对象有复杂的类型与副作用。\r\n\r\n``` json\r\n{\r\n  \"a\": 3,\r\n  \"b\": 4\r\n}\r\n```\r\n\r\n``` js\r\nimport obj from './main.json'\r\n\r\n// obj.b 由于未使用到，仍旧不会被打包\r\nconsole.log(obj.a)\r\n```\r\n\r\n## 引入支持 Tree Shaking 的 Package\r\n\r\n为了减小生产环境体积，我们可以**使用一些支持 ES 的 package，比如使用 `lodash-es` 替代 `lodash`**。\r\n\r\n我们可以在 [npm.devtool.tech](https://npm.devtool.tech/lodash-es) 中查看某个库是否支持 Tree Shaking。\r\n\r\n![lodash-es](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/lodash-es.60xosee62440.png)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjYxMTc=",
    "number": 88,
    "title": "【Q087】什么是 CNAME 记录和 A 记录",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NTgwNg==",
          "body": "CNAME：域名  -> 域名\r\nA：域名 -> IP",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY0Nzk=",
    "number": 89,
    "title": "【Q088】如何实现 promise.map，限制 promise 并发数",
    "body": "实现一个 promise.map，进行并发数控制，有以下测试用例\r\n\r\n``` js\r\npMap([1, 2, 3, 4, 5], x => Promise.resolve(x + 1))\r\n\r\npMap([Promise.resolve(1), Promise.resolve(2)], x => x + 1)\r\n\r\n// 注意输出时间控制\r\npMap([1, 1, 1, 1, 1, 1, 1, 1], x => sleep(1000), { concurrency: 2 })\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwMzUzMDU2Mw==",
          "body": "没人回答",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "dmwin72015",
            "url": "https://github.com/dmwin72015"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hU2T",
          "body": "以下代码见 [如何实现 promise.map - codepen](https://codepen.io/shanyue/pen/zYwZXPN?editors=0012)\r\n\r\n``` js\r\nfunction pMap(list, mapper, concurrency = Infinity) {\r\n  // list 为 Iterator，先转化为 Array\r\n  list = Array.from(list)\r\n  return new Promise((resolve, reject) => {\r\n    let currentIndex = 0\r\n    let result = []\r\n    let resolveCount = 0\r\n    let len = list.length\r\n    function next() {\r\n      const index = currentIndex\r\n      currentIndex++\r\n      Promise.resolve(list[index]).then(o => mapper(o, index)).then(o => {\r\n        result[index] = o\r\n        resolveCount++\r\n        if (resolveCount === len) { resolve(result) }\r\n        if (currentIndex < len) { next() }\r\n      })\r\n    }\r\n    for (let i = 0; i < concurrency && i < len; i ++) {\r\n      next()\r\n    }\r\n  })\r\n}\r\n```",
          "star": {
            "totalCount": 7
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hlhd",
          "body": "```javascript\r\nPromise.map = function (queue = [], opt = { }) {\r\n    let limit = opt.limit || 5\r\n    let queueIndex = 0\r\n    let completeCount = 0\r\n    let _resolve\r\n    let result = Array(queue.length)\r\n\r\n    for (let i = 0; i < limit; i++) {\r\n        next(queueIndex++)\r\n    }\r\n\r\n    function next (index) {\r\n        if (queue.length === 0) return\r\n        let curr = queue.shift()\r\n        if (typeof curr === 'function') {\r\n            curr = curr()\r\n        }\r\n        Promise.resolve(curr).then((res) => {\r\n            result[index] = res\r\n        }, (res) => {\r\n            result[index] = res\r\n        }).finally(() => {\r\n            completeCount += 1\r\n            if (completeCount === result.length) {\r\n                return _resolve(result)\r\n            }\r\n            next(queueIndex++)\r\n        })\r\n    }\r\n    return new Promise((resolve) => {\r\n        _resolve = resolve\r\n    })\r\n}\r\n\r\nfunction add (a, b) {\r\n    return Promise.resolve(a + b)\r\n}\r\n\r\nfunction sum (arr) {\r\n    if (arr.length <= 2) {\r\n        return add(arr[0] || 0, arr[1] || 0)\r\n    }\r\n    let mid = arr.length / 2 | 0\r\n    let promiseArr = []\r\n    for (let i = 0; i < mid; i++) {\r\n        promiseArr.push(add(arr[i], arr[mid + i]))\r\n    }\r\n    return Promise.map(promiseArr).then(res => {\r\n        if (arr.length % 2 !== 0) {\r\n            res.push(arr.pop())\r\n        }\r\n        return sum(res)\r\n    })\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs43hDxe",
          "body": "```javascript\r\nfunction pMap(list, mapper, cur) {\r\n  cur = cur || list.length;\r\n  let step = Promise.resolve();\r\n  do {\r\n    let temp = list.splice(0, cur);\r\n    step = step.then(() =>\r\n      Promise.all(\r\n        temp.map((i, index) => Promise.resolve(i).then((e) => mapper(e, index)))\r\n      )\r\n    );\r\n  } while (list.length);\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yazhouio",
            "url": "https://github.com/yazhouio"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DMVZd",
          "body": "```ts\r\nfunction pMap([...arr], fn, { concurrency = Infinity } = {}) {\r\n  let queue = [],\r\n    results = [];\r\n  return new Promise((resolve) =>\r\n    (function closure() {\r\n      const times = concurrency - queue.length;\r\n      for (let i = 0; i < times; i++) {\r\n        if (!arr.length) return;\r\n        const promise = Promise.resolve(arr.shift())\r\n          .then(fn)\r\n          .then((data) => results.push(data))\r\n          .finally(() => {\r\n            queue = queue.filter((item) => promise !== item);\r\n            if (!queue.length && !arr.length) return resolve(results);\r\n            return closure();\r\n          });\r\n        queue.push(promise);\r\n      }\r\n    })()\r\n  );\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FoTIa",
          "body": "```javascript\r\nfunction parallelMap(arr, fn, concurrency = Number.MAX_SAFE_INTEGER) {\r\n\treturn new Promise((resolve) => {\r\n\t\tlet ret = [];\r\n\t\tlet index = -1;\r\n\t\tfunction next() {\r\n\t\t\t++index;\r\n\t\t\tPromise.resolve(arr[index]).then(val => fn(val, index)).then(res => {\r\n\t\t\t\tret.push(res);\r\n\t\t\t\tif (ret.length === arr.length) {\r\n\t\t\t\t\tresolve(ret);\r\n\t\t\t\t} else if (index < arr.length) {\r\n\t\t\t\t\tnext();\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < arr.length && i < concurrency; i++) {\r\n\t\t\tnext();\r\n\t\t}\r\n\t});\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yxw007",
            "url": "https://github.com/yxw007"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VndA6",
          "body": "```js\r\nfunction pMap(argsArr, fn, config) {\r\n    let queue = [];\r\n\r\n    const next = () => {\r\n        if (queue.length > 0) {\r\n            queue.shift().then(_task => _task());\r\n        }\r\n    };\r\n\r\n    const run = async (fn, resolve, args) => {\r\n        const result = await (async () => fn(...args))()\r\n        resolve(result)\r\n        try {\r\n            result\r\n        } catch (e) { }\r\n        next()\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const concurrency = (config || {}).concurrency;\r\n        if (!concurrency) {\r\n            Promise.all(\r\n                argsArr.map((item) =>\r\n                    item instanceof Promise ? item.then(fn) : fn(item)\r\n                )\r\n            ).then(resolve).catch(reject);\r\n        } else {\r\n            queue = argsArr.map(async (item) => run.bind(null, fn, resolve, [item instanceof Promise ? (await item) : item]));\r\n            for (let i = 0; i < concurrency; i++) {\r\n                queue[i].then(_task => _task())\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kirazZ1",
            "url": "https://github.com/kirazZ1"
          }
        },
        {
          "id": "IC_kwDODQzyOs5XV7rF",
          "body": "```ts\r\ntype pMapType<T = any> = (\r\n  argsArr: any[],\r\n  fn: (...args: any) => Promise<T>,\r\n  concurrency?: number\r\n) => Promise<T>;\r\n\r\nconst pMap: pMapType = (argsArr, fn, concurrency = Infinity) => {\r\n  return new Promise((resolve, reject) => {\r\n    const result = new Array(argsArr.length).fill(0);\r\n\r\n    const taskQueue: any[] = [];\r\n\r\n    let currentWorkingAmount = 0;\r\n\r\n    function run() {\r\n      while (currentWorkingAmount < concurrency) {\r\n        const nextTask = taskQueue.shift();\r\n        if(nextTask) {\r\n          nextTask()\r\n          currentWorkingAmount++\r\n        }\r\n        if(taskQueue.length === 0) break\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < argsArr.length; i++) {\r\n      taskQueue.push(() => {\r\n        Promise.resolve(fn(argsArr[i]))\r\n          .then((res) => {\r\n            result[i] = res;\r\n            currentWorkingAmount--;\r\n            if(taskQueue.length === 0 && currentWorkingAmount === 0) return resolve(result)\r\n            if (currentWorkingAmount < concurrency) run();\r\n          })\r\n          .catch(reject);\r\n      });\r\n    }\r\n\r\n    run();\r\n  });\r\n};\r\n\r\nfunction asyncFun(value: any, delay: number) {\r\n  return new Promise((resolve) => {\r\n      console.log(\"start \" + value);\r\n      setTimeout(() => resolve(value), delay);\r\n  });\r\n}\r\n\r\npMap([1, 2, 3, 4, 5, 6, 7, 8], (x) => asyncFun(`task${x}`, 2000), 4).then(res => {\r\n  console.log(\"res\",res)\r\n});\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kirazZ1",
            "url": "https://github.com/kirazZ1"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY4NTc=",
    "number": 90,
    "title": "【Q089】vue 中 v-if 和 v-show 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MTkzNDA3NQ==",
          "body": "> v-show always compiles and renders everything - it simply adds the \"display: none\" style to the element. It has a higher initial load cost, but toggling is very cheap.\r\n> Incomparison, v-if is truely conditional: it is lazy, so if its initial condition is false, it won't even do anything. This can be good for initial load time. When the condition is true, v-if will then compile and render its content. Toggling a v-if block actually tearsdown everything inside it, e.g. Components inside v-if are acually destroyed and re-created when toggled, so toggling a huge v-if block can be more expensive than v-show.\r\n\r\nv-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 `display: none;` 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。\r\n相比之下，v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于v-if下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大v-if块儿时会比v-show消耗的性能多。",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "zhaofeihao",
            "url": "https://github.com/zhaofeihao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcwNTE=",
    "number": 91,
    "title": "【Q090】vue 中 computed 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzA1MDQzMw==",
          "body": "要讲清楚，computed原理，首先得讲vue响应式原理，因为computed的实现是基于Watcher对象的。\r\n那么vue的响应式原理是什么呢，众所周知，vue是基于Object.defineProperty实现监听的。在vue初始化数据data和computed数据过程中。会涉及到以下几个对象：\r\n1. Observe对象\r\n2. Dep对象\r\n3. Watch对象\r\nObserve对象是在data执行响应式时候调用，因为computed属性基于响应式属性，所以其不需要创建Observe对象。\r\nDep对象主要功能是做依赖收集，有个属性维护多个Watch对象，当更新时候循环调用每个Watch执行更新。\r\nWatch对象主要是用于更新，而且是收集的重点对象。\r\n\r\n这里谈到computed计算属性，首先要知道，其有两种定义方式，一种是方法，另一种是get，set属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如data的属性vuex的属性。\r\n\r\nvue在创建computed属性时候，会循环所有计算属性，每一个计算属性会创建一个watch，并且在通过defineProperty定义监听，在get中，计算属性工作是做依赖收集，在set中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为computed是懒执行，也就是说第一次初始化之后，变不会执行计算，下一次变更执行重新计算是在set中。\r\n\r\n另一个补充点是依赖收集的时机，computed收集时机和data一样，是在组件挂载前，但是其收集对象是自己属性对应的watch，而data本身所有数据对应一个watch。\r\n\r\n以下附计算属性源码验证说法：\r\n\r\n```typescript\r\n\r\nfunction initComputed (vm: Component, computed: Object) {\r\n  // $flow-disable-line\r\n  const watchers = vm._computedWatchers = Object.create(null)\r\n  // computed properties are just getters during SSR\r\n  const isSSR = isServerRendering()\r\n\r\n  for (const key in computed) {\r\n    const userDef = computed[key]\r\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\r\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\r\n      warn(\r\n        `Getter is missing for computed property \"${key}\".`,\r\n        vm\r\n      )\r\n    }\r\n\r\n    if (!isSSR) {\r\n      // create internal watcher for the computed property.\r\n      watchers[key] = new Watcher(\r\n        vm,\r\n        getter || noop,\r\n        noop,\r\n        computedWatcherOptions\r\n      )\r\n    }\r\n\r\n    // component-defined computed properties are already defined on the\r\n    // component prototype. We only need to define computed properties defined\r\n    // at instantiation here.\r\n    if (!(key in vm)) {\r\n      defineComputed(vm, key, userDef)\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      if (key in vm.$data) {\r\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\r\n      } else if (vm.$options.props && key in vm.$options.props) {\r\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n可以看到，在执行new Watcher之前，会对计算属性做判断，判断其是否为函数，如果不是则取getter。这是因为计算属性有两种定义方式。之后第二步是执行deineCoumputed。这一步只是简单的调用defineProterty我就不贴代码了。\r\n\r\n关于计算属性的getter和setter定义如下：\r\n重点关注get的懒加载部分，和Watcher的定义\r\n```typescript\r\nfunction createComputedGetter (key) {\r\n  return function computedGetter () {\r\n    const watcher = this._computedWatchers && this._computedWatchers[key]\r\n    if (watcher) {\r\n      if (watcher.dirty) {\r\n        watcher.evaluate()\r\n      }\r\n      if (Dep.target) {\r\n        watcher.depend()\r\n      }\r\n      return watcher.value\r\n    }\r\n  }\r\n}\r\n\r\nfunction createGetterInvoker(fn) {\r\n  return function computedGetter () {\r\n    return fn.call(this, this)\r\n  }\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "wython",
            "url": "https://github.com/wython"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CxJwl",
          "body": "Vue3中Computed计算原理和Vue2中使用Watch的搜集方式不太一样了。在Vue3中，如果我们创建了一个computed方法，则会创建一个ComputedRefImpl的对象，在这个对象中进行get和set的处理。如果是读取，就会判断是否是有缓存值以及是否存在不同的数据，如果存在则进行数据的读取（这里对值不变但是频繁读取的情况进行了优化）。判断值已经变化则进行effect的run操作进行取数。设置对应值的话则会进行一个报错提示。\r\n\r\n源码如下：\r\n\r\n```javascript \r\n\r\nimport { DebuggerOptions, ReactiveEffect } from './effect'\r\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { isFunction, NOOP } from '@vue/shared'\r\nimport { ReactiveFlags, toRaw } from './reactive'\r\nimport { Dep } from './dep'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (...args: any[]) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean\r\n\r\n  public _dirty = true\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean\r\n  ) {\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      if (!this._dirty) {\r\n        this._dirty = true\r\n        triggerRefValue(this)\r\n      }\r\n    })\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    trackRefValue(self)\r\n    if (self._dirty || !self._cacheable) {\r\n      self._dirty = false\r\n      self._value = self.effect.run()!\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n}\r\n\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "MMmaXingXing",
            "url": "https://github.com/MMmaXingXing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcxNzg=",
    "number": 92,
    "title": "【Q091】vue-loader 的实现原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs43Kirf",
          "body": "vue-loader会把sfc中的内容拆分为template，script，style三个“虚拟模块”，然后分别匹配webpack配置中对应的rules，比如script模块会匹配所有跟处理JavaScript或TypeScript相关的loader。\r\n\r\ntemplate中的内容会通过 vue compiler 转换为 render函数后合并到 script “虚拟模块”中。\r\n\r\nscoped style 会经过vue-loader/style-post-loader的处理，成为只匹配特定元素的私有样式。\r\n\r\n参考 [vue-loader README](https://github.com/vuejs/vue-loader/blob/master/README.md)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        },
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzE4MTgyMzA=",
    "number": 93,
    "title": "【Q092】react 中 ref 是干什么用的，有哪些使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDM4ODY5MQ==",
          "body": "**取得深层次的dom的结构。进行操作；我用过的主要是对表格滚动条的操作**",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "senbochen",
            "url": "https://github.com/senbochen"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDM2NQ==",
          "body": "操作原生JS的桥梁",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI1NzgxMzc=",
    "number": 94,
    "title": "【Q093】如何实现一个 LRU",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3NDA0OTQ5Nw==",
          "body": "leetcode149\r\n1. 用双向链表+哈希。\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n    this.cache = new DoubleList();\r\n};\r\nclass Node {\r\n    constructor(k, val) {\r\n        this.k = k;\r\n        this.val = val;\r\n        this.pre = null;\r\n        this.next = null;\r\n    }\r\n}\r\nclass DoubleList {\r\n    constructor() {\r\n        this.size = 0;\r\n        this.head = new Node(0, 0);\r\n        this.tail = new Node(0, 0);\r\n        this.head.next = this.tail;\r\n        this.tail.pre = this.head;\r\n    }\r\n    addLast(x) {\r\n        const { head, tail } = this;\r\n        x.pre = tail.pre;\r\n        x.next = tail;\r\n        tail.pre.next = x;\r\n        tail.pre = x;\r\n        this.size++;\r\n    }\r\n    remove(x) {\r\n        x.pre.next = x.next;\r\n        x.next.pre = x.pre;\r\n        this.size--;\r\n    }\r\n    removeFirst() {\r\n        const { head, tail } = this;\r\n        if (head.next === tail) return null;\r\n        let first = head.next;\r\n        this.remove(first);\r\n        return first;\r\n    }\r\n}\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    const { cache, map } = this;\r\n    if (map.has(key)) {\r\n        let x = map.get(key);\r\n        cache.remove(x);\r\n        cache.addLast(x);\r\n        return map.get(key).val;\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    const { cache, map,size } = this;\r\n    const addRecently = function(key,value){\r\n        let x = new Node(key,value);\r\n        cache.addLast(x);\r\n        map.set(key,x);\r\n    }\r\n    if (map.has(key)) {\r\n        let x = map.get(key);\r\n        cache.remove(x);\r\n        map.delete(key);\r\n        addRecently(key,value);\r\n    }else{\r\n        if(cache.size=== this.capacity){\r\n            let x = cache.removeFirst();\r\n            map.delete(x.k);\r\n        }\r\n        addRecently(key,value);\r\n    }\r\n};\r\n```\r\n2. Map的巧妙使用\r\nmap放入数据是按顺序的，最新放入的数据在迭代器最后\r\n而且map的entries方法，还有keys方法，会返回一个迭代器，迭代器调用next也是顺序返回，所以返回第一个的值就是最老的，找到并删除即可\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    const map = this.map;\r\n    let val = map.get(key);\r\n    if (val !== undefined) {\r\n        map.delete(key);\r\n        map.set(key, val);\r\n        return val;\r\n    } else {\r\n        return -1;\r\n    }\r\n\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    const { map, capacity } = this\r\n    if (map.has(key)) map.delete(key);\r\n    map.set(key, value);\r\n    if (map.size > capacity) {\r\n        map.delete(map.entries().next().value[0])\r\n    }\r\n};\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manyyuri",
            "url": "https://github.com/manyyuri"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI2MzUxNDc=",
    "number": 95,
    "title": "【Q094】你们的前端代码上线部署一次需要多长时间，需要人为干预吗",
    "body": "更短的部署时间，更少的人为干预，更有利于敏捷开发",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NDkyMA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzkyNjMxMA==",
          "body": "Jenkins+docker",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rex-ll",
            "url": "https://github.com/rex-ll"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c127",
          "body": "需要1个小时，需要",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "IC_kwDODQzyOs459uxb",
          "body": "@Carrie999 一个小时！！！？这也太久了吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5fY6fR",
          "body": "5min，2minCI，3minCD",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhenghuilin",
            "url": "https://github.com/zhenghuilin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyMTI2OTc=",
    "number": 96,
    "title": "【Q095】k8s 中的 QoS 有哪几种类型",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjAzNzYzNw==",
          "body": "参考官方文档：[Configure Quality of Service for Pods\r\n](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/)，总结如下\r\n\r\n有三种类型 `Guaranteed`，`Burstable` 与 `BestEffort `\r\n\r\n+ `Guaranteed`\r\n    + Pod 里的每个容器都必须有内存 `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n    + Pod 里的每个容器都必须有 CPU `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n+ `Burstable`\r\n    + Pod 里至少有一个容器有内存或者 CPU `resources.requests`\r\n+ `BestEffort`\r\n    + 不设置 `resources.requests` 和 `resources.limits`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjAxNzg=",
    "number": 97,
    "title": "【Q096】cron 表达式 (* 10 * * *) 会如何触发",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTA3Mg==",
          "body": "每天十点，每分钟都会执行一次",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjIyOTE=",
    "number": 98,
    "title": "【Q097】cron 表达式 (30 10 * * *) 会如何触发",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTIxMw==",
          "body": "每天十点半执行一次",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyOTUyMzQ=",
    "number": 99,
    "title": "【Q098】在 linux 中如何查看 cron 执行的情况",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTk0NA==",
          "body": "在 `centos` 中，查看日志文件\r\n\r\n``` bash\r\n$ tail -f /var/log/cron\r\nDec  5 19:30:01 8 CROND[24068]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24084]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24083]: (root) CMD (echo hello)\r\nDec  5 19:32:01 8 CROND[24094]: (root) CMD (echo hello, world)\r\nDec  5 19:32:01 8 CROND[24093]: (root) CMD (echo hello)\r\nDec  5 19:33:01 8 CROND[24104]: (root) CMD (echo hello, world)\r\nDec  5 19:33:01 8 CROND[24103]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24113]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24114]: (root) CMD (echo hello, world)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0MDI4NzA=",
    "number": 100,
    "title": "【Q099】git 如何查看某个文件的提交历史",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjE2ODM3OA==",
          "body": "``` bash\r\ngit log -p file\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODg3NDgzMQ==",
          "body": "git log -p  filename",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "viyoung",
            "url": "https://github.com/viyoung"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
          "name": "git"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0NDIzMzk=",
    "number": 101,
    "title": "【Q100】如何使用 react/vue 实现一个 message API",
    "body": "可以实现如下 API\r\n\r\n`message.info()`\r\n`message.success()`",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQwMzE1MQ==",
          "body": "```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n// info组件\r\nimport Info from 'info';\r\n// success组件\r\nimport Success from 'success';\r\n\r\nfunction createMessage(message, Com) {\r\n\r\n  let el = document.createElement('div');\r\n\r\n  document.body.appendChild(el);\r\n\r\n  const component = React.createElement(Com, {\r\n    message\r\n  });\r\n\r\n  ReactDOM.render(component, el);\r\n}\r\n\r\nconst message = {\r\n  info(message) {\r\n    return createMessage(message, Info);\r\n  },\r\n  success(message) {\r\n    return createMessage(message, Success);\r\n  },\r\n};\r\n\r\nexport default message;\r\n```\r\n主要实现思路就是创建一个div到body下，然后利用ReactDOM.render将组件渲染到这个容器下，这只是一个简单的实现，没实现关闭和多次调用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "allan-hx",
            "url": "https://github.com/allan-hx"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5ODA1MjQ2OQ==",
          "body": "Vue 实现也是差不多，可以先写好一个 render 函数，作用是把某一HTML片段挂载到 #root 下 / 从 #root 删除该片段。然后写一个 Vue 插件，就是一个暴露了包含 install 方法的模块，install 方法中将 设置 Vue.prototype.$message = message 对象。最后使用 Vue.use 全局注册这个插件即可。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wizzeng",
            "url": "https://github.com/wizzeng"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5NDk1OTkyMg==",
          "body": "```\r\n// alert.js \r\nimport Alert from './alert.vue'\r\nimport Vue from 'vue'\r\n// 创建构造器\r\nconst InstanceAlert = Vue.extend(Alert)\r\n\r\nexport default class Message {\r\n  deaultOptions = {\r\n    el: document.createElement('div')\r\n    propsData: {\r\n      title: '标题'\r\n    }\r\n  }\r\n  instance = {}\r\n  constructor (options) {\r\n    options = Object.assign({},options,this.deaultOptions)\r\n    this.instance = new InstanceAlert(options)\r\n  }\r\n  show() {\r\n    document.body.appendChild(this.instance.$el)\r\n\r\n  }\r\n  hide() {\r\n    document.body.removeChild(this.instance.$el)\r\n  }\r\n}\r\n```\r\n\r\n```\r\n// alert.vue\r\n<template>\r\n  <div id=\"alert-mount\">\r\n    这里是{{ title }}\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    props:{\r\n      title:{\r\n        type:String,\r\n        default:\"\"\r\n      }\r\n    }\r\n  }\r\n</script>\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HuiFeiYa",
            "url": "https://github.com/HuiFeiYa"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-oCTz",
          "body": "用createPortal会好点，符合createPortal的使用场景并且如果message复杂点createElement就用不了",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Drowned-fish",
            "url": "https://github.com/Drowned-fish"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM3NTE1MTA=",
    "number": 102,
    "title": "【Q101】你们后端代码上线部署一次需要多长时间",
    "body": "关键在于考虑开发人员对项目部署流程的了解",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1ODE1Ng==",
          "body": "30分钟左右",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fmleing",
            "url": "https://github.com/fmleing"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDEwMDA3OA==",
          "body": "> 30分钟左右\r\n\r\n那你们部署的流程是什么呢？我觉得半个小时有点多呀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDc1OTg1Ng==",
          "body": "> > 30分钟左右\r\n> \r\n> 那你们部署的流程是什么呢？我觉得半小时有点多呀\r\n\r\n估计和OS有关，放在测试环境上的是Linux比较快，正式环境是window就比较慢，使用的是jekins+tomcat容器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fmleing",
            "url": "https://github.com/fmleing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM4MzM1Mzk=",
    "number": 103,
    "title": "【Q102】有没有用 npm 发布过 package，如何发布",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyOTM4NzI3MA==",
          "body": "## 步骤\r\n\r\n1. 注册 npm 账号 https://www.npmjs.com/\r\n2. 本地通过命令行 `npm login` 登陆\r\n3. 进入到项目目录下（与 package.json 同级），在 package.json 中指定发布文件、文件夹\r\n```json\r\n{\r\n  \"name\": \"pkg-xxx\",\r\n  \"version\": \"0.0.1\",\r\n  \"main\": \"lib/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"files\": [\r\n    \"CHANGELOG.md\",\r\n    \"lib\",\r\n    \"esm\",\r\n    \"dist\",\r\n    \"types\",\r\n  ],\r\n  ...\r\n}\r\n```\r\n执行 `npm publish --registry=https://registry.npmjs.org/` 即可发布\r\n\r\n## 其他\r\n\r\n还可以配合 [GitHub Packages](https://docs.github.com/en/free-pro-team@latest/packages/using-github-packages-with-your-projects-ecosystem/configuring-npm-for-use-with-github-packages) 发布",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangkailang",
            "url": "https://github.com/wangkailang"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c1Qu",
          "body": "我还会发布vscode主题呢，https://marketplace.visualstudio.com/items?itemName=carrie999.cyberpunk-2020 ，看下载量8k呢",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ3NDA=",
    "number": 104,
    "title": "【Q103】你在工作中遇到最有挑战的事情是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1NzQ5NQ==",
          "body": "一个人3天负责完成本来评估1周工作量的需求变更，在刚接手项目进行维护的前提下，不熟悉需要更改的业务代码实现。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fmleing",
            "url": "https://github.com/fmleing"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c00C",
          "body": "没有",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c0_6",
          "body": "我觉得都挺简单的，实现页面，对接接口，完美，但是有的时候用户会反馈问题就很烦，有的时候首屏家在速度慢就很烦，动效啥的也简单的，配置都是配置好了，容错机制，监控报错加上，就很棒了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ5MTk=",
    "number": 105,
    "title": "【Q104】你在工作中遇到最受挫折的事情是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45c1Ji",
          "body": "就是钱少干的多委屈",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5OTgwODg=",
    "number": 106,
    "title": "【Q105】你为什么从上家公司离职",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45c1F_",
          "body": "俺觉得主要是钱多，去哪里其实都差不多",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDA5NTk=",
    "number": 107,
    "title": "【Q106】什么是IO多路复用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMTQzNg==",
          "body": "假设你的服务器要同时处理 100 个 `socket` 连接\r\n\r\n1. 开一个线程，挨个处理。这就没法处理并发了\r\n1. 开100个线程，分别处理。这么多的线程在内核态频频进进出出也很消耗性能\r\n1. 开一个线程，去检查 `socket` 是否就绪，如果就绪则再开一个线程去处理。这就是IO多路复用了\r\n\r\n`select`、`poll`、`epoll` 是三中典型的IO多路复用的系统调用，但实际上现在 `epoll` 使用的最多。当你使用 `strace` 查看 `nodejs` 某个服务的系统调用时，将会发现 `nodejs` 就是使用了 `epoll`\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDQ5MjIwMA==",
          "body": "不会开新的线程去处理，轮训所有注册的socket，就绪就去处理",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangxiaokun",
            "url": "https://github.com/zhangxiaokun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDg0MzU=",
    "number": 108,
    "title": "【Q107】什么是 Basic Auth 和 Digest Auth",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sgFn5",
          "body": "Basic Auth：使用Base64编码的用户名和密码，将其放置在HTTP请求头中进行身份验证；\r\nDigest Auth：使用摘要（Digest）算法，将密码使用算法加密后放在HTTP请求头中进行身份验证；\r\n这两种身份验证在实际应用中比较少，比较流行的还是Token-based Auth。\r\nToken-based Auth：使用令牌（Token），客户端在登录成功后获取令牌，之后的请求中将令牌包含在请求头中进行身份验证。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MTY5MDI=",
    "number": 109,
    "title": "【Q108】gzip 的原理是什么，如何配置",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwNjgyNg==",
          "body": "一句话：`gzip` 的核心是 `Deflate`，而它使用了 `LZ77` 算法与 `Huffman` 编码来压缩文件，重复度越高的文件可压缩的空间就越大。\r\n\r\n因此 `gzip` 用于 HTTP 文件传输中，比如 JS、CSS 等，**但一般不会压缩图片**。在 HTTP Response 报文中，用 `Content-Encoding` 指明使用 gzip 压缩，而以下响应头在大部分生产环境的响应报文中都可以看到！比如你现在立刻马上可以打开[我的网站](https://q.shanyue.tech)或者[百度](https://www.baidu.com)试一试。\r\n\r\n``` bash\r\n# Request Header\r\nAccept-Encoding: gzip, deflate, br\r\n\r\n# Reponse Header\r\nContent-Encoding: gzip\r\n```\r\n\r\n`gzip` 一般在反向代理那一层，如 `nginx` 进行处理，直接使用 C 语言编写，具有更好的性能。\r\n\r\n在 `nginx` 开启 `gzip`: 配置可参考 [gzip module](http://nginx.org/en/docs/http/ngx_http_gzip_module.html)\r\n\r\n``` nginx\r\ngzip on;\r\n```\r\n\r\n## LZ77\r\n\r\n## Huffman\r\n\r\n## 相关阅读\r\n\r\n+ [gzip原理与实现](https://blog.csdn.net/imquestion/article/details/16439)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0NzcxNzA=",
    "number": 110,
    "title": "【Q109】可以对图片开启 gzip 压缩吗，为什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMzYyMw==",
          "body": "不需要开启，如果开启的话，有可能使图片变的更大。如果你注意一些网站的 img 资源时，就会发现他们都没有开启 `gzip`\r\n\r\n参考: https://webmasters.stackexchange.com/questions/8382/is-gzipping-images-worth-it-for-a-small-size-reduction-but-overhead-compressing\r\n\r\n> **Don't use gzip for image or other binary files.**\r\n>\r\n> Image file formats supported by the web, as well as videos, PDFs and other binary formats, are already compressed; using gzip on them won't provide any additional benefit, and can actually make them larger. To compress images, see Optimize images.",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NTc0OTg=",
    "number": 111,
    "title": "【Q110】http 的请求报文与响应报文的格式是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzYzNzUzMA==",
          "body": "以 `nc` 模拟 http 报文如下\r\n\r\n``` bash\r\n$ nc www.baidu.com 80\r\nGET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\nHTTP/1.1 200 OK\r\nAccept-Ranges: bytes\r\nCache-Control: no-cache\r\nConnection: Keep-Alive\r\nContent-Length: 14615\r\nContent-Type: text/html\r\nDate: Tue, 10 Dec 2019 02:48:44 GMT\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nPragma: no-cache\r\nServer: BWS/1.1\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA285F51A1F2F8A170BB:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BIDUPSID=F0FC6B3A056DEA285F51A1F2F8A170BB; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: PSTM=1575946124; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA287CB2B9422E09E30E:FG=1; max-age=31536000; expires=Wed, 09-Dec-20 02:48:44 GMT; domain=.baidu.com; path=/; version=1; comment=bd\r\nTraceid: 1575946124058431156210725656341129791126\r\nVary: Accept-Encoding\r\nX-Ua-Compatible: IE=Edge,chrome=1\r\n\r\n<!DOCTYPE html><!--STATUS OK-->\r\n........内容省略\r\n```\r\n\r\nGET 请求报文如下：\r\n\r\n![](https://static.shanyue.tech/images/23-09-15/clipboard-9447.78475f.webp)\r\n\r\nPOST 请求报文如下：\r\n\r\n![](https://static.shanyue.tech/images/23-09-15/clipboard-6319.cd1372.webp)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NzEwNzM=",
    "number": 112,
    "title": "【Q111】http 响应头中的 ETag 值是如何生成的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzg5NDAzNA==",
          "body": "关于 `etag` 的生成需要满足几个条件，至少是宽松满足\r\n\r\n1. 当文件更改时，`etag` 值必须改变。\r\n1. **尽量**便于计算，不会特别耗 CPU。这样子利用摘要算法生成 (MD5, SHA128, SHA256) 需要慎重考虑，因为他们是 CPU 密集型运算\r\n1. **必须**横向扩展，分布式部署时多个服务器节点上生成的 `etag` 值保持一致。这样子 `inode` 就排除了\r\n\r\n> 关于服务器中 `etag` 如何生成可以参考 [HTTP: Generating ETag Header](https://stackoverflow.com/questions/4533/http-generating-etag-header)\r\n\r\n以上几个条件是理论上的成立条件，那在真正实践中，应该如何处理？\r\n\r\n我们来看一下 `nginx` 中是如何做的\r\n\r\n## nginx 中 ETag 的生成\r\n\r\n我翻阅了 `nginx` 的源代码，并翻译成伪代码如下：由 last_modified 与 content_length 拼接而成\r\n\r\n``` js\r\netag = header.last_modified + header.content_lenth\r\n```\r\n\r\n可见源码位置，并在以下贴出: [ngx_http_core_modules.c](https://github.com/nginx/nginx/blob/6c3838f9ed45f5c2aa6a971a0da3cb6ffe45b61e/src/http/ngx_http_core_module.c#L1582)\r\n\r\n``` c\r\netag->value.len = ngx_sprintf(etag->value.data, \"\\\"%xT-%xO\\\"\",\r\n                                  r->headers_out.last_modified_time,\r\n                                  r->headers_out.content_length_n)\r\n                      - etag->value.data;\r\n```\r\n\r\n**总结：`nginx` 中 `etag` 由响应头的 `Last-Modified` 与 `Content-Length` 表示为十六进制组合而成。**\r\n\r\n随手在我的k8s集群里找个 `nginx` 服务测试一下\r\n\r\n``` bash\r\n$ curl --head 10.97.109.49\r\nHTTP/1.1 200 OK\r\nServer: nginx/1.16.0\r\nDate: Tue, 10 Dec 2019 06:45:24 GMT\r\nContent-Type: text/html\r\nContent-Length: 612\r\nLast-Modified: Tue, 23 Apr 2019 10:18:21 GMT\r\nConnection: keep-alive\r\nETag: \"5cbee66d-264\"\r\nAccept-Ranges: bytes\r\n```\r\n\r\n由 `etag` 计算 `Last-Modified` 与 `Content-Length`，使用 `js` 计算如下，结果相符\r\n\r\n``` js\r\n> new Date(parseInt('5cbee66d', 16) * 1000).toJSON()\r\n\"2019-04-23T10:18:21.000Z\"\r\n> parseInt('264', 16)\r\n612\r\n```\r\n\r\n## Nginx 中的 ETag 算法及其不足\r\n\r\n协商缓存用来计算资源是否返回 304，我们知道协商缓存有两种方式\r\n\r\n+ `Last-Modified`/`if-Modified-Since`\r\n+ `ETag`/`If-None-Match`\r\n\r\n既然在 `nginx` 中 `ETag` 由 `Last-Modified` 和 `Content-Length` 组成，那它便算是一个加强版的 `Last-Modified` 了，那加强在什么地方呢？\r\n\r\n**`Last-Modified` 是由一个 `unix timestamp` 表示，则意味着它只能作用于秒级的改变，而 nginx 中的 ETag 添加了文件大小的附加条件**\r\n\r\n那下一个问题：[如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)\r\n\r\n答案：不能。\r\n\r\n**因此使用 nginx 计算 304 有一定局限性：在 1s 内修改了文件并且保持文件大小不变。但这种情况出现的概率极低就是了，因此在正常情况下可以容忍一个不太完美但是高效的算法。**\r\n\r\n## 相关问题\r\n\r\n+ [如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NzkzMTY3Nw==",
          "body": "Last-Modified 变了，但是Content-Length没变（文件内容不变），是否意味着etag的缓存失效",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jacintoface",
            "url": "https://github.com/jacintoface"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3Nzk1MzU2OQ==",
          "body": "@jacintoface 也可以这么理解",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1Njc3NTk=",
    "number": 113,
    "title": "【Q112】如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzkyNTM2Ng==",
          "body": "不一定，由服务器中 `ETag` 的生成算法决定。详见 [#112](https://github.com/shfshanyue/Daily-Question/issues/112)\r\n\r\n比如 `nginx` 中的 `etag` 由 `last_modified` 与 `content_length` 组成，而 `last_modified` 又由 `mtime` 组成\r\n\r\n当编辑文件却未更改文件内容时，或者 `touch file`，`mtime` 也会改变，此时 `etag` 改变，但是文件内容没有更改。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Njk2NDg5NA==",
          "body": "比如 nginx 中的 etag 由 last_modified 与 content_length 组成，而 last_modified 又由 mtime 组成。\r\n\r\n\r\n那Etag是怎么解决last_modified，当编辑文件却未更改文件时间的问题？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "collins999",
            "url": "https://github.com/collins999"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNjI2NzE4MA==",
          "body": "> 比如 nginx 中的 etag 由 last_modified 与 content_length 组成，而 last_modified 又由 mtime 组成。\r\n> \r\n> 那Etag是怎么解决last_modified，当编辑文件却未更改文件时间的问题？\r\n\r\n1. 此时文件大小有可能发生更改，ETag 会改变\r\n1. 此时文件大小没有发生更改，ETag 不会改变。但这需要极其苛刻的条件：1s 内更改文件，并且保持文件大小不变。这种情况出现概率很低，因此忽略了",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1ODU2ODY=",
    "number": 114,
    "title": "【Q113】如何看待 toB 与 toC",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs47iswb",
          "body": "从职业方向取舍的角度看，我认为纠结这两个点没必要，toB 的业务可能很简单，toC 的业务也可能很复杂，两个端的壁垒也没有那么大。\r\n\r\n从传统观点上看：\r\ntoB：业务复杂，表单和定制化需求较多，需要给出一整套解决方案，但对体验和交互要求没有那么重要\r\ntoC：偏向用户体验的内容稍多，移动端的内容稍多。对性能的要求略高，每个产品的功能不复杂，业务开始只需要满足用户的一个痛点\r\n\r\n但随着前端能力的增加，很多工具类软件都可以由前端承载，代码的复杂度也随之上升，前端从传统的辅助地位逐渐走向了客户端工程师的地位，内容也逐渐变得更有挑战性。\r\n\r\n但如果从公司的角度看，toB 的公司一般面向政府、企事业单位，以供应商的身份提供技术咨询、定制化开发、业务支持等服务，回款周期较长，如果外部环境不好，资金流不畅，很容易拖欠工资。\r\n但是，节奏没有那么快，一切都有较长的排期，相对更规范一些。\r\n\r\ntoC 的公司，一般都自负盈亏，现金流相对会快一些。但是现在的互联网企业都搞什么敏捷开发，基本上一周或者两周就一个版本，面向市场需要小步快跑\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1OTAyOTc=",
    "number": 115,
    "title": "【Q114】如何查看一个文件的 inode number",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk3ODc1Nw==",
          "body": "可以使用 `ls` 或者 `stat`\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n\r\n$ ls -i hello.txt\r\n917526 hello.txt\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NTA0MDI=",
    "number": 116,
    "title": "【Q115】文件系统中 mtime、ctime 和 atime 指什么，都有什么不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk4MzQ3Nw==",
          "body": "在 `linux` 中，\r\n\r\n+ `mtime`：`modified time` 指文件内容改变的时间戳\r\n+ `ctime`：`change time` 指文件属性改变的时间戳，属性包括 `mtime`。而在 windows 上，它表示的是 `creation time`\r\n\r\n所以 `ctime` 会比 `mtime` 要大一些，使用 `stat` 查看文件属性如下\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n Birth: -\r\n```\r\n\r\n而 http 服务选择 `Last_Modified` 时一般会选择 `mtime`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NzAxMjE=",
    "number": 117,
    "title": "【Q116】http 服务中静态文件的 Last-Modified 是根据什么生成的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk5NzU5OA==",
          "body": "一般会选文件的 `mtime`，表示文件内容的修改时间\r\n\r\n`nginx` 也是这样处理的，源码见: [ngx_http_static_module.c](https://github.com/nginx/nginx/blob/4bf4650f2f10f7bbacfe7a33da744f18951d416d/src/http/modules/ngx_http_static_module.c#L217)\r\n\r\n``` c\r\n    r->headers_out.status = NGX_HTTP_OK;\r\n    r->headers_out.content_length_n = of.size;\r\n    r->headers_out.last_modified_time = of.mtime;\r\n```\r\n\r\n关于为什么使用 `mtime` 而非 `ctime`，可以参考 [#116](https://github.com/shfshanyue/Daily-Question/issues/117)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OXdap",
          "body": "针对静态资源而言，一般会选择文件的 mtime 元属性作为上次修改时间，该元属性表示文件内容的修改时间，在linux中可以用stat命令来查看文件属性，其中就包括了mtime和ctime。mtime指的是文件内容修改时间，而ctime指的是文件修改时间",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "feefeefee",
            "url": "https://github.com/feefeefee"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2ODYxNjY=",
    "number": 118,
    "title": "【Q117】既然 http 是无状态协议，那它是如何保持登录状态",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDAwMzA2Nw==",
          "body": "通过 cookie 或者 Authorization header 来传递凭证，在服务端进行认证",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODY0ODM=",
    "number": 119,
    "title": "【Q118】有没有读过 koa 的源码，什么是洋葱模型呢",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwMDAzMjkzMw==",
          "body": "# 四十行代码实现一个 koa\r\n\r\n当我们在深入学习一个框架或者库时，为了了解它的思想及设计思路，也为了更好地使用和避免无意的 Bug，有时很有必要研究源码。对于 koa 这种极为简单，而应用却很广泛的框架/库更应该了解它的源码。\r\n\r\n而为了验证我们是否已足够了解它，可以实现一个仅仅具备核心功能的迷你的库。正所谓，麻雀虽小，五脏俱全。\r\n\r\n`删繁就简三秋树`，这里只用四十行代码实现一个小型的却具有其核心功能的 koa。\r\n\r\n> **源码实现：<https://github.com/shfshanyue/koa-mini>**\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/blog@latest/node/assets/koa.jpg)\r\n\r\n这是一个拥有 koa 几乎所有核心功能最简化的示例：\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 1 Start')\r\n  await next()\r\n  console.log('Middleware 1 End')\r\n})\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 2 Start')\r\n  await next()\r\n  console.log('Middleware 2 End')\r\n\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\napp.listen(3000)\r\n\r\n// output\r\n// Middleware 1 Start\r\n// Middleware 2 Start\r\n// Middleware 2 End\r\n// Middleware 1 End\r\n```\r\n\r\n在这个最简化的示例中，可以看到有三个清晰的模块，分别如下：\r\n\r\n+ Application: 基本服务器框架\r\n+ Context: 服务器框架基本数据结构的封装，用以 http 请求解析及响应\r\n+ Middleware: 中间件，也是洋葱模型的核心机制\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/blog@latest/node/assets/koa-module.jpg)\r\n\r\n我们开始逐步实现这三个模块：\r\n\r\n## 抛开框架，来写一个简单的 server\r\n\r\n我们先基于 node 最基本的 `http API` 来启动一个 http 服务，并通过它来实现最简版的 koa：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nconst server = http.createServer((req, res) => {\r\n  res.end('hello, world')\r\n})\r\n\r\nserver.listen(3000)\r\n```\r\n\r\n而要实现最简版的 `koa` 示例如下，我把最简版的这个 koa 命名为 `koa-mini`\r\n\r\n``` js\r\nconst Koa = require('koa-mini')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 1 Start')\r\n  await next()\r\n  console.log('Middleware 1 End')\r\n})\r\n\r\napp.use(async (ctx, next) => {\r\n  console.log('Middleware 2 Start')\r\n  await next()\r\n  console.log('Middleware 2 End')\r\n\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n## 构建 Application\r\n\r\n首先完成 `Appliacation` 的大体框架：\r\n\r\n+ `app.listen`: 处理请求及响应，并且监听端口\r\n+ `app.use`: 中间件函数，处理请求并完成响应\r\n\r\n只有简单的十几行代码，示例如下：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nclass Application {\r\n  constructor () {\r\n    this.middleware = null \r\n  }\r\n\r\n  listen (...args) {\r\n    const server = http.createServer(this.middleware)\r\n    server.listen(...args)\r\n  }\r\n\r\n  // 这里依旧调用的是原生 http.createServer 的回调函数\r\n  use (middleware) {\r\n    this.middleware = middleware\r\n  }\r\n}\r\n```\r\n\r\n此时调用 `Application` 启动服务的代码如下:\r\n\r\n``` js\r\nconst app = new Appliacation()\r\n\r\napp.use((req, res) => {\r\n  res.end('hello, world')\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n由于 `app.use` 的回调函数依然是原生的 `http.crateServer` 回调函数，而在 `koa` 中回调参数是一个 `Context` 对象。\r\n\r\n下一步要做的将是构建 `Context` 对象。\r\n\r\n## 构建 Context\r\n\r\n在 koa 中，`app.use` 的回调参数为一个 `ctx` 对象，而非原生的 `req/res`。因此在这一步要构建一个 `Context` 对象，并使用 `ctx.body` 构建响应：\r\n\r\n+ `app.use(ctx => ctx.body = 'hello, world')`: 通过在 `http.createServer` 回调函数中进一步封装 `Context` 实现\r\n+ `Context(req, res)`: 以 `request/response` 数据结构为主体构造 Context 对象\r\n\r\n核心代码如下，注意注释部分：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nclass Application {\r\n  constructor () {}\r\n  use () {}\r\n\r\n  listen (...args) {\r\n    const server = http.createServer((req, res) => {\r\n      // 构造 Context 对象\r\n      const ctx = new Context(req, res)\r\n\r\n      // 此时处理为与 koa 兼容 Context 的 app.use 函数\r\n      this.middleware(ctx)\r\n\r\n      // ctx.body 为响应内容\r\n      ctx.res.end(ctx.body)\r\n    })\r\n    server.listen(...args)\r\n  }\r\n}\r\n\r\n// 构造一个 Context 的类\r\nclass Context {\r\n  constructor (req, res) {\r\n    this.req = req\r\n    this.res = res\r\n  }\r\n}\r\n```\r\n\r\n此时 `koa` 被改造如下，`app.use` 可以正常工作：\r\n\r\n``` js\r\nconst app = new Application()\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\napp.listen(7000)\r\n```\r\n\r\n实现以上的代码都很简单，现在就剩下一个最重要也是最核心的功能：洋葱模型\r\n\r\n## 洋葱模型及中间件改造\r\n\r\n上述工作只有简单的一个中间件，然而在现实中中间件会有很多个，如错误处理，权限校验，路由，日志，限流等等。因此我们要改造下 `app.middlewares`\r\n\r\n+ `app.middlewares`: 收集中间件回调函数数组，并并使用 `compose` 串联起来\r\n\r\n对所有中间件函数通过 `compose` 函数来达到抽象效果，它将对 `Context` 对象作为参数，来接收请求及处理响应：\r\n\r\n``` js\r\n// this.middlewares 代表所有中间件\r\n// 通过 compose 抽象\r\nconst fn = compose(this.middlewares)\r\nawait fn(ctx)\r\n\r\n// 当然，也可以写成这种形式，只要带上 ctx 参数\r\nawait compose(this.middlewares, ctx)\r\n```\r\n\r\n此时完整代码如下：\r\n\r\n``` js\r\nconst http = require('http')\r\n\r\nclass Application {\r\n  constructor () {\r\n    this.middlewares = []\r\n  }\r\n\r\n  listen (...args) {\r\n    const server = http.createServer(async (req, res) => {\r\n      const ctx = new Context(req, res)\r\n\r\n      // 对中间件回调函数串联，形成洋葱模型\r\n      const fn = compose(this.middlewares)\r\n      await fn(ctx)\r\n\r\n      ctx.res.end(ctx.body)\r\n    })\r\n    server.listen(...args)\r\n  }\r\n\r\n  use (middleware) {\r\n    // 中间件回调函数变为了数组\r\n    this.middlewares.push(middleware)\r\n  }\r\n}\r\n```\r\n\r\n接下来，着重完成 `compose` 函数\r\n\r\n### 完成 compose 函数的封装\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/blog@latest/node/assets/yangcong.png)\r\n\r\nkoa 的洋葱模型指出每一个中间件都像是洋葱的每一层，当从洋葱中心穿过时，每层都会一进一出穿过两次，且最先穿入的一层最后穿出。\r\n\r\n+ `middleware`: 第一个中间件将会执行\r\n+ `next`: 每个中间件将会通过 next 来执行下一个中间件\r\n\r\n我们如何实现所有的中间件的洋葱模型呢?\r\n\r\n我们看一看每一个 middleware 的 API 如下\r\n\r\n``` js\r\nmiddleware(ctx, next)\r\n```\r\n\r\n而每个中间件中的 `next` 是指执行下一个中间件，我们来把 `next` 函数提取出来，而 `next` 函数中又有 `next`，这应该怎么处理呢？\r\n\r\n``` js\r\nconst next = () => nextMiddleware(ctx, next)\r\nmiddleware(ctx, next(0))\r\n```\r\n\r\n是了，使用一个递归完成中间件的改造，并把中间件给连接起来，如下所示:\r\n\r\n``` js\r\n// dispatch(i) 代表执行第 i 个中间件\r\n\r\nconst dispatch = (i) => {\r\n  return middlewares[i](ctx, () => dispatch(i+1))\r\n}\r\ndispatch(0)\r\n```\r\n\r\n`dispatch(i)` 代表执行第 i 个中间件，而 `next()` 函数将会执行下一个中间件 `dispatch(i+1)`，于是我们使用递归轻松地完成了洋葱模型\r\n\r\n此时，再把递归的终止条件补充上: 当最后一个中间件函数执行 `next()` 时，直接返回\r\n\r\n``` js\r\nconst dispatch = (i) => {\r\n  const middleware = middlewares[i]\r\n  if (i === middlewares.length) {\r\n    return\r\n  }\r\n  return middleware(ctx, () => dispatch(i+1))\r\n}\r\nreturn dispatch(0)\r\n```\r\n\r\n最终的 `compose` 函数代码如下:\r\n\r\n``` js\r\nfunction compose (middlewares) {\r\n  return ctx => {\r\n    const dispatch = (i) => {\r\n      const middleware = middlewares[i]\r\n      if (i === middlewares.length) {\r\n        return\r\n      }\r\n      return middleware(ctx, () => dispatch(i+1))\r\n    }\r\n    return dispatch(0)\r\n  }\r\n}\r\n```\r\n\r\n至此，koa 的核心功能洋葱模型已经完成，写个示例来体验一下吧:\r\n\r\n``` js\r\nconst app = new Application()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, one'\r\n  await next()\r\n})\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, two'\r\n  await next()\r\n})\r\n\r\napp.listen(7000)\r\n```\r\n\r\n此时还有一个小小的但不影响全局的不足：异常处理，下一步将会完成异常捕获的代码\r\n\r\n## 异常处理\r\n\r\n如果在你的后端服务中因为某一处报错，而把整个服务给挂掉了怎么办？\r\n\r\n我们只需要对中间件执行函数进行一次异常处理即可：\r\n\r\n``` js\r\ntry {\r\n  const fn = compose(this.middlewares)\r\n  await fn(ctx)\r\n} catch (e) {\r\n  console.error(e)\r\n  ctx.res.statusCode = 500\r\n  ctx.res.write('Internel Server Error')\r\n}\r\n```\r\n\r\n然而在日常项目中使用时，我们**必须**在框架层的异常捕捉之前就需要捕捉到它，来做一些异常结构化及异常上报的任务，此时会使用一个异常处理的中间件：\r\n\r\n``` js\r\n// 错误处理中间件\r\napp.use(async (ctx, next) => {\r\n  try {\r\n    await next();\r\n  }\r\n  catch (err) {\r\n    // 1. 异常结构化\r\n    // 2. 异常分类\r\n    // 3. 异常级别\r\n    // 4. 异常上报\r\n  }\r\n})\r\n```\r\n\r\n## 小结\r\n\r\n`koa` 的核心代码特别简单，如果你是一个 Node 工程师，非常建议在业务之余研究一下 koa 的源码，并且自己也实现一个最简版的 koa。\r\n\r\n我源码实现的仓库为：[koa-mini](https://github.com/shfshanyue/koa-mini)",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c1_X",
          "body": "我读过，大概是用promise 来实现，一个这个promise 一直在等下一个promise 所以就像洋葱模型了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODcwMDU=",
    "number": 120,
    "title": "【Q119】https 是如何保证报文安全的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODM4MDY4MA==",
          "body": "https主要解决三个安全问题：\r\n1. 内容隐私\r\n2. 防篡改\r\n3. 确认对方身份\r\n\r\nhttps并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。\r\n证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "wython",
            "url": "https://github.com/wython"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTAyNTc=",
    "number": 121,
    "title": "【Q120】TCP 是如何保证可靠性的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDY3Nw==",
          "body": "ACK",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c2IK",
          "body": "现在UDP也挺可靠的还快",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_QQOC",
          "body": "@Carrie999 大佬细说",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "changshou83",
            "url": "https://github.com/changshou83"
          }
        },
        {
          "id": "IC_kwDODQzyOs5J_90Z",
          "body": "TCP协议",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liaotao123",
            "url": "https://github.com/liaotao123"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ahSKS",
          "body": "TCP（传输控制协议）是一种面向连接的、可靠的传输协议。TCP 通过以下几种机制来保证数据传输的可靠性：\r\n\r\n应答机制：当发送方发送数据时，接收方会发送一个应答确认已经收到数据。如果发送方在超时时间内未收到应答，就会重新发送数据，直到接收方发送应答确认为止。\r\n\r\n序列号和确认号：TCP 将每个数据包都分配一个序列号，接收方收到数据包后会向发送方发送一个确认号，确认当前已收到的数据包的序列号。发送方可以根据确认号知道哪些数据包已经被接收方成功接收，哪些数据包需要重新发送。\r\n\r\n滑动窗口：TCP 使用滑动窗口机制来控制发送方发送数据的速度。滑动窗口的大小取决于接收方的可用缓冲区大小和网络延迟等因素。发送方只能发送窗口内的数据，接收方只确认窗口内的数据。如果发送方收到接收方的窗口更新通知，则可以增加窗口大小，以便发送更多的数据。\r\n\r\n超时重传：如果发送方在超时时间内未收到接收方的确认应答，就会认为数据包已经丢失，并重新发送数据包。超时时间通常根据网络延迟和拥塞程度等因素来计算，以确保重传时机的合理性。\r\n\r\n拥塞控制：TCP 通过拥塞控制算法来防止网络拥塞。如果网络出现拥塞，TCP 会减少发送速率，以避免进一步加重网络负载。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Azure089",
            "url": "https://github.com/Azure089"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTk4MDM=",
    "number": 122,
    "title": "【Q121】我们如何从 http 的报文中得知该服务使用的技术栈",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDEwMTEwMw==",
          "body": "一般有两个 response header，有时服务端为了隐蔽自己真实的技术栈会隐蔽这两个字段\r\n\r\n+ `X-Powerd-By`\r\n+ `Server`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzYxODgyMjQ=",
    "number": 123,
    "title": "【Q122】在发送 http 请求报文时，Host 是必要的吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDgwODY1NA==",
          "body": "是有必要的，因为我们不知道会途径会不会有代理出现， 如果直接到达服务器的话，服务器是可以通过路径知道资源在哪，但是如果通过代理的话，代理无法得知具体服务器是什么地址",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Gloomysunday28",
            "url": "https://github.com/Gloomysunday28"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY3MzY1NTI=",
    "number": 124,
    "title": "【Q123】如何监控文件的变动",
    "body": "当一个文件或者一个目录下的文件有所变动时能够监控到。\r\n\r\n如一些前端和后端项目在开发环境下会根据项目目录变动而重启或者重新编译",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDYwMQ==",
          "body": "1. 在 node 中调用 API `fs.watch`\r\n1. 在 linux 中原理是 `inotify`，macos 中原理是 `FSEvents`，windows 中原理是 ` ReadDirectoryChangesW`\r\n1. 由于内核对文件监控更加细粒度，更加敏感，当每次修改文件时可能触发内核多次调用，需要防抖\r\n1. 注意软链接，读写权限等文件系统属性\r\n\r\n可参考文章 [How to Watch for Files Changes in Node.js](https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/) 及 [精读《如何利用 Nodejs 监听文件夹》](https://github.com/dt-fe/weekly/blob/v2/059.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Nodejs%20%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%8B.md)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTAzMzA5NA==",
          "body": "我不太清楚问这个的目的，是 fs.watch 吧？若要问的深一点底层怎么做的监听，我就不会了。贴一下答案？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "everlose",
            "url": "https://github.com/everlose"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTA1NDQzOQ==",
          "body": "@everlose 简单的总结了以下，见楼上",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5PM7yD",
          "body": "chokidar这个包更好吧，我记得理论上它避免了fs.watch的一些坑，而且webpack底层用的也是这个，在mac和windows的兼容性应该都还行",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yinzhixiaxue",
            "url": "https://github.com/yinzhixiaxue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MDc0NDQ=",
    "number": 125,
    "title": "【Q124】如何保证内网服务的安全性",
    "body": "如 `gitlab CE` 经常暴露出重大漏洞，而它也只需要在公司内部使用。部署 `gitlab` 时我们如何保证它的安全性",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDk2MTA5Nw==",
          "body": "basic auth，digest auth，ip whitelist，vpn",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5sgHsW",
          "body": "内网服务由于只允许局域网访问，所以首先我们要先进行严格的端口限制，确保其服务绑定的端口不允许外部请求，不绑定外网IP防止外部攻击，其次内部服务的请求采用RPC方式可减少被外部直接调用的风险，这些是隔绝外部访问的措施，接下来则要防止因为漏洞或木马而产生的从内部发出的攻击，首先要检查内网服务的代码，看是否存在可能远程触发，注入等漏洞，再者对内部的调用都要鉴权并且监控敏感操作及时报警，最后就是运维层面对服务器的监控，对于可疑流量波动和请求及时发现报警。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MzU3MzA=",
    "number": 126,
    "title": "【Q125】docker 中如何为每个容器的 cpu/memory 设限，原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sgJbp",
          "body": "在运行容器时，可以使用--cpus参数来设置CPU的限制，以及使用-m或--memory参数来设置内存的限制，docker是通过Linux内核的cgroups来实现对cpu和内存等资源等分配的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc0MTgzNzQ=",
    "number": 127,
    "title": "【Q126】localhost:3000 与 localhost:5000 的 cookie 信息是否共享",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1Mjk1Mg==",
          "body": "共享",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1NDgxNg==",
          "body": "根据同源策略，cookie是区分端口的，但是浏览器实现来说，“cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangwen9229",
            "url": "https://github.com/zhangwen9229"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTYxNjg0NA==",
          "body": "貌似 不考虑domian 设置 path 默认为/的话 \r\n\r\nhttps://xxxx.com 和http://xxxx.com 协议不同其他相同的 cookie 也是共享的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fariellany",
            "url": "https://github.com/fariellany"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMDA4NDM3OA==",
          "body": "默认domain为localhost path为/ 存储的cookie没有端口信息\r\n共享",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hao0906",
            "url": "https://github.com/hao0906"
          }
        },
        {
          "id": "IC_kwDODQzyOs5AM5F0",
          "body": "@[fariellany](https://github.com/fariellany)\r\n`Set-Cookie: id=a3fWa; Expires=Thu, 21 Oct 2021 07:28:00 GMT; Secure; HttpOnly`\r\n补充一点,不同协议http和https，也可以共享\r\n但是带有Secure属性的不能被http共享\r\n带有HttpOnly属性的cookie无法被document.cookie访问",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Telanx",
            "url": "https://github.com/Telanx"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc1NDM2MzA=",
    "number": 128,
    "title": "【Q127】vpn 的原理是什么",
    "body": "当在公司工作时经常需要 vpn 用以连接公司内网，其原理是什么",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODMzMjQ2NQ==",
          "body": "正向代理",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xinlanlan",
            "url": "https://github.com/xinlanlan"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ahSXS",
          "body": "加密：VPN使用加密技术对数据进行加密，以确保数据在传输过程中是安全的。VPN使用的加密算法通常是对称加密和公钥加密的组合。\r\n隧道：VPN通过隧道技术，在公共网络上创建一个加密通道，将远程用户或分支机构的数据流量转发到私有网络中。隧道技术可以确保数据在公共网络上传输时是安全的，并且只有经过身份验证的用户才能访问私有网络。\r\n认证：VPN使用认证技术来验证用户的身份。这通常包括用户名和密码、数字证书或其他身份验证证书。\r\n授权：VPN使用授权技术来限制用户对私有网络资源的访问。这可以通过访问控制列表、安全策略和其他技术来实现。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Azure089",
            "url": "https://github.com/Azure089"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc4ODYyMzI=",
    "number": 129,
    "title": "【Q128】构建镜像时，那几个指令会增加镜像层数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTY5Njk1Nw==",
          "body": "`RUN`，`ADD`，`COPY`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc5MDczNTY=",
    "number": 130,
    "title": "【Q129】shell 中 ${} 与 $() 各是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTcxMjkwOQ==",
          "body": "+ `${}` 变量\r\n+ `$()` 命令",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjc4MDU=",
    "number": 131,
    "title": "【Q130】docker 如何隔离容器与宿主机的时间",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5UIad3",
          "body": "命名空间（namespace）是Linux内核的一个强大特征，为容器虚拟化的实现带来了极大的便利。\r\n利用这一特征，每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样。\r\n命令空间机制保证了容器彼此之间互不影响。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzhejia",
            "url": "https://github.com/wuzhejia"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjkzODM=",
    "number": 132,
    "title": "【Q131】在 docker 的容器中，如何访问宿主机的 localhost",
    "body": "如在宿主机有一个 `mysql` 数据库，在容器中，如何连接数据库",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stTwi",
          "body": "由于容器和宿主的网络是隔离的，所以直接访问宿主的localhost是不可行的，主要有三种实现方式：\r\n1.使用宿主机的IP地址代替localhost，这种方式比较通用；\r\n2.使用主机名 host.docker.internal（仅限 Windows、macOS、Docker Desktop）；\r\n3.使用网络模式 host共享宿主机的网络命名空间，这样就可以直接使用localhost访问（仅限 Linux）；",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMzEzMjg=",
    "number": 133,
    "title": "【Q132】如何在 docker 中运行 docker",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stVTZ",
          "body": "要在docker中在运行docker（DinD）需要将宿主的docker守护进程套接字挂载到容器，同时在容器内安装docker客户端，这样容器内便可以共享使用宿主的docker引擎，但是这种方式存在安全风险，通常不建议这样编排。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgyNzc2Nzg=",
    "number": 134,
    "title": "【Q133】http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDg3MA==",
          "body": "代表二进制流，一般用以下载文件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5H2Rh4",
          "body": "用这个请求头好处是什么？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nianxiongdi",
            "url": "https://github.com/nianxiongdi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzkxMDc4ODk=",
    "number": 135,
    "title": "【Q134】ssh 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1MjE1ODM3OQ==",
          "body": "搬运 [图解SSH原理](https://www.jianshu.com/p/33461b619d53)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nextprops",
            "url": "https://github.com/nextprops"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ahSin",
          "body": "加密：SSH使用加密技术对网络连接进行保护，以确保数据在传输过程中是安全的。它使用的加密算法通常是对称加密和公钥加密的组合。\r\n隧道：SSH通过隧道技术，在不安全的网络中创建一个加密通道，将本地计算机和远程计算机之间的数据进行传输。隧道技术可以确保数据在不安全的网络中传输时是安全的，并且只有经过身份验证的用户才能访问远程计算机。\r\n身份验证：SSH提供了多种身份验证机制，包括基于密码、公钥、证书和挑战响应等。这些身份验证机制可以确保只有经过身份验证的用户才能访问远程计算机。\r\n端口转发：SSH还提供了端口转发功能，可以将本地计算机上的应用程序连接到远程计算机上的服务，从而实现远程访问本地服务的功能。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Azure089",
            "url": "https://github.com/Azure089"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzk0MjUwMzk=",
    "number": 136,
    "title": "【Q135】负载均衡有哪几种方式，它们的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Njg0NzUzOQ==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5stWT6",
          "body": "1.轮询：根据请求顺序依次分发到不同的机器；\r\n2.最小连接数：将请求分发到连接数最少的机器；\r\n3.IP哈希：对客户端的IP进行哈希计算，根据哈希值分配机器这样可保证相同IP永远分配到同一台机器；\r\n4.加权轮询和加权最小连接数：对服务器进行额外的权重配置，权重越大分配到的概率越大；\r\n5.随机：随机进行分发；\r\n6.内容感知路由：根据请求内容的URL，HTTP头等信息判断分发到哪台机器；",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDAxMzI2OTY=",
    "number": 137,
    "title": "【Q136】http 向 https 做重定向应该使用哪个状态码",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMTc1Nw==",
          "body": "一般用作 `301` 的较为多，但是也有使用 `302`，如果开启了 `HSTS` 则会使用 `307`\r\n\r\n如知乎使用了 302，淘宝使用了 301\r\n\r\n``` bash\r\n$ curl --head www.zhihu.com\r\nHTTP/1.1 302 Found\r\nDate: Tue, 24 Dec 2019 00:13:54 GMT\r\nContent-Length: 22\r\nConnection: keep-alive\r\nServer: NWS_TCloud_IPV6\r\nLocation: https://www.zhihu.com/\r\nX-NWS-LOG-UUID: 0e28d9a1-6aeb-42cd-9f6b-00bd6cf11500\r\n\r\n$ curl --head www.taobao.com\r\nHTTP/1.1 301 Moved Permanently\r\nServer: Tengine\r\nDate: Tue, 24 Dec 2019 00:13:58 GMT\r\nContent-Type: text/html\r\nContent-Length: 278\r\nConnection: keep-alive\r\nLocation: https://www.taobao.com/\r\nVia: cache20.cn1480[,0]\r\nTiming-Allow-Origin: *\r\nEagleId: 6f3f38a815771464380412555e\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA4MTY1NDQ=",
    "number": 138,
    "title": "【Q137】js 代码压缩 minify 的原理是什么",
    "body": "我们知道 `javascript` 代码经压缩 (uglify) 后，可以使体积变得更小，那它代码压缩的原理是什么。\r\n\r\n如果你来做这么一个功能的话，你会怎么去压缩一段 `js` 代码的体积",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzM5NDk1Nw==",
          "body": "@shfshanyue 问的是原理，你贴UglifyJS2的地址干嘛",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTA0MjQ2Ng==",
          "body": "uglify 包里有 ast.js 所以它一定是生成了抽象语法树\r\n接着遍历语法树并作出优化，像是替换语法树中的变量，变成a，b，c那样的看不出意义的变量名。还有把 if/else 合并成三元运算符等。\r\n最后输出代码的时候，全都输出成一行。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "everlose",
            "url": "https://github.com/everlose"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTczNDMwMA==",
          "body": "> uglify 包里有 ast.js 所以它一定是生成了抽象语法树\r\n> 接着遍历语法树并作出优化，像是替换语法树中的变量，变成a，b，c那样的看不出意义的变量名。还有把 if/else 合并成三元运算符等。\r\n> 最后输出代码的时候，全都输出成一行。\r\n\r\n非常nice",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fariellany",
            "url": "https://github.com/fariellany"
          }
        },
        {
          "id": "IC_kwDODQzyOs438Zbw",
          "body": "通过 AST 分析，根据选项配置一些策略，来生成一颗更小体积的 AST 并生成代码。\r\n\r\n目前前端工程化中使用 [terser](https://terser.org/docs/api-reference#compress-options) 和 [swc](https://swc.rs/docs/configuration/minification) 进行 JS 代码压缩，他们拥有相同的 API。\r\n\r\n常见用以压缩 AST 的几种方案如下:\r\n\r\n## 去除多余字符: 空格，换行及注释\r\n\r\n``` javascript\r\n// 对两个数求和\r\nfunction sum (a, b) {\r\n  return a + b;\r\n}\r\n```\r\n\r\n此时文件大小是 `62 Byte`， **一般来说中文会占用更大的空间。**\r\n\r\n多余的空白字符会占用大量的体积，如空格，换行符，另外注释也会占用文件体积。当我们把所有的空白符合注释都去掉之后，代码体积会得到减少。\r\n\r\n**去掉多余字符之后，文件大小已经变为 `30 Byte`。** 压缩后代码如下:\r\n\r\n``` javascript\r\nfunction sum(a,b){return a+b}\r\n```\r\n\r\n替换掉多余字符后会有什么问题产生呢？\r\n\r\n**有，比如多行代码压缩到一行时要注意行尾分号。** \r\n\r\n## 压缩变量名：变量名，函数名及属性名\r\n\r\n``` javascript\r\nfunction sum (first, second) {\r\n  return first + second;  \r\n}\r\n```\r\n\r\n如以上 `first` 与 `second` 在函数的作用域中，在作用域外不会引用它，此时可以让它们的变量名称更短。但是如果这是一个 `module` 中，`sum` 这个函数也不会被导出呢？那可以把这个函数名也缩短。\r\n\r\n``` javascript\r\n// 压缩: 缩短变量名\r\nfunction sum (x, y) {\r\n  return x + y;  \r\n}\r\n\r\n// 再压缩: 去除空余字符\r\nfunction s(x,y){return x+y}\r\n```\r\n\r\n在这个示例中，当完成代码压缩 (`compress`) 时，代码的混淆 (`mangle`) 也捎带完成。 **但此时缩短变量的命名也需要 AST 支持，不至于在作用域中造成命名冲突。**\r\n\r\n## 解析程序逻辑：合并声明以及布尔值简化\r\n\r\n通过分析代码逻辑，可对代码改写为更精简的形式。\r\n\r\n合并声明的示例如下：\r\n\r\n``` javascript\r\n// 压缩前\r\nconst a = 3;\r\nconst b = 4;\r\n\r\n// 压缩后\r\nconst a = 3, b = 4;\r\n```\r\n\r\n布尔值简化的示例如下：\r\n\r\n``` javascript\r\n// 压缩前\r\n!b && !c && !d && !e\r\n\r\n// 压缩后\r\n!(b||c||d||e)\r\n```\r\n\r\n## 解析程序逻辑: 编译预计算\r\n\r\n在编译期进行计算，减少运行时的计算量，如下示例:\r\n\r\n``` javascript\r\n// 压缩前\r\nconst ONE_YEAR = 365 * 24 * 60 * 60\r\n\r\n// 压缩后\r\nconst ONE_YAAR = 31536000\r\n```\r\n\r\n以及一个更复杂的例子，简直是杀手锏级别的优化。\r\n\r\n``` javascript\r\n// 压缩前\r\nfunction hello () {\r\n  console.log('hello, world')\r\n}\r\n\r\nhello()\r\n\r\n// 压缩后\r\nconsole.log('hello, world')\r\n```\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5NjUwNTk=",
    "number": 139,
    "title": "【Q138】一个守护进程的创建步骤是什么，如何用 C 语言创建",
    "body": "#50 ",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        },
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5NzU5MDg=",
    "number": 140,
    "title": "【Q139】在 Node 应用中如何利用多核心CPU的优势",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyNDQyMQ==",
          "body": "使用 `cluster` 模块\r\n\r\n[Node 中 cluster 的原理是什么](https://github.com/shfshanyue/Daily-Question/issues/141)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5ODQ0NDI=",
    "number": 141,
    "title": "【Q140】Node 中 cluster 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyMzY1NA==",
          "body": "1. `fork` 子进程\r\n1. `Load Balance`\r\n1. 多进程共享端口\r\n\r\n## 相关文章\r\n\r\n+ [Node 官方文档: cluster](https://nodejs.org/api/cluster.html)\r\n+ [深入浅出 node cluster](https://juejin.im/post/5c87760fe51d4507534c88e5)\r\n+ [Node.js进阶：cluster模块深入剖析](https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDEzMjg1MTI=",
    "number": 142,
    "title": "【Q141】http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODE4MjMzNw==",
          "body": "+ `Date`: 报文在源服务器的产生时间，由此可查看报文已缓存了多久时间\r\n+ `Last-Modified`: 源服务器上资源的上次修改时间\r\n\r\n`LM-Factor` 与它俩有关，它处于 [0, 1] 之间，以下使用 n 来替代。\r\n\r\n简而言之，一个静态资源没有设置 `Cache-Control` 时会以这两个响应头来设置强制缓存时间：`(Date - LastModified) * n`，而非直接进行协商缓存。在涉及到 CDN 时，表现更为明显，体现在更新代码部署后，界面没有更新。\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41JfTh",
          "body": "(Date - LastModified) * n  这个n代表什么？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuhaoz",
            "url": "https://github.com/yuhaoz"
          }
        },
        {
          "id": "IC_kwDODQzyOs41VK0s",
          "body": "@yuhaoz 就是那个 lm-factor",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE0MjcyMzg=",
    "number": 143,
    "title": "【Q142】react hooks 中如何模拟 componentDidMount",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODg1MDAwNw==",
          "body": "在 `useEffect`，把第二个参数即依赖的状态，设置为 `[]`\r\n \r\n``` js\r\nuseEffect(callback, [])\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE1NzE2NTk=",
    "number": 144,
    "title": "【Q143】docker-compose 部署 docker 时，如何把宿主机的环境变量注入到容器中",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stW1d",
          "body": "通过在docker-compose.yaml的容器配置上加environment配置项，便可以将宿主的环境变量注入到容器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE5Mzc1MTU=",
    "number": 145,
    "title": "【Q144】http 1.1 中的 keep-alive 有什么作用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDUxMw==",
          "body": "在 `http 1.1` 中，在响应头中设置 `keep-alive` 可以在一个 TCP 连接上发送多个 http 请求\r\n\r\n1. 避免了重开 TCP 连接的开销\r\n1. 避免了刷新时重新建立 SSL 连接的开销\r\n1. 避免了QPS过大时，服务器的连接数过大\r\n\r\n在服务器端使用响应头开启 `keep-alive`\r\n\r\n``` bash\r\nConnection: Keep-Alive\r\nKeep-Alive: timeout=5, max=1000\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIxMzQ2MTU=",
    "number": 146,
    "title": "【Q145】如何判断端口是否可达",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODc1MjAzMA==",
          "body": "使用 `nc`，`-z` 指测试接口连通性\r\n\r\n``` bash\r\nnc -vz localhost 443\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIyMjk1OTE=",
    "number": 147,
    "title": "【Q146】如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODgxNzY1Mw==",
          "body": "不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwMDQxMzg3OQ==",
          "body": "我试了 可以啊 这是时候只是找不到实体DOM 但是具备js的执行环境了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "thunderqin",
            "url": "https://github.com/thunderqin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI1NDY2MzM=",
    "number": 148,
    "title": "【Q147】当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTM4MzY4Mg==",
          "body": "当前 curl 的版本及支持的协议以及功能特性没有支持 HTTP2",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "vczx1994",
            "url": "https://github.com/vczx1994"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3ODkxODU=",
    "number": 149,
    "title": "【Q148】关于 JSON，以下代码输出什么",
    "body": "``` js\r\nconst obj = {\r\n  a: 3,\r\n  b: 4,\r\n  c: null,\r\n  d: undefined,\r\n  get e () {}\r\n}\r\n\r\nconsole.log(JSON.stringify(obj))\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTIxNzAyNg==",
          "body": "> ``` js\r\n> const obj = {\r\n>   a: 3,\r\n>   b: 4,\r\n>   c: null,\r\n>   d: undefined,\r\n>   get e () {}\r\n> }\r\n> ```\r\n> \r\n> console.log(JSON.stringify(obj))\r\n>\r\n> 输出什么？\r\n\r\n``` js\r\n{\"a\":3,\"b\":4,\"c\":null}\r\n```\r\n\r\n对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTIyNTAwNQ==",
          "body": "666",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiushangzhe",
            "url": "https://github.com/qiushangzhe"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI5MTA4OQ==",
          "body": "> > ```js\r\n> > const obj = {\r\n> >   a: 3,\r\n> >   b: 4,\r\n> >   c: null,\r\n> >   d: undefined,\r\n> >   get e () {}\r\n> > }\r\n> > ```\r\n> > \r\n> > \r\n> > console.log(JSON.stringify(obj))\r\n> > 输出什么？\r\n> \r\n> ```js\r\n> {\"a\":3,\"b\":4,\"c\":null}\r\n> ```\r\n> \r\n> 对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉\r\n\r\n`const obj` 中的 `get e () {}` 并不是函数，此处应该是重写了 `obj.e` 的 `get` 方法，因为 `get` 方法未定义返回值，因此在执行 `JSON.stringify` 时，执行 `obj.e` 的 `get` 方法，返回 `undefined`，因此被忽略\r\n\r\n让我们更改 `get` 方法的返回值\r\n![image](https://user-images.githubusercontent.com/57755075/89437679-76f57080-d77a-11ea-9208-2e80d6505d68.png)\r\n\r\n看到 666 了吧？",
          "star": {
            "totalCount": 3
          },
          "author": null
        },
        {
          "id": "IC_kwDODQzyOs5JToup",
          "body": "> > > ```js\r\n> > > const obj = {\r\n> > >   a: 3,\r\n> > >   b: 4,\r\n> > >   c: null,\r\n> > >   d: undefined,\r\n> > >   get e () {}\r\n> > > }\r\n> > > ```\r\n> > > \r\n> > > \r\n> > >     \r\n> > >       \r\n> > >     \r\n> > > \r\n> > >       \r\n> > >     \r\n> > > \r\n> > >     \r\n> > >   \r\n> > > console.log(JSON.stringify(obj))\r\n> > > 输出什么？\r\n> > \r\n> > \r\n> > ```js\r\n> > {\"a\":3,\"b\":4,\"c\":null}\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > 对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉\r\n> \r\n> `const obj` 中的 `get e () {}` 并不是函数，此处应该是重写了 `obj.e` 的 `get` 方法，因为 `get` 方法未定义返回值，因此在执行 `JSON.stringify` 时，执行 `obj.e` 的 `get` 方法，返回 `undefined`，因此被忽略\r\n> \r\n> 让我们更改 `get` 方法的返回值 ![image](https://user-images.githubusercontent.com/57755075/89437679-76f57080-d77a-11ea-9208-2e80d6505d68.png)\r\n> \r\n> 看到 666 了吧？\r\n\r\n原来是这样，又学到了 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Awalter0411",
            "url": "https://github.com/Awalter0411"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3OTEzMzg=",
    "number": 150,
    "title": "【Q149】什么是队首阻塞，如何解决，原理如何",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5coXzS",
          "body": "队首阻塞包含http应用层协议上的队首阻塞和tcp传输层的队首阻塞\r\n\r\n1. http应用层协议上的队首阻塞:\r\n以http1.1为例，一个tcp连接一次只能处理一个请求，如果接受端处理慢的话，后面的请求就得排队，这是导致队首阻塞的根本原因\r\n虽然http1.1提出了管线技术，支持同时发起多个请求出去，但是又限制了接收端返回必须得按照顺序，所以这项技术也未能解决队首阻塞。\r\n\r\nhttp2.0 提出了 frame 和 stream的概念，\r\n把请求数据分成了不同的二进制frame，有strameid标识，包装进不同的stream通过同一个tcp管道进行并发的多路复用传输，\r\n接收端根据streamid来进行组装，解决了队首阻塞的问题。\r\n\r\n但是依然没有解决tcp传输层的队首阻塞，如果过程中一个包丢了，需要重传，就需要后面的包等待了\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuzd",
            "url": "https://github.com/yuzd"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDMxMzgwMDQ=",
    "number": 151,
    "title": "【Q150】redis 中 zset 是什么，用作什么应用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMjcyNQ==",
          "body": "`SortedSet`，有序集合，一般可以有两种用途\r\n\r\n1. 排行榜，TOP N 之类\r\n1. 优先级消息队列",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQxMDM=",
    "number": 152,
    "title": "【Q151】react hooks 如何替代或部分替代 redux 功能",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwNDI4MQ==",
          "body": "我们把全局store分为两块\r\n\r\n1. 从服务器端来，如各种 `model`，此时可以使用 `swr` 直接替代。或者封装一个 `useModel`，如 `useUser`，`usePermission`\r\n1. 客户端全局 store，此时可以使用 `useReducer` 和 `useContext` 来替代",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMzE2Nw==",
          "body": "useReducer+useContext",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQ5NTA=",
    "number": 153,
    "title": "【Q152】如何实现一个 react hook，你有没有自己写过一个",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwMzM1Nw==",
          "body": "可以参考官方文档 <https://reactjs.org/docs/hooks-custom.html>\r\n\r\n自定义一个 `hook` 仅仅是一个以 `use` 打头，组合 `useState` 和 `useEffect` 或者其它 `hooks` 的一个普通函数",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMzQzNg==",
          "body": "各种优秀实现=》https://github.com/streamich/react-use",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDU0MjYxOQ==",
          "body": "> 各种优秀实现=》https://github.com/streamich/react-use\r\n\r\n这个厉害！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0MzI2MjM=",
    "number": 154,
    "title": "【Q153】权限设计中的 RABC 是指什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcwMTc0MTg3Mw==",
          "body": "RBAC: Role-Based Access Control?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "e10101",
            "url": "https://github.com/e10101"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BXQ5D",
          "body": "当我们通过角色为某一个用户指定到不同的权限之后，那么该用户就会在 项目中体会到不同权限的功能",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "knockkeykey",
            "url": "https://github.com/knockkeykey"
          }
        },
        {
          "id": "IC_kwDODQzyOs5KFA4e",
          "body": "https://blog.csdn.net/brother_Cheng_Py/article/details/121970486\r\n这篇文章有解释ACL模型、RABC模型和ABAC模型",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0NTk0MjA=",
    "number": 155,
    "title": "【Q154】在 react/vue 中数组是否可以以在数组中的次序为 key",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMjIwMg==",
          "body": "不可，key应为唯一标示，在数组变更时插入或删除后，index无法确保始终指向对应的序列",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        },
        {
          "id": "IC_kwDODQzyOs5H4UWG",
          "body": "只要数组次序不变更  是可以用index作为key值的吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Superljf",
            "url": "https://github.com/Superljf"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0ODE3NjM=",
    "number": 156,
    "title": "【Q155】当服务升级或者回退时，如何保证流量平滑切换",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stYXf",
          "body": "升级或者回退时先在预发布环境进行测试，确保测试无误后采用灰度发布的方式，先发布更新到负载较小的机器进行生产测试，一起正常再逐步更新所有机器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NDE5Mjc=",
    "number": 157,
    "title": "【Q156】如何进行代码质量检测",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDE4Nzc0NA==",
          "body": "圈复杂度(Cyclomatic complexity)描写了代码的复杂度，可以理解为覆盖代码所有场景所需要的最少测试用例数量。CC 越高，代码则越不好维护\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c2Mg",
          "body": "code review",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OXqcA",
          "body": "sonarQube插件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NTcxMDg=",
    "number": 158,
    "title": "【Q157】如何管理生产环境多个数据库的配置，如何快速连接",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stZ37",
          "body": "可以通过本地配置文件，环境变量，远程配置服务etcd, zookeeper等，密钥存储服务或docker编排文件里配置多个数据库等配置信息，当需要连接不同数据库的时候只需要更换配置信息即可",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUyODExMzI=",
    "number": 159,
    "title": "【Q158】数据库 postgres 与 mysql 相比有哪些优劣",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5lmNjP",
          "body": "PostgreSQL 和 MySQL 都是优秀的数据库管理系统，它们都提供了高性能、稳定和安全的数据存储和处理功能。但是，它们之间也存在一些差异，以下是它们的优劣比较：\r\n\r\n**功能强大**\r\n\r\nPostgreSQL 支持更多的数据类型和操作符，包括全文搜索和数组操作符。它还支持更复杂的查询语句，如子查询、连接多个表、使用递归查询等。MySQL 在这方面也有一些限制，比如不支持全文搜索和数组操作符。\r\n\r\n**性能优化**\r\n\r\nPostgreSQL 的性能优化工具和度量信息更加丰富，包括支持在线备份、表空间、资源组、逻辑复制等特性。这些工具可以帮助数据库管理员更好地监控、管理和优化数据库性能。MySQL 也有一些性能优化工具，但相对于 PostgreSQL 来说略显简单。\r\n\r\n**数据完整性**\r\n\r\nPostgreSQL 支持更严格的数据完整性约束，如主键、唯一索引、外键等。它还支持更复杂的业务逻辑，如触发器、规则和函数等。MySQL 在这方面相对较弱，对于一些复杂的业务逻辑处理能力有限。\r\n\r\n**多表连接查询**\r\n\r\nPostgreSQL 支持所有主流的多表连接查询方式，包括 Nest loop、Hash JOIN、Sort Merge JOIN 等。MySQL 也支持这些连接查询方式，但在某些情况下可能表现不佳。\r\n\r\n**数据仓库**\r\n\r\nPostgreSQL 是非常适合做数据仓库的数据库之一，支持大量的分析函数和操作符，还支持全文搜索、空间索引等特性。MySQL 在这方面相对较弱，更适合于事务处理和轻量级应用。\r\n\r\n**移动互联网特性**\r\n\r\nPostgreSQL 支持一些移动互联网特性，如空间索引和时间序列数据存储。MySQL 也有一些支持移动互联网的特性，但相对较少。\r\n\r\n**在线操作功能**\r\n\r\nPostgreSQL 支持在线建索引和修改表结构的功能，可以在不锁定表的情况下进行操作。MySQL 在这方面相对较弱，需要锁定表或者使用一些特殊的工具来实现。\r\n\r\n总的来说，PostgreSQL 和 MySQL 都是优秀的数据库管理系统，选择哪种取决于具体的应用场景和需求。如果需要高性能、稳定和安全的数据存储和处理功能，同时需要更严格的数据完整性约束和更复杂的查询语句，那么 PostgreSQL 是更好的选择。如果需要轻量级、易于管理和维护的数据库系统，同时不需要太复杂的数据处理和业务逻辑，那么 MySQL 是更好的选择。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zcrchong",
            "url": "https://github.com/zcrchong"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzQ2NDc=",
    "number": 160,
    "title": "【Q159】什么是 CSRF 攻击",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzgyMTQyOA==",
          "body": "跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\r\n\r\n来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rex-ll",
            "url": "https://github.com/rex-ll"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MzYxMjEwNA==",
          "body": "CSRF (Cross-site request forgery)，跨站请求伪造，又称为 `one-click attack`，顾名思义，通过恶意引导用户一次点击劫持 cookie 进行攻击。\r\n\r\n1. 使用 JSON API。当进行 CSRF 攻击时，请求体通过 `<form>` 构建，请求头为 `application/www-form-urlencoded`。它难以发送 JSON 数据被服务器所理解。\r\n2. CSRF Token。生成一个随机的 token，切勿放在 cookie 中，每次请求手动携带该 token 进行校验。\r\n3. SameSite Cookie。设置为 Lax 或者 Strict，禁止发送第三方 Cookie。\r\n\r\n> 参考以下链接：\r\n> 1. [理解 CSRF](https://github.com/pillarjs/understanding-csrf/blob/master/README_zh.md)\r\n> 1. [Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNDI=",
    "number": 161,
    "title": "【Q160】如何设置一个 cookie",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjgxMjk3MQ==",
          "body": "HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。\r\n\r\n服务端是通过setCookie的响应头来设置cookie的，要设置多个cookie时，得多写几个setCookie。服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。\r\n\r\n前端使用document.cookie属性来读写当前网页的 Cookie。写入的时候，Cookie 的值必须写成key=value的形式。\r\n\r\nCookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。\r\n参考资料：\r\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)\r\n[把cookie聊清楚](https://juejin.im/post/59d1f59bf265da06700b0934)\r\n[阮一峰JavaScript教程](https://javascript.ruanyifeng.com/bom/cookie.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VCAz2",
          "body": "``` js\r\n// 旧方式\r\ndocument.cookie = 'a=3'\r\n\r\n// 也可以使用新的 API\r\ncookieStore.set('a', 3)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNjU=",
    "number": 162,
    "title": "【Q161】如何删除一个 cookie",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NDgxMjkzOQ==",
          "body": "通过把该 `cookie` 的过期时间改为过去时即可删除成功，具体操作的话可以通过操作两个字段来完成\r\n\r\n1. `max-age`: 将要过期的最大秒数，设置为 `-1` 即可删除\r\n1. `expires`: 将要过期的绝对时间，存储到 `cookies` 中需要通过 `date.toUTCString()` 处理，设置为过期时间即可删除\r\n\r\n很明显，`max-age` 更为简单，以下代码可在命令行控制台中进行测试\r\n\r\n``` js\r\n// max-age 设置为 -1 即可成功\r\ndocument.cookie = 'a=3; max-age=-1'\r\n```\r\n\r\n``` js\r\n> document.cookie\r\n< \"\"\r\n\r\n> document.cookie = 'a=3'\r\n< \"a=3\"\r\n\r\n> document.cookie\r\n< \"a=3\"\r\n\r\n// 把该字段的 max-age 设置为 -1\r\n> document.cookie = 'a=3; max-age=-1'\r\n< \"a=3; max-age=-1\"\r\n\r\n// 删除成功\r\n> document.cookie\r\n< \"\"\r\n```\r\n\r\n同时，也可以使用最新关于 cookie 操作的 API: [CookieStore API](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore) 其中的 `cookieStore.delete(name)` 删除某个 cookie",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c2PD",
          "body": "前端一般不操作，server来操作",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU0MTk0OTE=",
    "number": 163,
    "title": "【Q162】如何禁止服务器被 ping",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY5MzM4NTQ3MA==",
          "body": "\r\n> echo \"1\" > /proc/sys/net/ipv4/icmp_echo_ignore_all\r\n\r\n\r\n[How do I disable ping responses from my system?\r\n](https://access.redhat.com/articles/7134#:~:text=To%20configure%20a%20Red%20Hat,command%20as%20the%20root%20user.&text=To%20make%20the%20changes%20persistent,to%20ICMP%20(ping)%20net.)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iSenninha",
            "url": "https://github.com/iSenninha"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU3MDExMDM=",
    "number": 164,
    "title": "【Q163】如何创建一个线程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MjUzNTY3NQ==",
          "body": "创建一个最简单的线程\r\n\r\n``` c\r\n#include <pthread.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid *thread_function(void *arg) {\r\n  printf(\"hello, world\\n\");\r\n  sleep(10);\r\n}\r\n\r\nint main() {\r\n  pthread_t thread;\r\n\r\n  pthread_create(&thread, NULL, thread_function, NULL);\r\n  pthread_join(thread, NULL);\r\n}\r\n```\r\n\r\n执行它\r\n\r\n``` bash\r\n$ gcc thread.c -std=c99 -lpthread && ./a.out\r\nhello, world\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc0Mzk3ODI=",
    "number": 165,
    "title": "【Q164】React 中 fiber 是用来做什么的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDczODQ3NA==",
          "body": "因为JavaScript单线程的特点，每个同步任务不能耗时太长，不然就会让程序不会对其他输入作出相应，React的更新过程就是犯了这个禁忌，而React Fiber就是要改变现状。\r\n而可以通过分片来破解JavaScript中同步操作时间过长的问题。\r\n\r\n把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。\r\n\r\nReact Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。\r\n\r\n维护每一个分片的数据结构，就是Fiber。",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "yuzeyang97",
            "url": "https://github.com/yuzeyang97"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODYyOTY2OQ==",
          "body": "React Fiber是对核心算法的一次重新实现\r\nFiber reconciler\r\n从v16.x开始底层使用Fiber reconciler替换stack reconciler.\r\n已知：\r\nstack reconciler处理大状态时由于计算和组件树遍历的消耗容易出现渲染线程挂起，进而页面掉帧。（根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行JS）\r\n\r\n求：\r\n建立一种能解决主线程占用问题，且具有长远意义的机制\r\n解：\r\n把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间（更细粒度、更强的控制力）\r\n\r\n子问题：\r\n1.拆什么？什么不能拆？\r\n把渲染/更新过程分为2个阶段（diff + patch）：\r\ndiff~~render/reconciliation\r\n(对比prevInstance和nextInstance的状态，找出差异及其对应的DOM change。)\r\npatch~~commit\r\n(把本次更新中的所有DOM change应用到DOM树，是一连串的DOM操作。)\r\nrender/reconciliation阶段的工作（diff）可以拆分，commit阶段的工作（patch）不可拆分.\r\n\r\n2.怎么拆？\r\nFiber的拆分单位是fiber（fiber tree上的一个节点），实际上就是按虚拟DOM节点拆，因为fiber tree是根据vDOM tree构造出来的，树结构一模一样，只是节点携带的信息有差异。\r\n\r\n3.如何调度任务？\r\n分2部分：\r\n￼工作循环\r\n￼优先级机制\r\n工作循环是基本的任务调度机制，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会，此时通过shouldYield函数（idleDeadline.timeRemaining()）判读时间是否用完，用完则把时间还给主线程等待下次requestIdleCallback的唤起，否则继续执行任务。\r\n优先级机制用来处理突发事件与优化次序。\r\n有如下策略：\r\n￼到commit阶段了，提高优先级\r\n￼高优任务做一半出错了，给降一下优先级\r\n￼抽空关注一下低优任务，别给饿死了\r\n￼如果对应DOM节点此刻不可见，给降到最低优先级\r\n是工作循环的辅助机制。\r\n\r\n4.如何中断/断点恢复？\r\n中断：检查当前正在处理的工作单元，保存当前成果（firstEffect, lastEffect），修改tag标记一下，迅速收尾并再开一个requestIdleCallback，下次有机会再做\r\n断点恢复：下次再处理到该工作单元时，看tag是被打断的任务，接着做未完成的部分或者重做\r\n自然中断（时间耗尽），或优先级中断（高优任务中断），原理相同。\r\n\r\n5.如何收集任务结果？\r\n每个节点更新结束时向上归并effect list来收集任务结果，reconciliation结束后，根节点的effect list里记录了包括DOM change在内的所有side effect。\r\n\r\nrequestIdleCallback\r\n让开发者在主事件循环中执行后台或低优先级的任务,不会对动画和用户交互等关键事件产生影响。\r\n\r\nfiber 架构：\r\n* 循环条件：利用 requestIdeCallback 空闲时间递减.\r\n* 遍历过程：利用链表，找孩子找兄弟找父亲.",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Feahter",
            "url": "https://github.com/Feahter"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MTMwODM=",
    "number": 166,
    "title": "【Q165】什么是公有云，私有云，混合云以及多重云",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0Mjk5ODAzNQ==",
          "body": "公有云就是阿里云 腾讯云 aws 等\r\n私有云 就是公司自己买物理机，在机房自己搭建网络，自己做虚拟机\r\n混合云 就是 公有云 + 私有云\r\n多重云 就是多个公有云",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "timtike",
            "url": "https://github.com/timtike"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MzA5OTA=",
    "number": 167,
    "title": "【Q166】在C语言中，void * 是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNTMzMTM0OA==",
          "body": "`void` 指无类型，常用在函数前，表示什么也不用返回。\r\n\r\n`*` 代表一个指针，如 `int *p` 代表指针 p 指向一个整型，`char *s` 代表指针 s 指向一个字符串的首地址。\r\n\r\n而 `void *` 代表一个可能指向任何类型的指针，如下代码所示：\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  void *p;\r\n\r\n  // 使用它装一个整数\r\n  int a = 3;\r\n  p = &a;\r\n  printf(\"%d\", *(int *)p);\r\n\r\n  // 使用它装一个字符串\r\n  char s[] = \"hello, world\";\r\n  p = s;\r\n  printf(\"%s\", p);\r\n  return 0;\r\n}\r\n```\r\n\r\n## 相关问题\r\n\r\n+ [【Q433】在C语言中，void 是什么意思](https://github.com/shfshanyue/Daily-Question/issues/440)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg0MTM1MTQ=",
    "number": 168,
    "title": "【Q167】每个指针所占的存储空间是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzMwNDg5MQ==",
          "body": "与字长有关。如果是64位系统，则占八个字节，32位系统，则占四个字节。可以用 `sizeof` 测试\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  int *p;\r\n\r\n  printf(\"size: %d\", sizeof(p));\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MTA3OTM=",
    "number": 169,
    "title": "【Q168】在 js 中如何把类数组转化为数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzY3MTY0Mg==",
          "body": "首先，什么是类数组(Array Like)？\r\n\r\n**一个简单的定义，如果一个对象有 `length` 属性值，则它就是类数组**\r\n\r\n那常见的类数组有哪些呢？\r\n\r\n这在 DOM 中甚为常见，如各种元素检索 API 返回的都是类数组，如 `document.getElementsByTagName`，`document.querySelectorAll` 等等。除了 DOM API 中，常见的 `function` 中的 `arguments` 也是类数组\r\n\r\n那如何把类数组转化为数组呢？这是类数组操作时一个典型的场景，也是一个典型的面试题\r\n\r\n以下我们将以 `{ length: 3 }` 来指代类数组，来作为演示\r\n\r\n<!--more-->\r\n\r\n## ES6+\r\n\r\n`ES6` 中有现成的 API：`Array.from`，极为简单\r\n\r\n``` js\r\n// [undefined, undefined, undefined]\r\nArray.from({ length: 3 })\r\n```\r\n\r\n除了 `Array.from` 还有更简单的运算符 `...` 扩展运算符，不过它只能作用于 `iterable` 对象，即拥有 `Symbol(Symbol.iterator)` 属性值\r\n\r\n拥有 `Symbol(Symbol.iterator)` 属性值，意味着可以使用 `for of` 来循环迭代\r\n\r\n``` js\r\n// 适用于 iterable 对象\r\n[...document.querySelectorAll('div')]\r\n```\r\n\r\n但是严格意义上来说，它不能把类数组转化为数组，如 `{ length: 3 }`。它将会抛出异常\r\n\r\n``` js\r\n// Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\r\n[...{length: 3}]\r\n```\r\n\r\n## ES5\r\n\r\n在此之前，我们先不使用 `{ length: 3 }`，使用以下数据来代表类数组\r\n\r\n``` js\r\nconst arrayLike = {\r\n  0: 3,\r\n  1: 4,\r\n  2: 5,\r\n  length: 3\r\n}\r\n```\r\n\r\n在 `ES5` 中可以借用 `Array API` 通过 `call/apply` 改变 `this` 或者 `arguments` 来完成转化。\r\n\r\n最常见的转换是 `Array.prototype.slice`\r\n\r\n``` js\r\nArray.prototype.slice.call(arrayLike)\r\n```\r\n\r\n**当然由于借用 `Array API`，一切以数组为输入，并以数组为输出的 API 都可以来做数组转换，如**\r\n\r\n+ `Array` (借用 arguments)\r\n+ `Array.prototype.concat` (借用 arguments)\r\n+ `Array.prototype.slice` (借用 this)\r\n+ `Array.prototype.map` (借用 this)\r\n+ `Array.prototype.filter` (借用 this)\r\n\r\n``` js\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\nArray.prototype.slice.call(arrayLike)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n此时一切正常，但是忘了一个特例，稀疏数组。在此之前，先做一个题，以下代码输出多少\r\n\r\n``` js\r\n// 该代码输出多少\r\nArray(100).map(x => 1)\r\n```\r\n\r\n> 参考 [Array(100).map(x => 1) 结果是多少](https://github.com/shfshanyue/Daily-Question/issues/170)\r\n\r\n## 稀疏数组 (sparse array)\r\n\r\n使用 `Array(n)` 将会创建一个稀疏数组，为了节省空间，稀疏数组内含非真实元素，在控制台上将以 `empty` 显示，如下所示\r\n\r\n`[,,,]` 与 `Array(3)` 都将返回稀疏数组\r\n\r\n``` js\r\n> [,,,]\r\n[empty × 3]\r\n> Array(3)\r\n[empty × 3]\r\n```\r\n\r\n当类数组为 `{ length: 3 }` 时，一切将类数组做为 `this` 的方法将都返回稀疏数组，而将类数组做为 `arguments` 的方法将都返回密集数组\r\n\r\n## 总结\r\n\r\n由上总结，把类数组转化成数组最靠谱的方式是以下三个\r\n\r\n``` js\r\nArray.from(arrayLike)\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\n```\r\n\r\n以下几种方式需要考虑稀疏数组的转化\r\n\r\n``` js\r\nArray.prototype.filter.call(divs, x => 1)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n以下方法要注意是否是 `iterable object`\r\n\r\n``` js\r\n[...arrayLike]\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MzAxNjc=",
    "number": 170,
    "title": "【Q169】Array(100).map(x => 1) 结果是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzUyNzgyOA==",
          "body": "`Array(100)` 将会创建一个稀疏数组 (sparse array)，即不存在真实元素，节省内存空间。在控制台上显示为 `[empty]`\r\n\r\n``` js\r\n// [empty × 100]\r\nArray(100)\r\n```\r\n\r\n正因为没有元素，所以它也不会有 `map` 操作，所以 `Array(100).map(x => 1)` 仍然返回为 `[empty]`\r\n\r\n**那如何生成100个元素为1的数组呢？**\r\n\r\n可以使用 `Array.from`\r\n\r\n``` js\r\nArray.from(Array(100), x => 1)\r\n```\r\n\r\n而在 `ES5` 中借用 `apply`\r\n\r\n``` js\r\nArray.apply(null, Array(100)).map(x => 1)\r\n```\r\n\r\n根据楼下提示，再添加一个 `fill`\r\n\r\n``` js\r\nArray(100).fill(1)\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk2MTEwNQ==",
          "body": "> 那如何生成100个元素为1的数组呢？\r\n\r\n```ts\r\nArray(100).fill(1)\r\n```",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "Chersquwn",
            "url": "https://github.com/Chersquwn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg4MzUzMDY=",
    "number": 171,
    "title": "【Q170】什么是文件描述符 (file descriptor)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzU5OTE0MA==",
          "body": "`fd` 在内核中通常表示为非负整数，当进程新建或者打开文件时，内核将会返回一个文件描述符，使用它可以用来读写文件。\r\n\r\n另外，新建 `socket` 时也会产生一个文件描述符。\r\n\r\n另外，有三个特殊的文件描述符，用以表示标准输入，标准输出及标准错误\r\n\r\n+ `STDIN_FILENO`: 0\r\n+ `STDOUT_FILENO`: 1\r\n+ `STDERR_FILENO`: 2",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDkzNTkzNjc=",
    "number": 172,
    "title": "【Q171】在服务器内如何得知自己的公网IP",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NDAyMzI2NQ==",
          "body": "有现成的公网IP服务提供，根据 TCP 连接获得真实 IP 地址\r\n\r\n``` bash\r\n$ curl ifconfig.me\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0MTQ3MjE=",
    "number": 173,
    "title": "【Q172】C语言中 printf 与 puts 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NDA2NjU1Ng==",
          "body": "```c\r\n// 支持各种格式\r\nint printf(const char *__restrict__ __format, ...);\r\n\r\n// 只支持字符串输出到 stdout，适用于只有字符串时\r\nint puts(const char *__s);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0NTk5NDI=",
    "number": 174,
    "title": "【Q173】简述 UDP socket 建立的过程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NDA5OTY3MQ==",
          "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/72334798-e3365700-36f8-11ea-9bd8-1bfd59118c01.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUwMzc=",
    "number": 175,
    "title": "【Q174】TCP 三次握手发生在 socket 建立的哪一步",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_QQ-i",
          "body": "TCP Client调用connec()请求建立连接时",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "changshou83",
            "url": "https://github.com/changshou83"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        },
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUzNDA=",
    "number": 176,
    "title": "【Q175】如何使用 css 写一个魔方",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs49dcsq",
          "body": "https://jsbin.com/xemaxovisa/edit?css,output",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "dsize1",
            "url": "https://github.com/dsize1"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DwRmm",
          "body": "https://codepen.io/indusy/pen/YzeEzzb",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Indusy",
            "url": "https://github.com/Indusy"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1NzgyNjA=",
    "number": 177,
    "title": "【Q176】如何在数组中找出三个数之和为N",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4-tl6K",
          "body": "排序之后使用双指针\r\nlet ar = [5, 12, 6, 3, 9, 2, 1, 7];\r\n\r\nfunction getthreenum(arr, target, result = []) {\r\n    arr = arr.sort((a, b) => a - b)\r\n    const len = arr.length;\r\n    for (let i = 0; i < len; i++) {\r\n        let j = i + 1;\r\n        let k = len - 1;\r\n        while (j < k) {\r\n            if (arr[j] + arr[k] > target - arr[i]) {\r\n                k--;\r\n            } else if (arr[j] + arr[k] < target - arr[i]) {\r\n                j++;\r\n            } else {\r\n                result.push([arr[i], arr[j], arr[k]]);\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nconsole.log(getthreenum(ar, 13, []));",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HNHED",
            "url": "https://github.com/HNHED"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MCnY4",
          "body": "可以使用双指针法，注意去重；\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans;\r\n        if(nums.empty() || nums.size()<3)\r\n            return ans;\r\n\r\n        sort(nums.begin(), nums.end());\r\n\r\n        for(int i=0; i<nums.size(); i++){\r\n            if(i==0 || (i>0&&nums[i]!=nums[i-1])){\r\n                int left = i+1;\r\n                int right = nums.size()-1;\r\n                while(left<right){\r\n                    int s = nums[i]+nums[left]+nums[right];\r\n                    if(s<0){\r\n                        left++;\r\n                    }else if(s>0) {\r\n                        right--;\r\n                    }else{\r\n                        ans.push_back({nums[i], nums[left], nums[right]});\r\n                        while(left<right && nums[left]==nums[left+1]){  // 找到下一个不相等的下标，为了去重\r\n                            left++;\r\n                        }\r\n                        while(left<right && nums[right]==nums[right-1]){ // 找到下一个不相等的下标，为了去重\r\n                            right--;\r\n                        }\r\n                        left++;\r\n                        right--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n参考：[【LeetCode-数组】三数之和 - Flix - 博客园](https://www.cnblogs.com/flix/p/12651825.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Zss1990",
            "url": "https://github.com/Zss1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MCnZD",
          "body": "可以使用双指针法，注意去重；\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> threeSum(vector<int>& nums) {\r\n        vector<vector<int>> ans;\r\n        if(nums.empty() || nums.size()<3)\r\n            return ans;\r\n\r\n        sort(nums.begin(), nums.end());\r\n\r\n        for(int i=0; i<nums.size(); i++){\r\n            if(i==0 || (i>0&&nums[i]!=nums[i-1])){\r\n                int left = i+1;\r\n                int right = nums.size()-1;\r\n                while(left<right){\r\n                    int s = nums[i]+nums[left]+nums[right];\r\n                    if(s<0){\r\n                        left++;\r\n                    }else if(s>0) {\r\n                        right--;\r\n                    }else{\r\n                        ans.push_back({nums[i], nums[left], nums[right]});\r\n                        while(left<right && nums[left]==nums[left+1]){  // 找到下一个不相等的下标，为了去重\r\n                            left++;\r\n                        }\r\n                        while(left<right && nums[right]==nums[right-1]){ // 找到下一个不相等的下标，为了去重\r\n                            right--;\r\n                        }\r\n                        left++;\r\n                        right--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n参考：[【LeetCode-数组】三数之和 - Flix - 博客园](https://www.cnblogs.com/flix/p/12651825.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Zss1990",
            "url": "https://github.com/Zss1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk2MjY5NjQ=",
    "number": 178,
    "title": "【Q177】如何在 url 中传递数组",
    "body": "可以参考 [arrays in query params](https://medium.com/raml-api/arrays-in-query-params-33189628fa68)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0NDQwMjE0Ng==",
          "body": "在 URL 中如何传递数组这种复杂的数据，完全**取决于项目中前后端成员关于复杂数据在 URL 中传输的约定**，一般情况下可以使用以下方式来传递数组\r\n\r\n``` js\r\na=3&a=4&a=5\r\n\r\na=3,4,5\r\n\r\na[]=3&a[]=4&a[]=5\r\n\r\na[0]=3&a[1]=4&a[2]=5\r\n```\r\n\r\n但同样，需要后端开发者写一个 `querystring.parse` 来对指定的格式解析进行支持，同时也有对各种复杂 qs 支持较好的 package，比如：\r\n\r\n+ [qs: 据说是对 querystring 复杂对象解析最好的库](https://github.com/ljharb/qs#parsing-arrays)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAwMjQ0NjM=",
    "number": 179,
    "title": "【Q178】如何使用 css 写一个有 3D 效果的立方体",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjQ0NDE0Mw==",
          "body": "`<div class=\"warp\">\r\n\t<div class=\"box box1\">1</div>\r\n    <div class=\"box box2\">2</div>\r\n    <div class=\"box box3\">3</div>\r\n    <div class=\"box box4\">4</div>\r\n    <div class=\"box box5\">5</div>\r\n    <div class=\"box box6\">6</div>\r\n</div>`\r\n`* {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n}\r\n\r\nbody {\r\n\tperspective: none;\r\n\tperspective-origin: 50% 50%;\r\n}\r\n\r\n.warp {\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tmargin: 100px auto;\r\n\t\r\n\tposition: relative;\r\n\t\r\n\ttransform-style: preserve-3d;\r\n\t\r\n\ttransform: rotateX(45deg) rotateY(45deg);\r\n\t\r\n\tanimation: play 5s linear infinite;\r\n}\r\n\r\n.box {\r\n\twidth: 200px;\r\n\theight: 200px;\r\n\tborder: 2px solid #ccc;\r\n\t\r\n\ttext-align: center;\r\n\tline-height: 200px;\r\n\tfont-size: 150px;\r\n\tfont-weight: bold;\r\n\tcolor: #fff;\r\n\t\r\n\tposition: absolute;\r\n\ttop: 150px;\r\n\tleft: 150px;\r\n}\r\n\r\n.box1 {\r\n\tbackground: rgba(135,135,135,.3);\r\n\ttransform: rotateY(90deg) translateZ(100px);\r\n}\r\n\r\n.box2 {\r\n\tbackground: rgba(135,0,255,.3);\r\n\ttransform: rotateY(90deg) translateZ(-100px);\r\n}\r\n\r\n.box3 {\r\n\tbackground: rgba(255,125,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(-100px);\r\n}\r\n\r\n.box4 {\r\n\tbackground: rgba(125,255,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(100px);\r\n}\r\n\r\n.box5 {\r\n\tbackground: rgba(30,150,189,.3);\r\n\ttransform: translateZ(100px);\r\n}\r\n\r\n.box6 {\r\n\tbackground: rgba(169,150,189,.3);\r\n\ttransform: translateZ(-100px);\r\n}\r\n\r\n@keyframes play {\r\n\tfrom{ transform: rotateX(0) rotateY(0) rotateZ(0);}\r\n\tto {transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg);}\r\n}`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lihan1k",
            "url": "https://github.com/lihan1k"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAxNzM3ODM=",
    "number": 180,
    "title": "【Q179】ssh 如何设置 IP whiteList",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAyNDUxMTk=",
    "number": 181,
    "title": "【Q180】当执行 SQL 语句 select * from user where id = 1 时发什么了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stbGB",
          "body": "当执行SQL语句时，一般数据库引擎会先解析SQL语句，然后根据字段索引对操作进行优化，选择最优的路径（例如当你设了索引，当数据量比较小的时候数据库会使用全表扫描而非索引），然后执行查询，收集结果并返回。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTA4NjI4NDc=",
    "number": 182,
    "title": "【Q181】如何实现 compose 函数，进行函数合成",
    "body": "实现一个 compose 函数，进行函数合成，比如 redux 中的 compose，react 高阶组件连续调用时的 compose\r\n\r\n\r\n``` js\r\nconst add10 = x => x + 10\r\nconst mul10 = x => x * 10\r\nconst add100 = x => x + 100\r\n\r\n// (10 + 100) * 10 + 10 = 1110\r\ncompose(add10, mul10, add100)(10)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MTU2NDM1NA==",
          "body": "```\r\nfunction compose() {\r\n\r\n  let fns = [...arguments];\r\n\r\n  return function() {\r\n    let args = [...arguments];\r\n    let result = fns.reduce((ret, fn) => {\r\n      ret = fn.apply(this, ret);\r\n      return Array.isArray(ret) ? ret : [ret];\r\n    }, args);\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nlet toUpperCase = (x) => x.toUpperCase();\r\nlet exclaim = (x) => x + '!';\r\nlet shout = compose(toUpperCase,exclaim);\r\nlet str = shout('hello world');\r\nconsole.log(str);\r\n```\r\n\r\n第一次试着写，简单查了一下compose是什么意思，竟然拼凑出来了。请各位指正。  :smile:",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "RainMaker-Q",
            "url": "https://github.com/RainMaker-Q"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NDcyNTg3NQ==",
          "body": "看到一种新实现  \r\n```\r\nfunction compose(...fns) {\r\n  fns.reduce( (a, b) => (...args) => a(b(...args)));\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "RainMaker-Q",
            "url": "https://github.com/RainMaker-Q"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczNTg4OTQ5OQ==",
          "body": "const compose = (...fns) => (...params) => fns.reduce((prev, current) => current(prev), ...params);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nieyao",
            "url": "https://github.com/nieyao"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MTU1MDAwNA==",
          "body": "实现一个**从右向左**(right to left)计算的组合函数:\r\n\r\n``` js\r\nconst compose = (...fns) =>\r\n  // 注意 f、g 的位置，如果实现从左到右计算，则置换顺序\r\n  fns.reduce((f, g) => (...args) => f(g(...args)))\r\n```\r\n\r\n跑一个示例\r\n\r\n``` js\r\nconst add5 = x => x + 5\r\nconst multiply = (x) => x * 10\r\nconst multiply10AndAdd5 = compose(\r\n  add5,\r\n  multiply\r\n)\r\nmultiply10AndAdd5(10) // 105\r\n```\r\n\r\n在 `Redux` 中广泛使用了 `compose` 函数，其中的实现如下\r\n\r\n+ [源码位置](https://github.com/reduxjs/redux/blob/master/src/compose.ts)\r\n\r\n``` ts\r\nexport default function compose(...funcs: Function[]) {\r\n  if (funcs.length === 0) {\r\n    // infer the argument type so it is usable in inference down the line\r\n    return <T>(arg: T) => arg\r\n  }\r\n\r\n  if (funcs.length === 1) {\r\n    return funcs[0]\r\n  }\r\n\r\n  return funcs.reduce((a, b) => (...args: any) => a(b(...args)))\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MTU1MDExMw==",
          "body": "@nieyao params 应该置后，测试示例时没有通过",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MTU1NzIzMg==",
          "body": "> @nieyao params 应该置后，测试示例时没有通过\r\n\r\n确实，忘了compose是从右往左执行的，那加个reverse 好了。\r\nconst compose = (...fns) => (...params) => fns.reverse().reduce((prev, current) => current(prev), ...params)\r\n或者用reduceRight\r\nconst compose = (...fns) => (...params) => fns.reduceRight((prev, current) => current(prev), ...params)\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "nieyao",
            "url": "https://github.com/nieyao"
          }
        },
        {
          "id": "IC_kwDODQzyOs40lroO",
          "body": "```js\r\nfunction compose(...fn) {\r\n  return (...args) => fn.reverse().slice(1).reduce((acc, cur) => cur(acc), fn[0](...args))\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "IC_kwDODQzyOs5F8Zwq",
          "body": "这种方式更优雅\r\n```js\r\nconst compose = (...fns) =>\r\n  fns.reduceRight(\r\n    (prev, next) =>\r\n      (...args) =>\r\n        prev(next(...args))\r\n  );\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maolovecoding",
            "url": "https://github.com/maolovecoding"
          }
        },
        {
          "id": "IC_kwDODQzyOs5XHUJC",
          "body": "之前看了koa的compose实现，先入为主了，感觉写的没上面的优雅，不过能过用例：\r\n```js\r\nfunction compose(...args) {\r\n  const length = args.length;\r\n  function dispatch(index, val) {\r\n    if (index === length) return val;\r\n    else {\r\n      args = args || [];\r\n      return args[index](dispatch(index + 1, val));\r\n    }\r\n  }\r\n  return (init) => dispatch(0, init);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kirazZ1",
            "url": "https://github.com/kirazZ1"
          }
        },
        {
          "id": "IC_kwDODQzyOs5giMeD",
          "body": "```js\r\n const compose = (...fns) => ((params) => fns.reduce((prev, cur) => (prev = cur(prev ?? params), prev), null))\r\n```\r\n看了大佬的实现，感觉我的实现突然不香了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyNzc0MDg=",
    "number": 183,
    "title": "【Q182】简述 TCP 的四次挥手，三次挥手可以吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTU3MjAwNQ==",
          "body": "第一次挥手 客户端 发送 fin 给服务端 \r\n第二次回收 服务端 发送 ack 给客户端\r\n中间服务端 可能还有数据传输\r\n第三次挥手 服务端 发送 fin 给客户端\r\n第四次挥手 客户端 发送 ack 给 客户端\r\n上述四个挥手 分别 类比 两人再打电话\r\nA对B说 我说完了\r\nB对A说 我知道了\r\n中间 b还有话说\r\nB再对A说 我也说完了\r\nA再对B说 我知道了\r\n双方挂断电话\r\n\r\n如果只有两次 即A对B说我说完了 而没有ack, A不确定B是否知道\"A我说完了\"这句话B听到没有\r\n同理,第三次挥手 B对A说我说完了, 还没等A回答我知道了就挂断,有可能A不知道B已经说完.\r\n\r\ntcp协议之所以可靠 就是由于 三次握手四次挥手 建立的连接, 以及ack回执机制,\r\n如果传输过程中连接断开 又会重新三次握手建立连接, 如果一直没收到ack, 发送方会一直发送相同的消息,等待另一方发ack回执回来",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manondidi",
            "url": "https://github.com/manondidi"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTg1ODM4MQ==",
          "body": "> 第一次挥手 客户端 发送 fin 给服务端\r\n> 第二次回收 服务端 发送 ack 给客户端\r\n> 中间服务端 可能还有数据传输\r\n> 第三次挥手 服务端 发送 fin 给客户端\r\n> 第四次挥手 客户端 发送 ack 给 客户端\r\n> 上述四个挥手 分别 类比 两人再打电话\r\n> A对B说 我说完了\r\n> B对A说 我知道了\r\n> 中间 b还有话说\r\n> B再对A说 我也说完了\r\n> A再对B说 我知道了\r\n> 双方挂断电话\r\n> \r\n> 如果只有两次 即A对B说我说完了 而没有ack, A不确定B是否知道\"A我说完了\"这句话B听到没有\r\n> 同理,第三次挥手 B对A说我说完了, 还没等A回答我知道了就挂断,有可能A不知道B已经说完.\r\n> \r\n> tcp协议之所以可靠 就是由于 三次握手四次挥手 建立的连接, 以及ack回执机制,\r\n> 如果传输过程中连接断开 又会重新三次握手建立连接, 如果一直没收到ack, 发送方会一直发送相同的消息,等待另一方发ack回执回来\r\n\r\n\r\n1.A对B说 我说完了\r\n2.B对A说 我知道了\r\n  中间 b还有话说\r\n3.B再对A说 我也说完了\r\n4.A再对B说 我知道了\r\n双方挂断电话\r\n\r\n题主 把 两次挥手改成三次挥手了,我还是拿挂电话的例子\r\n如果步骤4没了 就挂断,那么 B不确定A是否收到 B已经说完了, 而直接挂断\r\n,如果A没收到 A将会一直等待\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manondidi",
            "url": "https://github.com/manondidi"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_QSFK",
          "body": "第一次：客户端通知服务端我要结束了\r\n第二次：服务端告诉客户端我知道了\r\n第三次：服务端通知客户端我准备好了\r\n第四次：客户端通知服务端表示我知道了\r\n\r\n-- update 3月31日 --\r\n三次握手还有确认哪条连接的作用(根据ACK) ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "changshou83",
            "url": "https://github.com/changshou83"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyOTEwMjA=",
    "number": 184,
    "title": "【Q183】tcp 中 time_wait 堆积过多会有什么问题，为什么它超时时间这么长",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_QTcq",
          "body": "会占用大量网络资源(接口)，导致网络响应卡顿。超时时间长是为了有足够的时间确保客户端能接受到消息",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "changshou83",
            "url": "https://github.com/changshou83"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE3NzQ4OTE=",
    "number": 185,
    "title": "【Q184】有没有使用过 css variable，它解决了哪些问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTY3ODE3MQ==",
          "body": "css变量减少样式重复定义，比如同一个颜色值要在多个地方重复使用，以前通过less和sass预处理做到，现在css变量也可以做到，方便维护，提高可读性\r\n```\r\n:root{\r\n  --bgcolor: blue;\r\n  --color: red;\r\n}\r\np {\r\n  color: var(--color);\r\n}\r\ndiv {\r\n  backgroung-color: var(--bgcolor);\r\n  color: var(--color)\r\n}\r\n```\r\n在媒体查询中使用，精简代码，减少冗余\r\n```\r\n.box {\r\n  --base-size: 10;\r\n  width: calc(var(--base-size)* 10px);\r\n  height: clac(var(--base-size)* 5px);\r\n  padding:calc(var(--base-size) * 1px);\r\n}\r\n@media screen and (min-width: 1480px) {\r\n  .box{\r\n    --base-size: 8;\r\n  }\r\n}\r\n```\r\n方便在js中使用\r\n```\r\n// 设置变量\r\ndocument.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n// 读取变量\r\ndoucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n// 删除变量\r\ndocument.getElementById('box').style.removeProperty('--color')\r\n```",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "Cicelychen",
            "url": "https://github.com/Cicelychen"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTcwNDM4OA==",
          "body": "可在运行时控制 CSS 逻辑，与 less/sass 相比，更加灵活，因为它很容易通过 JS 来控制。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI4Njc2Nw==",
          "body": "补充两个用途：\r\n\r\n1. 可以减少 JavaScript 对 DOM 的介入，制作性能更高的动画\r\n2. 配合 content 等通过 CSS 给 JS 传参，得到一些通过 JavaScript 难以获取的参数\r\n\r\nhttps://www.zhangxinxu.com/wordpress/tag/css-var/",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3NTIyMzMxMQ==",
          "body": "对浏览器兼容性有要求吗",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liusshuai",
            "url": "https://github.com/liusshuai"
          }
        },
        {
          "id": "IC_kwDODQzyOs44ooXn",
          "body": "> 对浏览器兼容性有要求吗\r\n\r\n现在主流浏览器都支持了，可以 MDN 或者 Can I use 里面自己查一下",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Ww6P2",
          "body": "> css变量减少样式重复定义，比如同一个颜色值要在多个地方重复使用，以前通过less和sass预处理做到，现在css变量也可以做到，方便维护，提高可读性\r\n> \r\n> ```\r\n> :root{\r\n>   --bgcolor: blue;\r\n>   --color: red;\r\n> }\r\n> p {\r\n>   color: var(--color);\r\n> }\r\n> div {\r\n>   backgroung-color: var(--bgcolor);\r\n>   color: var(--color)\r\n> }\r\n> ```\r\n> \r\n> 在媒体查询中使用，精简代码，减少冗余\r\n> \r\n> ```\r\n> .box {\r\n>   --base-size: 10;\r\n>   width: calc(var(--base-size)* 10px);\r\n>   height: clac(var(--base-size)* 5px);\r\n>   padding:calc(var(--base-size) * 1px);\r\n> }\r\n> @media screen and (min-width: 1480px) {\r\n>   .box{\r\n>     --base-size: 8;\r\n>   }\r\n> }\r\n> ```\r\n> \r\n> 方便在js中使用\r\n> \r\n> ```\r\n> // 设置变量\r\n> document.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n> // 读取变量\r\n> doucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n> // 删除变量\r\n> document.getElementById('box').style.removeProperty('--color')\r\n> ```\r\n\r\ndocument.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n这句 **setPropertyValue** 是不是写错了，我在 MDN 上只看到了 **setProperty** 这个 API\r\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration/setProperty\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhengaimin",
            "url": "https://github.com/zhengaimin"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lOunG",
          "body": "document.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n// 读取变量\r\ndoucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n\r\n\r\nset的时候不加Value get的时候加Value。。。。。(●'◡'●)\r\n\r\n正确写法：\r\ndocument.getElementById(\"box\").style.setProperty('--color', 'pink')\r\n// 读取变量\r\ndoucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n// 删除变量\r\ndocument.getElementById('box').style.removeProperty('--color')",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Jupiter-u",
            "url": "https://github.com/Jupiter-u"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lQQ-Z",
          "body": "@Jupiter-u 确实如此，这种用法实在是太难记了。\r\n\r\n> 哦对，你的回答中的代码可以通过 ``` 包裹，可以使其语法高亮。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE3ODAwOTM=",
    "number": 186,
    "title": "【Q185】谈谈你对 styled-component 的看法",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjA3MzM3Nw==",
          "body": "最为流行的 CSS-in-JS 方案",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-jZGf",
          "body": "优点： 可维护性高， 易读性好， 可抽象， 可扩展性好。\r\n\r\n缺点： runtime   对性能有一定的影响。 不能直接用postcss\r\n\r\n生态: \r\n\r\ntwin.macos  tailwind\r\n\r\n[babel-plugin-styled-components](https://link.juejin.cn/?target=https%3A%2F%2Fstyled-components.com%2Fdocs%2Ftooling%23better-debugging)   解决 className是名随机字符串的问题\r\n\r\n[typescript-styled-components-px2rem](https://github.com/xuyuanxiang/typescript-styled-components-px2rem)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "leeleoo",
            "url": "https://github.com/leeleoo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE5MTYyNTY=",
    "number": 187,
    "title": "【Q186】写一个关于全排列，全组合的函数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NjAwMTMxOA==",
          "body": "## `Arragement`\r\n\r\n## `Combination`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40-tEH",
          "body": "全排列\r\n```js\r\n/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\n var permute = function(nums) {\r\n  let result = [];\r\n  let used = Array.from({ length: nums.length }).fill(false);\r\n  function search(collection, used) {\r\n    if (collection.length === nums.length) {\r\n      result.push(collection);\r\n      return;\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n      if (used[i] === false) {\r\n        used[i] = true;\r\n        search(collection.concat(nums[i]), used.slice(0));\r\n        used[i] = false; // 重置状态\r\n      }\r\n    }\r\n    collection = null;\r\n    used = null;\r\n  }\r\n  search([], used);\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs40-wNu",
          "body": "全组合:\r\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\r\n```js\r\nvar combine = function(n, k) {\r\n  let result = [];\r\n  function find(collection, from) {\r\n    if (collection.length === k) {\r\n      result.push(collection);\r\n      return;\r\n    }\r\n    for (let i = from; i <= n; i++) {\r\n      find(collection.concat(i), i + 1);\r\n    }\r\n  }\r\n  find([], 1);\r\n  return result;\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTIyOTkyODU=",
    "number": 188,
    "title": "【Q187】当编辑 graphql 的 query 时，如何在编辑器中自动补全",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTUwNTI0NjY=",
    "number": 189,
    "title": "【Q188】大数乘法和大数加法",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40xWcg",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs408d0r",
          "body": "```js\r\nvar multiply = function(num1, num2) {\r\n    if (num1 === '0' || num2 === '0') {\r\n        return '0';\r\n    }\r\n    let num1s = num1.split('');\r\n    let num2s = num2.split('');\r\n    num1s.reverse();\r\n    num2s.reverse();\r\n\r\n    function add(a, b) {\r\n        a = a.split('').reverse();\r\n        b = b.split('').reverse();\r\n        let len = Math.max(a.length, b.length);\r\n        let c = 0;\r\n        let r = [];\r\n        for (let i = 0; i < len; i++) {\r\n            let d = Number(a[i] || 0) + Number(b[i] || 0) + c;\r\n            let e = 0;\r\n            if (d >= 10) {\r\n                e = d - 10;\r\n                c = 1;\r\n            } else {\r\n                e = d;\r\n                c = 0\r\n            }\r\n            r[i] = e;\r\n        }\r\n        if (c === 1) {\r\n            r[r.length] = 1;\r\n        }\r\n        return r.reverse().join('');\r\n    }\r\n    let results = [];\r\n    for(let i = 0; i < num1s.length; i++) {\r\n        for (let j = 0; j < num2s.length; j++) {\r\n            let zero = Array.from({ length: i + j }).fill(0).join('');\r\n            results.push(Number(num1s[i]) * Number(num2s[j]) + zero);\r\n        }\r\n    }\r\n    return results.reduce((acc, c) => {\r\n        return add(acc, c);\r\n    });\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU0Mjk3NTE=",
    "number": 190,
    "title": "【Q189】performance API 中什么指标可以衡量首屏时间",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczNjU2ODYxOA==",
          "body": "window.performance.timing,详细的可以看下这篇文章[前端性能优化衡量指标](https://serverless-action.com/fontend/fe-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87.html#performance-api)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nieyao",
            "url": "https://github.com/nieyao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1MjcyMDY=",
    "number": 191,
    "title": "【Q190】使用 CSS 如何画一个三角形",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTQ0NDc2OA==",
          "body": "`\r\n.triangle {\r\n    width: 0px;\r\n    height: 0px;\r\n    border: 100px solid;\r\n    border-color: transparent transparent rgba(134, 241, 143,1) transparent;\r\n}\r\n`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Sumarina",
            "url": "https://github.com/Sumarina"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyNDY3NzQxOA==",
          "body": "`.container{\r\nwidth: 0; height:0;\r\nborder-color: transparent;\r\nborder-left: 100px solid #f00;\r\n}`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "canddyBrea",
            "url": "https://github.com/canddyBrea"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjI2OTE4OQ==",
          "body": "```\r\n    .triangle {\r\n      width: 0;\r\n      border: 100px solid transparent;\r\n      border-bottom: 100px solid rgba(66, 142, 212, 0.4);\r\n    }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Innocentw",
            "url": "https://github.com/Innocentw"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_AUqe",
          "body": "```js\r\n .container{\r\nwidth:0;\r\nborder:100px solid transparent;\r\nborder-bottom-color:#000;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "wangliang000",
            "url": "https://github.com/wangliang000"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DKFvi",
          "body": "```css\r\n\r\n        .triangle {\r\n            margin: 0 auto;\r\n            width: 50vh;\r\n            height: 50vh;\r\n            background-color: aqua;\r\n            /* \r\n                画多边形： \r\n                polygon(x y, x y, ...)\r\n                一组 x y, 代表一个点\r\n                x: 往右增加\r\n                y: 往下增加\r\n            */\r\n            clip-path: polygon(0 0, 0% 100%, 100% 100%);\r\n        }\r\n\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/67412196/168428607-1624ada6-1e52-49a8-981e-f21609023351.png)\r\n\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "cy948",
            "url": "https://github.com/cy948"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FhIcq",
          "body": "```html\r\n.box {\r\n    width: 0;\r\n    height: 0;\r\n    border:100px solid transparent;\r\n    border-bottom-color: blue;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zjunbin1286",
            "url": "https://github.com/zjunbin1286"
          }
        },
        {
          "id": "IC_kwDODQzyOs5k6Bkp",
          "body": "CSS实现三角形的核心，在于设置元素宽高为0，宽高由border撑起，设置其他三个border为透明\r\nhttps://stackblitz.com/edit/web-platform-nkudf7?file=index.html,styles.css",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Neisun",
            "url": "https://github.com/Neisun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1NDIxNjg=",
    "number": 192,
    "title": "【Q191】什么是 Open Graph 协议，用来做什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NTI0NjQwNQ==",
          "body": "Open Graph 协议可以让任何一个网页集成到社交图谱中。例如，facebook就是一种社交图谱(social graph)。\r\n一旦一个网页按照该协议进行集成，这个网页就像是社交图谱的一个节点，例如，你的网页集成了open graph协议，\r\n按照协议加入了网页的标题，描述以及图片信息等等，那么你在facebook中分享这个网页的时候，facebook就会按照\r\n你定义的内容来展示这个网页。\r\n\r\n这个协议其实很简单，主要是通过在html中加入一些元数据（meta）标签来实现，例如\r\n在head中加入meta标签，property是以og(open graph)开头, 后面跟着具体属性，content里面是属性的值，\r\n下面这段描述的就是一个类型为 video.movie，标题为 The rock，以及url和图片信息。这个例子就可以当做是\r\n为 https://www.imdb.com/title/tt0117500/ 实现了Open Graph协议、\r\n\r\n```\r\n<html prefix=\"og: http://ogp.me/ns#\">\r\n<head>\r\n<title>The Rock (1996)</title>\r\n<meta property=\"og:title\" content=\"The Rock\" />\r\n<meta property=\"og:type\" content=\"video.movie\" />\r\n<meta property=\"og:url\" content=\"http://www.imdb.com/title/tt0117500/\" />\r\n<meta property=\"og:image\" content=\"http://ia.media-imdb.com/images/rock.jpg\" />\r\n...\r\n</head>\r\n...\r\n</html>\r\n```\r\n结论：\r\n这个协议主要是Facebook提出来的，为了更好的展示用户分享的网页的内容，实现这个协议，有助于SEO优化，告诉google该网页有哪些内容，以及关键词等。\r\n\r\n可以快速实现Open Graph协议的工具有：\r\nWordpress的SEO plugin\r\n使用Facebook的Facebook Page功能\r\n\r\n \r\nReference:\r\n1. The Open Graph Protocol https://ogp.me/\r\n2. Open Graph Protocol for Facebook Explained with Examples  https://www.optimizesmart.com/how-to-use-open-graph-protocol/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "grace-shi",
            "url": "https://github.com/grace-shi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTg1MjgwMzI=",
    "number": 193,
    "title": "【Q192】简述你们前端项目中资源的缓存配置策略",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5T9746",
          "body": "1. html设置协商缓存\r\n2. 静态资源 hash + 强缓存",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jayyoonn",
            "url": "https://github.com/jayyoonn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjAyNzUyNzM=",
    "number": 194,
    "title": "【Q193】如何加速 npm install",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzQyOTg5Mw==",
          "body": "换成taobao源?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CaicoLeung",
            "url": "https://github.com/CaicoLeung"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY5MzEyNTc1Mg==",
          "body": "可以直接使用淘宝源，使用以下命令切换淘宝源：\r\n`npm config set registry=https://registry.npm.taobao.org`\r\n\r\n另外不建议直接使用 cnpm，实际使用中发现会遇到很多奇怪的错误。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "inlym",
            "url": "https://github.com/inlym"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTU1MTExNw==",
          "body": "可以使用**nrm**进行npm不同源的切换\r\nhttps://github.com/Pana/nrm\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wjw-gavin",
            "url": "https://github.com/wjw-gavin"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyMzI4MDgzNw==",
          "body": "1. 选择时延低的 registry，需要企业技术基础建设支持\r\n1. `NODE_ENV=production`，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)\r\n1. `CI=true`，npm 会在此环境变量下自动优化\r\n1. 结合 CI 的缓存功能，充分利用 `npm cache`\r\n1. 使用 `npm ci` 代替 `npm i`，既提升速度又保障应用安全性",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c2Tf",
          "body": "科学上网，镜像，使用pnpm",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjAzMjk5NTM=",
    "number": 195,
    "title": "【Q194】npm i 与 npm ci 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTcwOTcwOQ==",
          "body": "npm ci  (6.0版本以上)\r\n   1。会删除项目中的 `node_modules` 文件夹；\r\n   2.  会依照项目中的`package.json` 来安装确切版本的依赖项；\r\n   3. 不像 npm install, `npm ci` 不会修改你的 `package-lock.json` 但是它确实期望你的项目中有一个 - package-lock.json 文件 - 如果你没有这个文件， npm ci 将不起作用，此时必须使用 npm install",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fariellany",
            "url": "https://github.com/fariellany"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjA0NjEwNzY=",
    "number": 196,
    "title": "【Q195】package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MjMzMzYyNg==",
          "body": "`packagelock.json`/`yarn.lock` 用以锁定版本号，保证开发环境与生产环境的一致性，避免出现不兼容 API 导致生产环境报错\r\n\r\n在这个问题之前，需要了解下什么是 `semver`: [什么是 semver](https://github.com/shfshanyue/Daily-Question/issues/534)。\r\n\r\n当我们在 `npm i` 某个依赖时，默认的版本号是最新版本号 `^1.2.3`，以 `^` 开头可最大限度地使用新特性，但是某些库不遵循该依赖可能出现问题。\r\n\r\n> `^1.2.3` 指 *>=1.2.3 <2.0.0*，可查看 [semver checker](https://devtool.tech/semver)\r\n\r\n*一个问题: 当项目中没有 lock 文件时，生产环境的风险是如何产生的?*\r\n\r\n演示风险过程如下:\r\n\r\n1. `pkg 1.2.3`: 首次在开发环境安装 pkg 库，为此时最新版本 `1.2.3`，`dependencies` 依赖中显示 `^1.2.3`，实际安装版本为 `1.2.3`\r\n1. `pkg 1.19.0`: 在生产环境中上线项目，安装 pkg 库，此时最新版本为 `1.19.0`，满足 `dependencies` 中依赖 `^1.2.3` 范围，实际安装版本为 `1.19.0`，**但是 `pkg` 未遵从 semver 规范，在此过程中引入了 Breaking Change，如何此时 `1.19.0` 有问题的话，那生产环境中的 `1.19.0` 将会导致 bug，且难以调试**\r\n\r\n而当有了 lock 文件时，每一个依赖的版本号都被锁死在了 lock 文件，每次依赖安装的版本号都从 lock 文件中进行获取，避免了不可测的依赖风险。\r\n\r\n1. `pkg 1.2.3`: 首次在开发环境安装 pkg 库，为此时最新版本 `1.2.3`，`dependencies` 依赖中显示 `^1.2.3`，实际安装版本为 `1.2.3`，**在 lock 中被锁定版本号**\r\n1. `pkg 1.2.3`: 在生产环境中上线项目，安装 pkg 库，此时 lock 文件中版本号为 `1.2.3`，符合 `dependencies` 中 `^1.2.3` 的范围，将在生产环境安装 `1.2.3`，完美上线。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI1OTIxMjI=",
    "number": 197,
    "title": "【Q196】前端中遇到过处理二进制的场景吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzg2NDA4MA==",
          "body": "[JavaScript二进制数据处理](http://coinfaces.me/posts/handling-binary-data-using-javascript/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rex-ll",
            "url": "https://github.com/rex-ll"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI5NDk1Nw==",
          "body": "1. 读取二进制文件，绘制波形图。\r\n2. 文件转储。",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI2NDMyNTU=",
    "number": 198,
    "title": "【Q197】什么是 TypedArray",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs408Xzx",
          "body": "[ArrayBuffer，二进制数组](https://zh.javascript.info/arraybuffer-binary-arrays)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjMxNzkxMDU=",
    "number": 199,
    "title": "【Q198】如何实现类似 lodash.get 函数",
    "body": "使用 `get` 函数可避免长链的 key 时获取不到属性而出现问题，此时进行异常避免时及其服务，如 `o.a && o.a.b && o.a.b.c && o.a.b.c.d`\r\n\r\n实现类似[lodash.get](https://lodash.com/docs/4.17.15#get)，有以下测试用例:\r\n\r\n``` js\r\nconst object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n \r\n//=> 3\r\nget(object, 'a[0].b.c');\r\n\r\n//=> 3\r\nget(object, 'a[0][\"b\"][\"c\"]')\r\n\r\n//=> 10086\r\nget(object, 'a[100].b.c', 10086);\r\n```\r\n\r\n问题追问:\r\n\r\n**1. 如何使用 ts 写法来实现 lodash.get 函数？**",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NDU0MjMzNA==",
          "body": "function lodashGet(obj,exps){\r\n    if(typeof exps !== 'string') return obj\r\n    if(typeof obj !== 'object') return obj\r\n   let res = obj\r\n   const arr = exps.split('.')\r\n    for(let i=0;i<arr.length;i++){\r\n        const exp = arr[i]\r\n        if(res[exp]){\r\n        res = res[exp]\r\n        } else{\r\n        return undefined\r\n        }\r\n    }\r\nreturn res\r\n}\r\n\r\nvar obj = {test:{arr:[{name:1}]}}\r\n\r\n\r\nlodashGet(obj,'test.arr.0.name')\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "miaooow",
            "url": "https://github.com/miaooow"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1OTU2MjI5MQ==",
          "body": "代码见 [如何实现类似 lodash.get 函数 - codepen](https://codepen.io/shanyue/pen/jOmxwMv?editors=0012)\r\n\r\n``` js\r\nfunction get (source, path, defaultValue = undefined) {\r\n  // a[3].b -> a.3.b -> [a, 3, b]\r\n  const paths = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/\\[\"(\\w+)\"\\]/g, '.$1').replace(/\\['(\\w+)'\\]/g, '.$1').split('.')\r\n  let result = source\r\n  for (const p of paths) {\r\n    result = result?.[p]\r\n  }\r\n  return result === undefined ? defaultValue : result \r\n}\r\n```\r\n\r\n``` js\r\nconst object = { a: [{ b: { c: 3 } }] };\r\nconst result = _.get(object, 'a[0].b.c', 1); \r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs408Xof",
          "body": "```js\r\nfunction getValue(context, path, defaultValue) {\r\n  if (Object.prototype.toString.call(context) !== '[object Object]'\r\n    && Object.prototype.toString.call(context) !== '[object Array]') {\r\n    return context;\r\n  }\r\n  let paths = [];\r\n  if (Array.isArray(path)) {\r\n    paths = [...path];\r\n  } else if (Object.prototype.toString.call(path) === '[object String]') {\r\n    paths = path.replace(/\\[/g, '.').replace(/\\]/g, '').split('.').filter(Boolean);\r\n  } else {\r\n    paths = [String(path)];\r\n  }\r\n  let result = undefined;\r\n  for (let i = 0; i < paths.length; i++) {\r\n    const key = paths[i];\r\n    result = result ? result[key] : context[key];\r\n    if (result !== null && typeof result !== 'undefined') {\r\n      continue;\r\n    }\r\n    return defaultValue || undefined;\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs41EQga",
          "body": "\r\n\r\n```javascript\r\n// 其实原本是按照lodash实现的 但是这里有个差异是如果属性存在就返回其实没有把目标元素是`undefined`的时候设置回default\r\nfunction get (arm, params = '', defaultVal) {\r\n    if (typeof params !== 'string' && !Array.isArray(params)) {\r\n        throw new Error(`${params} is not string or array`)\r\n    }\r\n    if (!Array.isArray(params)) {\r\n        params = params.split(/\\].|[\\[.]/)\r\n    }\r\n    for (let i = 0; i < params.length; i++) {\r\n        if (Object.prototype.hasOwnProperty.call(arm, params[i])) {\r\n            arm = arm[params[i]]\r\n        } else {\r\n            return defaultVal\r\n        }\r\n    }\r\n    return arm\r\n}\r\n\r\nfunction get (obj, keyStr, defVal = undefined) {\r\n    let matchArr = Array.from(keyStr.matchAll(/(\\[).*?(\\])|(?<=\\.).*?(?=\\.)|(?<=\\.).*?$/g))\r\n    let val = obj\r\n    for (let i = 0; i < matchArr.length; i++) {\r\n        if (typeof val === 'object' && val !== null || typeof val === 'function') {\r\n            let key = matchArr[i][0]\r\n            if (key[0] === '[') {\r\n                key = key.slice(1, key.length - 1)\r\n            }\r\n            val = obj[key]\r\n        } else {\r\n            return defVal\r\n        }\r\n    }\r\n    if (val === undefined) {\r\n        return defVal\r\n    } else {\r\n        return val\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n```typescript\r\n\r\ntype strToPoint<S> =\r\n    S extends `${infer F}[\"${infer M}`  ? strToPoint<`${F}.${M}`> :\r\n        S extends `${infer F}\"]${infer M}`  ? strToPoint<`${F}${M}`> :\r\n            S extends `${infer F}['${infer M}`  ? strToPoint<`${F}.${M}`> :\r\n                S extends `${infer F}']${infer M}`  ? strToPoint<`${F}${M}`> :\r\n                    S extends `${infer F}[${infer M}`  ? strToPoint<`${F}.${M}`> :\r\n                        S extends `${infer F}]${infer M}`  ? strToPoint<`${F}${M}`> : S\r\n\r\ntype strPointToArr<S, A extends string[] = []> =\r\n    S extends `${infer F}.${infer M}`  ? strPointToArr<M, [...A, F]> :\r\n        S extends '' ? A : [...A, S]\r\n\r\n\r\ntype getReturnType<O extends unknown, K extends string[], D extends unknown = undefined> =\r\n    K extends [] ? O extends undefined ? D : O :\r\n        O extends Record<string, any> ? getReturnType<K[0] extends keyof O ? O[K[0]] : undefined, K extends [first:infer F, ...args: infer L] ? L : [] ,D > :\r\n            D\r\n\r\nlet obj = {\r\n    a: [1, 'lisi', {\r\n        b: {\r\n            c: 4\r\n        },\r\n        f: {\r\n            g: 'wangwu'\r\n        }\r\n    }]\r\n} as const\r\n\r\ntype get<O extends Record<string, any>, K extends string, Def extends unknown = undefined> =\r\n    (obj: O, keyStr: K, defVal: Def) => getReturnType<O, strPointToArr<strToPoint<K>>, Def>\r\n\r\n\r\ntype zz = get<typeof obj, 'a[2][b].c', '123'>\r\ntype zzz = get<typeof obj, 'd[e]', 'defaultVal'>\r\n\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs43XplT",
          "body": "```typescript\r\nconst lodashGet = (object: { [key: string]: any }, path: Array<string> | string, defaultValue?: any): any => {\r\n    let result: any\r\n    const findArrayPath = (path: Array<string>): any => {\r\n        if (path.length === 0) {\r\n            return result = defaultValue\r\n        }\r\n        result = object\r\n        for (const p of path) {\r\n            if (p in result) {\r\n                result = result[p]\r\n            } else {\r\n                result = defaultValue\r\n                break\r\n            }\r\n        }\r\n        return result\r\n    }\r\n    if (Array.isArray(path)) {\r\n        result = findArrayPath(path)\r\n    } else  {\r\n        path.replace\r\n        let normalizedPath = path.replace(/\\.|\\[|\\]/g, ' ').split(/\\s+/)\r\n        result = findArrayPath(normalizedPath)\r\n    }\r\n    return result\r\n}\r\n\r\nconst object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\r\nconsole.log(lodashGet(object, 'a[0].b.c'))\r\nconsole.log(lodashGet(object, ['a', '0', 'b', 'c']))\r\nconsole.log(lodashGet(object, 'a.b.c', 'default'))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs43hPtg",
          "body": "```javascript\r\nfunction get(obj, keys, defaultValue) {\r\n \r\n  let tempObj = obj;\r\n  let arr = [];\r\n  if (typeof keys === 'string') {\r\n    let key = '';\r\n    let index = 0;\r\n\r\n    while (index < keys.length) {\r\n      const k = keys[index];\r\n      if ((['[', '\\'', \"\\\"\", '.', ']']).includes(k)) {\r\n        if (key.length) {\r\n          arr.push(key);\r\n        }\r\n        key ='';\r\n      } else {\r\n        key  = key + k;\r\n      }\r\n      index = index +1;\r\n    }\r\n   key && arr.push(key);\r\n  } else {\r\n    arr = keys;\r\n  }\r\n\r\n  while (arr.length) {\r\n    tempObj = tempObj[arr.shift()]\r\n    if (tempObj === undefined || tempObj === null) {\r\n      return defaultValue;\r\n    }\r\n  }\r\n  return tempObj;\r\n\r\n}\r\n\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yazhouio",
            "url": "https://github.com/yazhouio"
          }
        },
        {
          "id": "IC_kwDODQzyOs5IYFlw",
          "body": "~~~js\r\nfunction get(obj, oriPath, defaultVal) {\r\n  const paths = oriPath.split(\".\");\r\n  const keys = [];\r\n  for (const path of paths) {\r\n    keys.push(...pathHandler(path));\r\n  }\r\n\r\n  let res = obj;\r\n  for (const key of keys) {\r\n    if (res[key] === undefined || res[key] === null) return defaultVal;\r\n    res = res[key];\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// 将 path 处理为能用的 keys\r\nfunction pathHandler(path) {\r\n  const res = [];\r\n  path = path.split(\"\");\r\n\r\n  let left = 0;\r\n  let right = 0;\r\n  let str = \"\";\r\n\r\n  while (left < path.length && right < path.length) {\r\n    if (path[left] === \"[\") {\r\n      right = left + 1;\r\n      while (path[right] !== \"]\") {\r\n        right++;\r\n      }\r\n      temp = path.slice(left + 1, right).join(\"\");\r\n\r\n      left = right + 1;\r\n      temp && res.push(temp);\r\n    } else {\r\n      str += path[left++];\r\n    }\r\n  }\r\n  res.unshift(str);\r\n\r\n  return res.map((item) => {\r\n    if (item[0] >= \"0\" && item[0] <= \"9\") {\r\n      // 转化为整数\r\n      return parseInt(item);\r\n    }\r\n    if (item.indexOf('\"') !== -1 || item.indexOf(\"'\") !== -1) {\r\n      // 去除两边的引号\r\n      return item.slice(1, item.length - 1);\r\n    }\r\n    return item;\r\n  });\r\n}\r\n~~~",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "4may-mcx",
            "url": "https://github.com/4may-mcx"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjQ0Mzk3Mzk=",
    "number": 200,
    "title": "【Q199】如何判断文件中的换行符是 LF 还是 CRLF",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg0MDM2MzU=",
    "number": 201,
    "title": "【Q200】前端如何进行多分支部署",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg2NTM0NTY=",
    "number": 202,
    "title": "【Q201】js 中什么是可选链操作符，如何访问数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU4OTQzODU3Mw==",
          "body": "> 文档见 [可选链操作符 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Optional_chaining) \r\n\r\n\r\n`?.` 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。\r\n\r\n``` javascript\r\nconst o = {}\r\n\r\n// 添加可选链之前\r\no && o.a && o.a.b && o.a.b.c && o.a.b.c.d\r\n\r\n// 添加可选链之后\r\no?.a?.b?.c?.d\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40yATa",
          "body": "```javascript\r\nconst obj = { a: [1, 2], b() {} }\r\n// 访问数组 \r\nobj?.a?.[0]\r\n//使用方法\r\nobj?.b?.()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1415333545",
            "url": "https://github.com/1415333545"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg5NTUzMjc=",
    "number": 203,
    "title": "【Q202】如何实现一个深拷贝 (cloneDeep)",
    "body": "``` js\r\nconst obj = {\r\n  re: /hello/,\r\n  f () {},\r\n  date: new Date(),\r\n  map: new Map(),\r\n  list: [1, 2, 3],\r\n  a: 3,\r\n  b: 4\r\n}\r\n\r\ncloneDeep(obj)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODc3MTU1NQ==",
          "body": "```js\r\nconst oldJson = { a: 1 }\r\nconst newJson = JSON.parse(JSON.stringify(oldJson))\r\noldJson.a = 2\r\nconsole.log(oldJson) // {a: 2}\r\nconsole.log(newJson) // {a: 1}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coder-eric",
            "url": "https://github.com/coder-eric"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NDU0NTUxMw==",
          "body": "function getType(obj){\r\n    return Object.prototype.toString.call(obj).slice(8,-1);\r\n}\r\nfunction cloneDeep(obj){\r\n\tlet target = {};\r\n\tif(getType(obj)==='Object'){\r\n\t\t\tfor(let key in obj){\r\n\t\t\t\tlet item = obj[key];\r\n\t\t\t\ttarget[key]=cloneDeep(item);\r\n\t\t\t}\r\n\t\t\treturn target;\r\n\t}else if(getType(obj)==='Array'){\r\n\t\treturn obj.map(item => cloneDeep(item) )\r\n\t}else{\r\n\t\treturn obj;\r\n\t}\r\n}\r\n\r\n\r\nvar obj = {foo:function(){},bar:1,name:'cat'}\r\n\r\nvar objClone = cloneDeep(obj)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "miaooow",
            "url": "https://github.com/miaooow"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDAxMzk4MA==",
          "body": "参考: [clone](https://npm.devtool.tech/clone)\r\n\r\n1. 如何处理复杂对象，如 `Date`、`Regexp` 等\r\n2. 如何处理循环引用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hspb",
          "body": "> const oldJson = { a: 1}\r\n> const newJson = {}\r\n> Object.assign(newJson, oldJson)\r\n> oldJson.a = 2\r\n> console.log(oldJson) // {a: 2}\r\n> console.log(newJson) // {a: 1}\r\n\r\n对于深层的复杂类型，assign其实是浅拷贝\r\n![image](https://user-images.githubusercontent.com/20502943/125911925-b011aafc-5193-4244-af00-7424a7f1174f.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haiifeng",
            "url": "https://github.com/haiifeng"
          }
        },
        {
          "id": "IC_kwDODQzyOs408XGZ",
          "body": "```js\r\n/**\r\n * 深拷贝关注点:\r\n * 1. JavaScript内置对象的复制: Set、Map、Date、Regex等\r\n * 2. 循环引用问题\r\n * @param {*} object \r\n * @returns \r\n */\r\nfunction deepClone(source, memory) {\r\n  const isPrimitive = (value) => {\r\n    return /Number|Boolean|String|Null|Undefined|Symbol|Function/.test(Object.prototype.toString.call(value));\r\n  }\r\n  let result = null;\r\n\r\n  memory || (memory = new WeakMap());\r\n  // 原始数据类型及函数\r\n  if (isPrimitive(source)) {\r\n    console.log('current copy is primitive', source);\r\n    result = source;\r\n  }\r\n  // 数组\r\n  else if (Array.isArray(source)) {\r\n    result = source.map(value => deepClone(value, memory));\r\n  }\r\n  // 内置对象Date、Regex\r\n  else if (Object.prototype.toString.call(source) === '[object Date]') {\r\n    result = new Date(source);\r\n  }\r\n  else if (Object.prototype.toString.call(source) === '[object Regex]') {\r\n    result = new RegExp(source);\r\n  }\r\n  // 内置对象Set、Map\r\n  else if (Object.prototype.toString.call(source) === '[object Set]') {\r\n    result = new Set();\r\n    for (const value of source) {\r\n      result.add(deepClone(value, memory));\r\n    }\r\n  }\r\n  else if (Object.prototype.toString.call(source) === '[object Map]') {\r\n    result = new Map();\r\n    for (const [key, value] of source.entries()) {\r\n      result.set(key, deepClone(value, memory));\r\n    }\r\n  }\r\n  // 引用类型\r\n  else {\r\n    if (memory.has(source)) {\r\n      result = memory.get(source);\r\n    } else {\r\n      result = Object.create(null);\r\n      memory.set(source, result);\r\n      Object.keys(source).forEach(key => {\r\n        const value = source[key];\r\n        result[key] = deepClone(value, memory);\r\n      });\r\n    }\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 6
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs410_Ho",
          "body": "```js\r\n(function (done) {\r\n  if (!done) return;\r\n  // 如何实现一个深拷贝 (cloneDeep)\r\n  const obj = {\r\n    re: /hello/,\r\n    f() {},\r\n    date: new Date(),\r\n    map: new Map(),\r\n    set: new Set(),\r\n    list: [1, 2, 3],\r\n    a: 3,\r\n    b: 4,\r\n    h: {\r\n      name: \"wby\",\r\n      age: 29,\r\n    },\r\n    e:undefined,\r\n    d:null\r\n  };\r\n  let utils = getTypes()\r\n  const newObj = cloneDeep(obj);\r\n  console.log(newObj);\r\n  console.log(obj.map === newObj.map);\r\n\r\n  function getTypes(){\r\n    let isTypes = {};\r\n    function isTyping(typing) {\r\n      return function (value) {\r\n        return Object.prototype.toString.call(value) === `[object ${typing}]`;\r\n      };\r\n    }\r\n    let types = [\"Object\", \"Function\", \"RegExp\", \"Map\", \"Set\", \"Date\", \"Array\",\"String\"];\r\n    for (let type of types) {\r\n      isTypes[`is${type}`] = isTyping(type);\r\n    }\r\n    return isTypes;\r\n  }\r\n \r\n  function cloneDeep(obj, memory) {\r\n    let target = Object.create(null);\r\n    memory || (memory = new WeakMap());\r\n    for (let key in obj) {\r\n      let value = obj[key];\r\n      if (typeof value !== \"object\" || value === null) {\r\n        target[key] = value;\r\n      } else {\r\n        if (utils.isSet(value)) {\r\n          target[key] = new Set();\r\n          for (const v of value) {\r\n            target[key].add(cloneDeep(v, memory));\r\n          }\r\n        } else if (utils.isMap(value)) {\r\n          target[key] = new Map();\r\n          for (const [k, v] of value.entries()) {\r\n            target[key].set(k, cloneDeep(v, memory));\r\n          }\r\n        } else if (utils.isObject(value)) {\r\n          target[key] = cloneDeep(value);\r\n        } else {\r\n          target[key] = new Object.prototype.constructor(value);\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n})(1);\r\n\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        },
        {
          "id": "IC_kwDODQzyOs45JPDy",
          "body": "```\r\n function deepCopy(obj) {\r\n          var result = Array.isArray(obj) ? [] : {};\r\n          for (var key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n              if (typeof obj[key] === 'object') {\r\n                result[key] = deepCopy(obj[key]);   //递归复制\r\n              } else {\r\n                result[key] = obj[key];\r\n              }\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs45vM57",
          "body": "> const oldJson = { a: 1} const newJson = {} Object.assign(newJson, oldJson) oldJson.a = 2 console.log(oldJson) // {a: 2} console.log(newJson) // {a: 1}\r\n@kucy 对于数组等引用类型的属性值，Object.assign还是浅拷贝\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CbRFP",
          "body": "JS有原生的深拷贝API `structuredClone`:\r\n\r\n```js\r\nconst obj1 = { a: 1 };\r\nconst obj2 = structuredClone(obj1);\r\n\r\nobj2.a = 2;\r\n\r\nconsole.log(obj1); // { a: 1 }\r\nconsole.log(obj2); // { a: 2 }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrcaidev",
            "url": "https://github.com/mrcaidev"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Dq_ki",
          "body": "``` javascript\r\n        // 使用array from克隆\r\n        let arr = [1, 2, 3, 4, 5, 6, [{ 1: 12, 2: 24 }]]\r\n        let arr2 = Array.from(arr)\r\n        console.log(arr === arr2)\r\n\r\n        console.log(arr) // [1,2,3,4,5,6,{\"1\": 0,\"2\": 0}]\r\n        console.log(arr2) // [1,2,3,4,5,6,{\"1\": 0,\"2\": 0}]\r\n\r\n        // 解决实现不了深拷贝\r\n        const deepClone = arr => Array.isArray(arr) ? Array.from(arr, deepClone) : arr\r\n        let arr3=deepClone(arr)\r\n        console.log(arr3) // [1,2,3,4,5,6,{\"1\": 12, \"2\": 24}]\r\n\r\n        arr[6][0] = { 1: 00, 2: 00 }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "QC2168",
            "url": "https://github.com/QC2168"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Dq_zA",
          "body": "```javascript\r\n\r\n// 使用扩展运算符实现深，浅拷贝\r\nlet arr = [1, 2, 3, 4, 5, 6, [{ 1: 12, 2: 24 }]]\r\nlet arr2 = [...arr]\r\nconsole.log(arr === arr2)\r\nconsole.log(arr) // [1,2,3,4,5,6,{\"1\": 0,\"2\": 0}]\r\nconsole.log(arr2) // [1,2,3,4,5,6,{\"1\": 0,\"2\": 0}]\r\n// 深拷贝\r\nconst deepClone = arr => arr.map(i => Array.isArray(i) ? deepClone(i) : i)\r\nlet arr3 = deepClone(arr)\r\narr[6][0] = { 1: 00, 2: 00 }\r\nconsole.log(arr3)  // [1,2,3,4,5,6,{\"1\": 12, \"2\": 24}]\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "QC2168",
            "url": "https://github.com/QC2168"
          }
        },
        {
          "id": "IC_kwDODQzyOs5H9kBD",
          "body": "~~~js\r\nfunction deepClone(target, map = new WeakMap()) {\r\n  if (typeof target !== \"object\") return target;\r\n\r\n  if (map.has(target)) return map.get(target); // 解决循环引用问题\r\n\r\n  const res = Array.isArray(target) ? [] : {};\r\n  map.set(target, res);\r\n\r\n  for (const key in target) {\r\n    res[key] = deepClone(target[key], map);\r\n  }\r\n  return res;\r\n}\r\n\r\n// 测试\r\nconst obj = {\r\n  foo: {\r\n    bar: 2,\r\n  },\r\n  list: [1, 2, 3],\r\n};\r\nobj.obj = obj; // 循环引用\r\n\r\nconst obj2 = deepClone(obj);\r\n\r\nconsole.log(obj, obj2);\r\n\r\nobj.list[3] = 3333;\r\nobj.foo.bar = 3;\r\n\r\nconsole.log(obj, obj2);\r\n\r\n\r\n~~~",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "4may-mcx",
            "url": "https://github.com/4may-mcx"
          }
        },
        {
          "id": "IC_kwDODQzyOs5J6vfn",
          "body": "```code：\r\nfunction deepClone(obj, map = new WeakMap()) {\r\n    if (obj === null) return obj\r\n    if (obj instanceof Date) return new Date(obj)\r\n    if (obj instanceof RegExp) return new RegExp(obj)\r\n    if (typeof obj !== 'object') return obj     \r\n    if (map.has(obj)) return map.get(obj)   //解决循环引用\r\n    const cloneobj = new obj.constructor()  //生成obj的对应类型\r\n    map.set(obj, cloneobj)\r\n    Reflect.ownKeys(obj).forEach((key) => {\r\n        cloneobj[key] = deepClone(obj[key], map)\r\n    })\r\n    return cloneobj\r\n}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coderWxs",
            "url": "https://github.com/coderWxs"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ZUH3B",
          "body": "```js\r\nconst obj = {\r\n\tre: /hello/,\r\n  f() {},\r\n  date: new Date(),\r\n  map: new Map(),\r\n  list: [1,2,3],\r\n  a: 3,\r\n  b: 4\r\n}\r\nfunction deepClone(target,map= new Map()) {\r\n  if(target === null) return null\r\n  if(Object.prototype.toString.call(target) === '[object RegExp]') {\r\n    return new RegExp(target)\r\n  }\r\n  if(Object.prototype.toString.call(target) === '[object Date]') {\r\n    return new Date(target)\r\n  }\r\n  if(typeof target === 'object') {\r\n    let cloneTarget = Array.isArray(target)?[]:{}\r\n    if(map.get(target)){\r\n      return map.get(target)\r\n    }\r\n    map.set(target,cloneTarget)\r\n    for(const key in target){\r\n      cloneTarget[key] = deepClone(target[key],map)\r\n    }\r\n    return cloneTarget\r\n  } else {\r\n    return target\r\n  }  \r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yinzhuo19970516",
            "url": "https://github.com/Yinzhuo19970516"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ZmA49",
          "body": "Array、Set、Map、Object中都可能出现循环引用。\r\n```javascript\r\nconst obj = {\r\n    re: /hello/,\r\n    f () {},\r\n    date: new Date(),\r\n    map: new Map(),\r\n    list: [1, 2, 3],\r\n    a: 3,\r\n    b: 4\r\n}\r\n\r\nconst obj2 = {loop2: obj, name: 'obj2'}\r\nobj.loop = obj2\r\n\r\n\r\nfunction deepClone(source, cache = new WeakMap()) {\r\n    //原始类型或函数直接返回\r\n    if (typeof source !== 'object') {\r\n        return source\r\n    }\r\n\r\n    //加入缓存解决循环引用\r\n    if (cache.has(source)) {\r\n        return cache.get(source)\r\n    }\r\n    let res = new source.constructor()\r\n    cache.set(source, res)\r\n    \r\n    //处理JS内置数据结构：Array、Map、Set、Object\r\n    if (source instanceof Array) {\r\n        source.forEach(v => {\r\n            res.push(deepClone(v, cache))\r\n        })\r\n    }\r\n    else if (source instanceof Map) {\r\n        for (const [k, v] of source) {\r\n            res.set(k, deepClone(v, cache))\r\n        }\r\n    }\r\n    else if (source instanceof Set) {\r\n        for (const v of source) {\r\n            res.add(deepClone(v, cache))\r\n        }\r\n    }\r\n    else if (Object.prototype.toString.call(source) == '[object Object]') {\r\n        for(const key in source){\r\n            res[key] = deepClone(source[key], cache)\r\n        }\r\n    }else {\r\n        //处理自定义对象（需遵循协议new constructors时为深拷贝）\r\n        res = new source.constructor(source)\r\n    }\r\n\r\n    return res\r\n}\r\n\r\nconst newObj = deepClone(obj)\r\nconsole.log(newObj)\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "xicYue",
            "url": "https://github.com/xicYue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lMBOa",
          "body": "> Array、Set、Map、Object中都可能出现循环引用。\r\n> \r\n> ```js\r\n> const obj = {\r\n>     re: /hello/,\r\n>     f () {},\r\n>     date: new Date(),\r\n>     map: new Map(),\r\n>     list: [1, 2, 3],\r\n>     a: 3,\r\n>     b: 4\r\n> }\r\n> \r\n> const obj2 = {loop2: obj, name: 'obj2'}\r\n> obj.loop = obj2\r\n> \r\n> \r\n> function deepClone(source, cache = new WeakMap()) {\r\n>     //原始类型或函数直接返回\r\n>     if (typeof source !== 'object') {\r\n>         return source\r\n>     }\r\n> \r\n>     //加入缓存解决循环引用\r\n>     if (cache.has(source)) {\r\n>         return cache.get(source)\r\n>     }\r\n>     let res = new source.constructor()\r\n>     cache.set(source, res)\r\n>     \r\n>     //处理JS内置数据结构：Array、Map、Set、Object\r\n>     if (source instanceof Array) {\r\n>         source.forEach(v => {\r\n>             res.push(deepClone(v, cache))\r\n>         })\r\n>     }\r\n>     else if (source instanceof Map) {\r\n>         for (const [k, v] of source) {\r\n>             res.set(k, deepClone(v, cache))\r\n>         }\r\n>     }\r\n>     else if (source instanceof Set) {\r\n>         for (const v of source) {\r\n>             res.add(deepClone(v, cache))\r\n>         }\r\n>     }\r\n>     else if (Object.prototype.toString.call(source) == '[object Object]') {\r\n>         for(const key in source){\r\n>             res[key] = deepClone(source[key], cache)\r\n>         }\r\n>     }else {\r\n>         //处理自定义对象（需遵循协议new constructors时为深拷贝）\r\n>         res = new source.constructor(source)\r\n>     }\r\n> \r\n>     return res\r\n> }\r\n> \r\n> const newObj = deepClone(obj)\r\n> console.log(newObj)\r\n> ```\r\n\r\ntypeof null 也是返回 'object' 的，建议都用 Object.prototype.toString.call() 判断吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "redsanjin-1",
            "url": "https://github.com/redsanjin-1"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lMBaQ",
          "body": "这是来自QQ邮箱的假期自动回复邮件。\r\n \r\n您好，我最近正在休假中，无法亲自回复您的邮件。我将在假期结束后，尽快给您回复。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xicYue",
            "url": "https://github.com/xicYue"
          }
        },
        {
          "id": "IC_kwDODQzyOs50bxIq",
          "body": "```javascript\r\nconst object = {\r\n  arr: [\r\n    {\r\n      b: {\r\n        c: 3\r\n      }\r\n    },\r\n    {\r\n      b: {\r\n        c: 4\r\n      },\r\n      d: 5,\r\n      e: [\r\n        {\r\n          f: 6\r\n        },\r\n        {\r\n          g: 7,\r\n          h: {\r\n            i: 8,\r\n            j: [\r\n              {\r\n                k: 9\r\n              },\r\n              {\r\n                l: 10,\r\n                m: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"10\"]\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  func() {\r\n\r\n  },\r\n  date: new Date(),\r\n  map: new Map(),\r\n  set: new Set(),\r\n  weakMap: new WeakMap(),\r\n  weakSet: new WeakSet(),\r\n  booleanT: true,\r\n  booleanF: false,\r\n  funcGet: (x) => {\r\n    console.log(x)\r\n    return x + 1\r\n  },\r\n  symbol: Symbol(\"x\"),\r\n  nul: null,\r\n  undefin: undefined,\r\n  nan: NaN,\r\n  integrity: Infinity,\r\n  number: 42,\r\n  regexp: /hello/,\r\n  bigint: BigInt(\"987654321\"),\r\n  str: \"str\",\r\n  promise: new Promise((resolve, reject) => {\r\n    resolve(\"promise 1\")\r\n  }),\r\n  div: document.createElement('div',{\r\n    id:'div',\r\n    class:'div'\r\n  }),\r\n  generator: function* generatorFunc() {\r\n    yield \"yield 1\"\r\n  },\r\n  err: new Error(\"error\"),\r\n}\r\n\r\nfunction deepClone(origin, hashMap = new WeakMap()) {\r\n  if (origin == undefined || typeof origin !== 'object'){\r\n    return origin\r\n  }\r\n\r\n  if (origin instanceof Date){\r\n    return new Date(origin.getTime())\r\n  }\r\n\r\n  if (origin instanceof RegExp){\r\n    return new RegExp(origin)\r\n  }\r\n\r\n  if(origin instanceof HTMLElement){\r\n    return origin.cloneNode(true)\r\n  }\r\n\r\n  if(origin instanceof Promise){\r\n    return origin\r\n  }\r\n\r\n  if (hashMap.has(origin)){\r\n    return hashMap.get(origin)\r\n  }\r\n\r\n  let targetClone = new origin.constructor()\r\n  hashMap.set(origin, targetClone)\r\n  Reflect.ownKeys(origin).forEach((key) => {\r\n    targetClone[key] = deepClone(origin[key], hashMap)\r\n  })\r\n\r\n  return targetClone\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hviwen",
            "url": "https://github.com/hviwen"
          }
        },
        {
          "id": "IC_kwDODQzyOs50bxOC",
          "body": "这是来自QQ邮箱的假期自动回复邮件。你好，我最近正在休假中，无法亲自回复你的邮件。我将在假期结束后，尽快给你回复。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "loveminxo",
            "url": "https://github.com/loveminxo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjkzMjAxNTM=",
    "number": 204,
    "title": "【Q203】对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTQyOTMwMw==",
          "body": "如果开启了tree shaking应该不会打包。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "blank121",
            "url": "https://github.com/blank121"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NzMzOTAwMQ==",
          "body": "tree shaking通过扫描所有 ES6 的 export，找出被 import 的内容并添加到最终代码中。tree shaking的使用时 **源码必须遵循 ES6 的模块规范 (import & export)，如果是 CommonJS 规范 (require) 则无法使用。** 也就是说，需要给babel里面配置一下\"es6不要解析\"：\r\n```\r\n// .babelrc\r\n\r\n{\r\n    \"presets\": [\r\n        [\"es2015\", {\"modules\": false}]\r\n    ]\r\n}\r\n```\r\ntree shaking在webpack2.0里面需要进行手动设置，webpack3和webpack4里面为默认设置。\r\n### 一、对于方法的处理\r\n**通过tree shaking设置后，webpack里面会将没有使用的方法标记为：\r\n`unused harmony export xxx`，但代码仍然保留。（webpack编译后的源码里面仍然包含没有使用的方法）**\r\n随后使用`UglifyJSPlugin`进行第二步，将已经标记的没有使用的方法进行删除。\r\n### 二、对于类的处理\r\n**与标记方法不同，webpack打包时会将整个类进行标记，也就是说，即使类里面的方法没有被使用也会进行打包编译。** 这表明 webpack tree shaking 只处理顶层内容，例如类和对象内部都不会再被分别处理。\r\n综上所述，可以得出 **“对于已经 import 但未实际使用的模块使用 webpack 还会对它打包”** 。\r\n当然，想要精简代码是可以实现的，具体文章参考：[Webpack 之 treeShaking](https://www.jianshu.com/p/cf930283d404)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "varlinux",
            "url": "https://github.com/varlinux"
          }
        },
        {
          "id": "IC_kwDODQzyOs43Xt2G",
          "body": "模块/文件级别的 tree shaking，如果模块没有导入但是模块内的函数存在副作用(对外部变量进行读写)的话，也会被打包。解决方法是在模块所在的npm包的package.json中增加 sideEffects: false, 表示所有的模块/文件都是没有副作用的，或者有副作用的话被删了也没关系\r\n\r\n参考 https://webpack.js.org/guides/tree-shaking/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk4NzQ5Nzg=",
    "number": 205,
    "title": "【Q204】Node 中如何判断一个路径是文件还是文件夹",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTI5MTU0Ng==",
          "body": "const  statInfo = fs.lstatSync(\"./xx\").\r\nstatInfo.isDirectory()",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "PlutoCA",
            "url": "https://github.com/PlutoCA"
          }
        },
        {
          "id": "IC_kwDODQzyOs5EDk7R",
          "body": "- isFile()：检测是否为常规文件\r\n- isDirectory()：检测是否为文件夹",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hsq777",
            "url": "https://github.com/hsq777"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk5ODMyNTU=",
    "number": 206,
    "title": "【Q205】Code Splitting 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5MTMzODg1MA==",
          "body": "https://www.toutiao.com/i6790221102615364108/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yt253284494",
            "url": "https://github.com/yt253284494"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzE0NjE5MTU=",
    "number": 207,
    "title": "【Q206】no-cache 与 no-store 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5OTE5MjU5MA==",
          "body": "no-cache 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 \r\nno-store 是禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "lijiayi01",
            "url": "https://github.com/lijiayi01"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxOTYxMTUzNw==",
          "body": "`no-cache` 和 `no-store` 用作控制缓存，被服务器通过响应头 `Cache-Control` 传递给客户端\r\n\r\n## `no-store`\r\n\r\n**永远都不要在客户端存储资源**，每次永远都要从原始服务器获取资源\r\n\r\n## `no-cache`\r\n\r\n可以在客户端存储资源，但每次都**必须去服务器做新鲜度校验**，来决定从服务器获取最新资源 (200) 还是从客户端读取缓存 (304)，即所谓的协商缓存\r\n\r\n> [当服务器资源返回 304 时与那些 HTTP 响应头有关](https://github.com/shfshanyue/Daily-Question/issues/441)\r\n\r\n一般情况下对于 `index.html` 或者现代构建环境下不加 hash 的静态资源都需要设置 `Cache-Control: no-cache`，用来强制每次在服务器端的新鲜度校验。\r\n\r\n相当于以下响应头\r\n\r\n``` bash\r\nCache-Control: max-age=0, must-revalidate\r\n```\r\n\r\n## 相关问题\r\n\r\n+ [【Q434】当服务器资源返回 304 时与那些 HTTP 响应头有关](https://github.com/shfshanyue/Daily-Question/issues/441)\r\n+ [【Q079】简述 HTTP 的缓存机制](https://github.com/shfshanyue/Daily-Question/issues/80)",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzMyNDkxODA=",
    "number": 208,
    "title": "【Q207】什么是隔离级",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stbhr",
          "body": "隔离级别（Isolation Level）是数据库管理系统（DBMS）中用于控制并发事务访问共享数据的一个概念。隔离级别规定了一个事务对数据库中数据的读取和写入在何种程度上与其他事务隔离，以防止并发事务引起的一系列问题，如脏读、不可重复读和幻读。\r\n\r\n常见的隔离级别有以下四种：\r\n读未提交（Read Uncommitted）： 允许一个事务读取另一个事务尚未提交的数据。这是最低的隔离级别，也是最灵活的，但会导致脏读、不可重复读和幻读的问题。\r\n读提交（Read Committed）： 允许一个事务读取另一个事务已经提交的数据。在这个级别下，脏读的问题得到解决，但仍可能发生不可重复读和幻读。\r\n可重复读（Repeatable Read）： 保证在同一个事务中多次读取相同的数据时，得到的结果是一致的。可重复读级别通过锁定读取的数据行，防止其他事务修改这些行，解决了不可重复读的问题。\r\n串行化（Serializable）： 提供最高的隔离级别，确保一个事务的执行过程中不会受到其他事务的干扰。它通过对数据进行加锁，防止其他事务读取或修改被锁定的数据，从而避免了脏读、不可重复读和幻读。\r\n\r\n一般我们常用Serializable级别。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzM1Njk3MTI=",
    "number": 209,
    "title": "【Q208】在 postgres 中如何查看慢查询语句",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzM5ODUxMzc=",
    "number": 210,
    "title": "【Q209】如何得知一条 SQL 执行的时长？",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5E0rOJ",
          "body": "1.show profiles；\r\n2.set profiling = 1;\r\n3.show databases;\r\n4.show profiles;\r\n----------+------------+----------------+\r\n| Query_ID | Duration   | Query          |\r\n+----------+------------+----------------+\r\n|        1 | 0.00124300 | show warnings  |\r\n|        2 | 0.03788000 | show databases |\r\n+----------+------------+----------------+\r\n\r\nNOTE:\r\nThe [SHOW PROFILE](https://dev.mysql.com/doc/refman/8.0/en/show-profile.html) and [SHOW PROFILES](https://dev.mysql.com/doc/refman/8.0/en/show-profiles.html) statements are deprecated; expect them to be removed in a future MySQL release. Use the [Performance Schema](https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html) instead;\r\n\r\n\r\n\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liyihang",
            "url": "https://github.com/liyihang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzQ2NTEyMDc=",
    "number": 211,
    "title": "【Q210】如何判断当前环境是移动端还是PC端",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5Mzk1MjgzNg==",
          "body": "判断 `navigator.userAgent`，对于 Android/iPhone 可以匹配以下正则\r\n\r\n``` js\r\nconst appleIphone = /iPhone/i;\r\nconst appleIpod = /iPod/i;\r\nconst appleTablet = /iPad/i;\r\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\r\nconst androidTablet = /Android/i;\r\n```\r\n\r\n当然，不要重复造轮子，推荐一个库: <https://github.com/kaimallea/isMobile>\r\n\r\n``` js\r\nimport isMobile from 'ismobilejs'\r\n\r\nconst mobile = isMobile()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzc3NTUzMA==",
          "body": "```\r\nisPc() {\r\n    var userAgentInfo = navigator.userAgent\r\n    var Agents = new Array(\r\n      'Android',\r\n      'iPhone',\r\n      'SymbianOS',\r\n      'Windows Phone',\r\n      'iPad',\r\n      'iPod'\r\n    )\r\n    var flag = true\r\n    for (var v = 0; v < Agents.length; v++) {\r\n      if (userAgentInfo.indexOf(Agents[v]) > 0) {\r\n        flag = false\r\n        break\r\n      }\r\n    }\r\n    return flag\r\n  }\r\n```\r\n嘿嘿照搬了一段商用的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzc3NzEyNw==",
          "body": "@SageSanyue 直接用 `Array.prototype.some` 就简单多了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzc4NDMzNw==",
          "body": "> @SageSanyue 直接用 `Array.prototype.some` 就简单多了\r\n\r\n确实噢😯我完全没动我的zhu脑子:(\r\n```\r\nisPc() {\r\n    var userAgentInfo = navigator.userAgent\r\n    var Agents = new Array(\r\n      'Android',\r\n      'iPhone',\r\n      'SymbianOS',\r\n      'Windows Phone',\r\n      'iPad',\r\n      'iPod'\r\n    )\r\n    var flag = true\r\n    flag = !Agents.some((ele) => {\r\n        return userAgentInfo.indexOf(ele) > 0 \r\n    })\r\n    return flag\r\n  }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzQ3MzIxNzM=",
    "number": 212,
    "title": "【Q211】React hooks 中 useCallback 的使用场景是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMDE1Nw==",
          "body": "能想到的只有两个场景\r\n1. 作为props传递的函数，集合memo一起使用；\r\n2. 作为更新触发的依赖项\r\n主要目的是为了避免高昂的计算和不必要的重复渲染",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "newwangyiyang",
            "url": "https://github.com/newwangyiyang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUxNTEzNTk=",
    "number": 213,
    "title": "【Q212】在 postgres/mysql 中如何判断当前版本是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDMzODQ4Mw==",
          "body": "使用 `select version()`\r\n\r\npostgres 示例如下:\r\n\r\n``` sql\r\npostgres@db:school> select version()\r\n+---------------------------------------------------------------------------------------+\r\n| version                                                                               |\r\n|---------------------------------------------------------------------------------------|\r\n| PostgreSQL 12.1 on x86_64-pc-linux-musl, compiled by gcc (Alpine 8.3.0) 8.3.0, 64-bit |\r\n+---------------------------------------------------------------------------------------+\r\nSELECT 1\r\nTime: 0.028s\r\n```\r\n\r\nmysql 示例如下：\r\n\r\n``` sql\r\n> select version()\r\n+-------------+\r\n| version()   |\r\n|-------------|\r\n| 5.6.16-log  |\r\n+-------------+\r\n1 row in set\r\nTime: 0.003s\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUzNjc3NTg=",
    "number": 214,
    "title": "【Q213】什么是隔离级，都有哪些隔离级",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDU0ODU5Mg==",
          "body": "隔离级事关并发事务的隔离机制，ANSI SQL 中定义了四种隔离级，分别是\r\n\r\n+ Read Uncommited\r\n+ Read Committed\r\n+ Repetable Read\r\n+ Serializable",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU1MzU2NjM=",
    "number": 215,
    "title": "【Q214】input 中监听值的变化是在监听什么事件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDY0NTQxNg==",
          "body": "可以**实时**监听值的变化的事件有以下几种\r\n\r\n+ keypress\r\n+ keydown\r\n+ keyup\r\n+ input\r\n\r\n注: `onChange` 无法做到实时监听，因为 onChange 需要失去焦点才能触发",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTAwMDQ5Mw==",
          "body": "oninput不用考虑是否失去焦点，不管js操作还是键盘鼠标手动操作，只要HTML元素属性发生改变即可立即捕获到",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "sunhua-2217",
            "url": "https://github.com/sunhua-2217"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTAxMTU5Mw==",
          "body": "**onchange:**\r\n\r\n**Supported HTML tags:** \r\n\r\n```\r\n<input type=\"checkbox\">, <input type=\"file\">, <input type=\"password\">, <input type=\"radio\">, <input type=\"range\">, <input type=\"search\">, <input type=\"text\">, <select> and <textarea>\r\n```\r\n\r\n\r\nThe onchange attribute fires the moment when the value of the element is changed.\r\n\r\nTip: This event is similar to the oninput event. The difference is that the oninput event occurs immediately after the value of an element has changed, **while onchange occurs when the element loses focus**. The other difference is that the onchange event also works on <select> elements.",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "qixMan",
            "url": "https://github.com/qixMan"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTU3MDQ0OA==",
          "body": "@CaiyueDamowang 测试了好像不行\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "imondo",
            "url": "https://github.com/imondo"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjA1NTM0Mg==",
          "body": "> @CaiyueDamowang 测试了好像不行\r\n\r\n嗯，不行。。\r\n在html标签中onchange可以在失去焦点触发",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cy-98",
            "url": "https://github.com/cy-98"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY5MTc4NTM1OQ==",
          "body": "低版本浏览器\r\n<input onpropertychange=\"onPropertyChange(event)\" />\r\nfunction onPropertyChange(event){console.log(event.srcElement.value)}\r\n\r\n\r\nie10以上\r\n<input onInput=\"onInput(event)\" />\r\nfunction onInput(event){console.log(event.srcElement.value)}\r\n\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "XFwilliamii",
            "url": "https://github.com/XFwilliamii"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjY3NzE1OA==",
          "body": "input 事件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "w1687021088",
            "url": "https://github.com/w1687021088"
          }
        },
        {
          "id": "IC_kwDODQzyOs5G2ZUl",
          "body": "oninput实时触发，onchange失去焦点时触发",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "huiaixing",
            "url": "https://github.com/huiaixing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjIyOTI=",
    "number": 216,
    "title": "【Q215】什么是跨域，如何解决跨域问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDk3MjkzOA==",
          "body": "## 跨域\r\n\r\n**协议**，**域名**，**端口**，三者有一不一样，就是跨域\r\n\r\n案例一：`www.baidu.com` 与 `zhidao.baidu.com` 是跨域\r\n\r\n## 如何解决跨域\r\n\r\n目前有两种最常见的解决方案：\r\n\r\n1. CORS，在服务器端设置几个响应头，如 `Access-Control-Allow-Origin: *`\r\n1. Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名\r\n1. JSONP，详解见 [JSONP 的原理是什么，如何实现](https://github.com/shfshanyue/Daily-Question/issues/447)\r\n\r\n附代码: nginx 关于跨域的配置\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech;\r\n\r\n  location / {\r\n    # 避免非root路径404\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  # 解决跨域\r\n  location /api {\r\n    # 或者是 http://localhost:8080\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQxNDM=",
    "number": 217,
    "title": "【Q216】你对未来的工作有什么期待",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQ3NTA=",
    "number": 218,
    "title": "【Q217】你对未来的三年规划和五年规划是什么样的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4MTc3MzYzNw==",
          "body": "三年高级五年架构",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Bob4F",
            "url": "https://github.com/Bob4F"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyOTI2NjQ0NA==",
          "body": "三年高考五年模拟",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "GitHubJiKe",
            "url": "https://github.com/GitHubJiKe"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjUwMTM=",
    "number": 219,
    "title": "【Q218】当你入职后发现压力过大怎么办",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45c2cV",
          "body": "没有过大，只有钱给的少",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzE2OTI=",
    "number": 220,
    "title": "【Q219】工作中你有没有很佩服的人",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4--zZF",
          "body": "月哥",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzQ0NjQ=",
    "number": 221,
    "title": "【Q220】请简述一下 event loop",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4Njk5MDU2Ng==",
          "body": "![image](https://user-images.githubusercontent.com/19162008/109372242-850c0980-78e3-11eb-8fe6-ecb15fa5e480.png)\r\n\r\nheap（堆）：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。\r\nstack（栈）：函数调用形成了一个由若干帧组成的栈。\r\nWebAPIS：囊括 Web 强大脚本能力的每个 API 参考资料， 包括 DOM 、所有相关的 APIs 及可以用来构建 Web 的相关接口。\r\n队列（event queue || Callback Queue）：一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数\r\n\r\n\r\n[event loop 运行图解](http://latentflip.com/loupe/?code=c2V0VGltZW91dChmdW5jdGlvbigpewogICAgY29uc29sZS5sb2coJzEnKQp9LDApOwoKbmV3oCBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpewoKoCBjb25zb2xlLmxvZygnMicpOwoKoCByZXNvbHZlKCk7Cgp9KS50aGVuKGZ1bmN0aW9uKCl7Cgpjb25zb2xlLmxvZygnMycpCgp9KTsKCmNvbnNvbGUubG9nKCc0Jyk7Cg%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)\r\n\r\n```\r\nsetTimeout(() => {\r\n    console.log(1)\r\n}, 100)\r\nconsole.log(2);\r\nsetTimeout(() => {\r\n    console.log(3)\r\n}, 0)\r\n// 2\r\n// 1\r\n// 3\r\n```\r\n\r\n![未标题-1](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif)\r\n\r\n\r\n\r\n看图我们可以了解到，setTimeout(() => {console.log(1)}, 0) 会在Stack执行，在放入WebAPIs中当成一个匿名函数执行，匿名函数执行完毕之后会放入Callback Queue 中。\r\nconsole.log(2) 则直接被推入Stack 中执行。\r\n\r\nsetTimeout(() => {console.log(3)}, 0) 同样的执行后放入WebAPIs中当成一个匿名函数执行，在放入Callback Queue中。当同步任务执行完之后，才会将Callback Queue 队列中的方法推入Stack中。\r\n\r\n**因为JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决排除等待问题，JS的任务分为同步任务（synchronous）和异步任务（asynchronous）。\r\n所有同步任务都在主线程上执行，形成一个Stac）。异步任务（如果是WebAPI 则会进入WebAPI，例如ajax setTimeout）不进入主线程，而是进入另一 Callback Queue。同步任务顺序执行，只有执行栈中的同步任务执行完了，系统才回读取任务队列中可以执行的异步任务，才会把此异步任务从事件队列中放入执行栈中执行，如此循环，直至所有任务执行完毕。**\r\n\r\n**这就是EventLoop**\r\n\r\n\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "martin-yin",
            "url": "https://github.com/martin-yin"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyMzMwMzE0MA==",
          "body": "@martin-yin 这个网站好评啊！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5G_2Hl",
          "body": "> ![image](https://user-images.githubusercontent.com/19162008/109372242-850c0980-78e3-11eb-8fe6-ecb15fa5e480.png)\r\n> \r\n> heap（堆）：对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。 stack（栈）：函数调用形成了一个由若干帧组成的栈。 WebAPIS：囊括 Web 强大脚本能力的每个 API 参考资料， 包括 DOM 、所有相关的 APIs 及可以用来构建 Web 的相关接口。 队列（event queue || Callback Queue）：一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数\r\n> \r\n> [event loop 运行图解](http://latentflip.com/loupe/?code=c2V0VGltZW91dChmdW5jdGlvbigpewogICAgY29uc29sZS5sb2coJzEnKQp9LDApOwoKbmV3oCBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpewoKoCBjb25zb2xlLmxvZygnMicpOwoKoCByZXNvbHZlKCk7Cgp9KS50aGVuKGZ1bmN0aW9uKCl7Cgpjb25zb2xlLmxvZygnMycpCgp9KTsKCmNvbnNvbGUubG9nKCc0Jyk7Cg%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)\r\n> \r\n> ```\r\n> setTimeout(() => {\r\n>     console.log(1)\r\n> }, 100)\r\n> console.log(2);\r\n> setTimeout(() => {\r\n>     console.log(3)\r\n> }, 0)\r\n> // 2\r\n> // 1\r\n> // 3\r\n> ```\r\n> \r\n> ![未标题-1](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif) [ ![未标题-1](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif) ](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif) [ ](https://user-images.githubusercontent.com/19162008/109375818-9c0a2600-78fa-11eb-8a0f-1d65394fb6a6.gif)\r\n> \r\n> 看图我们可以了解到，setTimeout(() => {console.log(1)}, 0) 会在Stack执行，在放入WebAPIs中当成一个匿名函数执行，匿名函数执行完毕之后会放入Callback Queue 中。 console.log(2) 则直接被推入Stack 中执行。\r\n> \r\n> setTimeout(() => {console.log(3)}, 0) 同样的执行后放入WebAPIs中当成一个匿名函数执行，在放入Callback Queue中。当同步任务执行完之后，才会将Callback Queue 队列中的方法推入Stack中。\r\n> \r\n> **因为JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。为了解决排除等待问题，JS的任务分为同步任务（synchronous）和异步任务（asynchronous）。 所有同步任务都在主线程上执行，形成一个Stack）。异步任务（如果是WebAPI 则会进入WebAPI，例如ajax setTimeout）不进入主线程，而是进入另一 Callback Queue。同步任务顺序执行，只有执行栈中的同步任务执行完了，系统才会读取任务队列中可以执行的异步任务，才会把此异步任务从事件队列中放入执行栈中执行，如此循环，直至所有任务执行完毕。**\r\n> \r\n> **这就是EventLoop**\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "18062706139fcz",
            "url": "https://github.com/18062706139fcz"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jitAq",
          "body": "```\r\nsetTimeout(() => {\r\n    console.log(1)\r\n}, 100)\r\nconsole.log(2);\r\nsetTimeout(() => {\r\n    console.log(3)\r\n}, 0)\r\n```\r\n// 2\r\n// 3\r\n// 1",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        },
        {
          "id": "IC_kwDODQzyOs5l_e4X",
          "body": "答案是不是错了啊   放在浏览器是2 3 1 现在这个网站放上去也是2 3 1\r\n<img width=\"1132\" alt=\"image\" src=\"https://github.com/shfshanyue/Daily-Question/assets/91886018/b60d2dd2-b8dc-4491-be37-475403a7ce4a\">\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "601odd",
            "url": "https://github.com/601odd"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzgwOTU=",
    "number": 222,
    "title": "【Q221】作为技术负责人，你每天的工作是什么样的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5nhW8F",
          "body": "不一定能细化到每一天，以半年时间回顾总结：\r\n\r\n**50%** 前端基建&技术管理（脚手架、组件库，前端架构，实现最佳实践模板，技术选型，开发工具提效（写一个类似油猴的chrome插件），前端技术分享，解决一些棘手的前端问题）\r\n**30%** 项目人员管理 （拆包分配任务，track项目并定制规范，招聘|培训新人，）\r\n**20%** 业务开发 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "FrankZhai367",
            "url": "https://github.com/FrankZhai367"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5Mzg0NTU=",
    "number": 223,
    "title": "【Q222】数据库中如何查看当前的连接数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NDgwNDEwOA==",
          "body": "**PostgresSQL 的最大连接数与当前连接数**\r\n\r\n``` sql\r\n-- 最大连接数\r\nshow max_connections;\r\n\r\n-- 当前连接数\r\nselect count(*) from pg_stat_activity;\r\n```\r\n\r\n**mysql 的最大连接数与当前连接数**\r\n\r\n``` sql\r\n-- 最大连接数\r\nshow variables like 'max_connections';\r\n\r\n-- 当前连接数\r\nshow full processlist;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzA2MTA=",
    "number": 224,
    "title": "【Q223】数据库查询如何更好地利用数据库缓存进行优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stek8",
          "body": "MySQL5.7之后就已经不推荐使用数据库缓存，因为数据库缓存会给数据库造成性能问题，可以将缓存放到应用层做，使用Redis。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzQ1MDM=",
    "number": 225,
    "title": "【Q224】误操作了一个 delete from 语句，如何恢复数据",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stgVK",
          "body": "1.如果数据库有备份，则从数据库的备份中恢复；\r\n2.数据库如果有开启binlog日志，可以通过日志找到该记录的操作语句进行恢复；\r\n3.借助一些第三方工具恢复；\r\n通常如果没有备份，或者没有开启日志，一旦误删除要恢复数据都是非常麻烦和困难的，所以数据库一定要做好备份以及权限控制。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzNjY1MzE=",
    "number": 226,
    "title": "【Q225】你相比去年，有哪些成长",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5OTg3NzYwNw==",
          "body": "体重有所成长，胖了不少",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Akishimo",
            "url": "https://github.com/Akishimo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzNzQyNDI=",
    "number": 227,
    "title": "【Q226】数据库死锁是怎么产生的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTMyMDc1Mw==",
          "body": "多个事务对资源的交替顺序访问，如\r\n\r\n事务1，访问A表，A表锁住，访问B表，此时B表却被事务2锁住，等待\r\n事务2，访问B表，B表锁住，访问A表，此时A表却被事务1锁住，等待\r\n\r\n由此观之，此死锁出现的条件极为苛刻\r\n\r\n1. 并发，产生多个事务\r\n1. 顺序，对相同资源的不同顺序访问 (干嘛要不同顺序呀)\r\n1. 时机，恰好两个事物都刚刚走完了第一步\r\n\r\n[更多示例](https://www.cnblogs.com/wezheng/p/8366029.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzODE4ODY=",
    "number": 228,
    "title": "【Q227】你如何看待996",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI3NzMxOQ==",
          "body": "1. 违法\r\n2. 开历史的倒车\r\n3. 容易使员工养成加班文化。最近一新闻提到苏州微软抵制从阿里离职的在职员工搞 996、在工作群里互相攀比加班时间的现象\r\n4. 使员工更不值钱。996 工作制下只有拿到当前工资的 2.275 倍，才在经济账上不吃亏。\r\n5. 对遵循八小时工作制的员工不公平\r\n6. [工作 996，生病 ICU](https://996.icu/#/zh_CN)",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "IC_kwDODQzyOs5XSe_I",
          "body": "问题的本质是管理者无能，换掉一个管理者。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuhaohao1234",
            "url": "https://github.com/wuhaohao1234"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY3MzE4MjE=",
    "number": 229,
    "title": "【Q228】如何实现一个 flatMap 函数 (头条)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzg5MTUwMg==",
          "body": "没说不让用flat；所以有个取巧的办法\r\nconst flatMap = arr => arr.flat().map(_ => _);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rex-ll",
            "url": "https://github.com/rex-ll"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MzQ4NDQyNA==",
          "body": "```\r\nfunction flatMap(arr){\r\n    let list = []\r\n    arr.forEach(item=>{\r\n        if(Array.isArray(item)){\r\n            const l = flatMap(item)\r\n            list.push(...l)\r\n        }else{\r\n            list.push(item)\r\n        }\r\n    })\r\n    return list\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HuiFeiYa",
            "url": "https://github.com/HuiFeiYa"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNDE1ODg5Mg==",
          "body": "`Array.prototype.flatMap` 已经是 EcmaScript 的标准，看一个例子，它的输出是多少？\r\n\r\n``` js\r\n[1, 2, [3], 4].flatMap(x => x + 1)\r\n//=> [2, 3, '31', 5]\r\n```\r\n\r\n很可惜，不是 `[2, 3, 4, 5]`，原因在于 `flatMap` 实际上是先 `map` 再 `flat`，实现如下\r\n\r\n``` js\r\nArray.prototype.flatMap = function (mapper) {\r\n  return this.map(mapper).flat()\r\n}\r\n```\r\n\r\n而 `flat` 可以如下实现\r\n\r\n``` js\r\nconst flat = list => list.reduce( (a, b) => a.concat(b), [])\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs408IuM",
          "body": "```js\r\nArray.prototype.FlatMap = function(callback, thisArgs) {\r\n  return this.reduce((acc, value) => {\r\n    return acc = acc.concat(callback.call(thisArgs, value));\r\n  });\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_hnuF",
          "body": "https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "719676340",
            "url": "https://github.com/719676340"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DrCQs",
          "body": "```javascript\r\n// 先map再flat\r\nlet myFlatMap = function (fn) {\r\n    let target = this\r\n    return (target.map(i => fn(i))).flat()\r\n}\r\nArray.prototype.myFlatMap = myFlatMap\r\nlet arr = [\"it's Sunny in\", \"\", \"California\"];\r\nlet arr1 = arr.map(x => x.split(\" \"));\r\nlet arr2 = arr.flatMap(x => x.split(\" \"));\r\nlet arr3 = arr.myFlatMap(x => x.split(\" \"));\r\nconsole.log(arr1); // [[\"it's\",\"Sunny\",\"in\"],[\"\"],[\"California\"]]\r\nconsole.log(arr2); // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"]\r\nconsole.log(arr3); // [\"it's\",\"Sunny\",\"in\", \"\", \"California\"]\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "QC2168",
            "url": "https://github.com/QC2168"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY4Mzc5Njg=",
    "number": 230,
    "title": "【Q229】在数据库中一个字段如果是字符串类型的，那应该设置哪种数据类型",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjIwNDExNg==",
          "body": "以下答案仅说明在 postgres 中的情况：\r\n\r\n在 postgres 有三种 `varchar`，`char` 以及 `text`，其中三者没有性能差异，见官方文档\r\n\r\n> Different from other database systems, in PostgreSQL, there is no performance difference among three character types. In most situation, you should use text or varchar, and varchar(n) if you want PostgreSQL to check for the length limit\r\n\r\n所以，选择 `text` 是最好的方案",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNDEyNjQ=",
    "number": 231,
    "title": "【Q230】如何裁剪图片 (情景：选择头像)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MzUyMTk4Mw==",
          "body": "```\r\nvar path = 'https://static-zh.wxb.com.cn/customer/form/2020/11/1758696796d.jpg'\r\nfunction clipImage(path){\r\n    const canvas = document.createElement('canvas')\r\n    canvas.width = 200\r\n    canvas.height = 100\r\n    const ctx = canvas.getContext('2d')\r\n    const img = document.createElement('img')\r\n    img.src = path\r\n    img.setAttribute(\"crossOrigin\",'Anonymous')\r\n    img.onload = function (){\r\n        ctx.drawImage(this,0,0,200,100)\r\n        console.log(canvas.toDataURL())\r\n    }\r\n}\r\nclipImage(path)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HuiFeiYa",
            "url": "https://github.com/HuiFeiYa"
          }
        },
        {
          "id": "IC_kwDODQzyOs450Kb3",
          "body": "使用ctx.arc()和ctx.clip()进行裁剪\r\n ctx.arc(x, y, radius, startAngle, endAngle);\r\nctx.clip();\r\nctx.drawImage(img, x, y, width, height)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNTQwMTQ=",
    "number": 232,
    "title": "【Q231】你周末都喜欢做些什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5Njk1NDQxNA==",
          "body": "打篮球，看电影，看不下书怎么办",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "HoweZhang",
            "url": "https://github.com/HoweZhang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzAzMDM5Ng==",
          "body": "> 打篮球，看电影，看不下书怎么办\r\n\r\n丰富而有意义的生活啊，有这样的美好生活，还看书干嘛？工作日再看呀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTMwOTA5OQ==",
          "body": "> 打篮球，看电影，看不下书怎么办\r\n\r\n看不下就休息，不要勉强自己",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4NTEyMjIyNg==",
          "body": "这取决于媳妇儿喜欢做什么",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rplss",
            "url": "https://github.com/rplss"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMDExOTI=",
    "number": 233,
    "title": "【Q232】当有大量的文本库时，如何做一个字云",
    "body": "如果对去重的每个字都做计数的话，会不会性能过差",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMTIyNzY=",
    "number": 234,
    "title": "【Q233】一个关于并发更新的事务以及隔离级的问题",
    "body": "当多并发场景下有以下事务执行 (计数器自增)，会出现什么问题\r\n\r\n``` sql\r\nbegin;\r\n\r\n-- select count from counter;\r\n\r\nupdate counter set count = count + 1 where id = 1;\r\n\r\ncommit;\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjA3MDY3OA==",
          "body": "如果在 pg 下:\r\n\r\n如果隔离级为 RC，则多个事务在更新同一行时，会受到阻塞 (Row Lock)\r\n如果隔离级为 RR，则多个事务在更新同一行时，会报错\r\n\r\n```\r\ncould not serialize access due to concurrent update\r\n```\r\n\r\nmysql 未测试",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMzAzMTE=",
    "number": 235,
    "title": "【Q234】以下 SQL 语句会有什么问题 (悲观锁)",
    "body": "一个计数器，自增一\r\n\r\n``` sql\r\nbegin;\r\nselect count from user;\r\n\r\n-- 根据以上 SQL 查询出来的 count 来进行自增\r\n-- 如果在此次事务中，已有多次事务对 count 进行了多次更改怎么办？\r\nupdate user set count = $count + 1 where id = 1;\r\ncommit;\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjA4NjI3MA==",
          "body": "在并发情况下会出现问题，先查看本次事务的流程\r\n\r\n1. 查询当前计数 -> 此时为 10\r\n1. 对当前计数自增 -> 此时为 11？**在自增时，有可能被多并发的其它事务已经自增到 100 了，此时若设置为 11，肯定有问题**\r\n\r\n**如何解决？**\r\n\r\n要在第一步时加锁，同一时间只放行一个事务，可以设置分布式锁和悲观锁\r\n\r\n+ **分布式锁** (redis)：`SET LOCK_KEY RANDOM_VALUE EX 100 NX`\r\n+ **悲观锁**：`select count from user for update`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg1NjUwNTU=",
    "number": 236,
    "title": "【Q235】useEffect 中如何使用 async/await",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzA3ODA5NQ==",
          "body": "``` ts\r\nfunction useEffect(effect: EffectCallback, deps?: DependencyList): void;\r\ntype EffectCallback = () => (void | (() => void | undefined));\r\n```\r\n\r\n根据文档及 ts 的提示来看，`useEffect` 的回调参数返回的是一个清除副作用的 `clean-up` 函数。因此无法返回 `Promise`，更无法使用 `async/await`\r\n\r\n``` js\r\nuseEffect(() => {\r\n  const subscription = props.source.subscribe();\r\n  return () => {\r\n    // Clean up the subscription\r\n    subscription.unsubscribe();\r\n  };\r\n});\r\n```\r\n\r\n**此时可以选择再包装一层 async 函数，置于 useEffect 的回调函数中，变相使用 async/await**\r\n\r\n``` jsx\r\nasync function fetchMyAPI() {\r\n  let response = await fetch('api/data')\r\n  response = await res.json()\r\n  dataSet(response)\r\n}\r\n\r\nuseEffect(() => {\r\n  fetchMyAPI();\r\n}, []);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs450X2u",
          "body": "useEffect(() => {\r\n    (async function anyNameFunction() {\r\n      await loadContent();\r\n    })();\r\n  }, []);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg3MDc0MTI=",
    "number": 237,
    "title": "【Q236】主域名的 SEO 是否比二级域名要更好",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTMxMTY1OA==",
          "body": "看场景的。请补充场景。再说这个和前端工程化有啥关系？",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzkxOTExOTg=",
    "number": 238,
    "title": "【Q237】以下代码，koa 会返回什么数据",
    "body": "根据有无 `await next()` 判断以下代码输出结果\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n  await next()\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  await next()\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzU4MDQyOA==",
          "body": "根据 koa 的洋葱模型，返回结果是\r\n\r\n```\r\nhello, 1\r\n\r\nhello, 2\r\n\r\nhello, 1\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzk5NDY4NTQ=",
    "number": 239,
    "title": "【Q238】什么是服务雪崩，如何避免",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5NjAxMzY=",
    "number": 240,
    "title": "【Q239】Node 如何进行进程间通信 ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5ODk5MTU4MQ==",
          "body": "对于 spawn/fork 出来的父子进程来说，可以通过 pipe 的方式\r\n\r\n+ `process.on('message')`/`process.send`\r\n+ `stdin.on/stdout.write`\r\n\r\n对于并无相关的进程\r\n\r\n+ `socket`\r\n+ `message queue`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5NzUxNjc=",
    "number": 241,
    "title": "【Q240】如何实现一个 async/await ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODU3Mzc2Mg==",
          "body": "```js\r\n/**\r\n * async的执行原理\r\n * 其实就是自动执行generator函数\r\n * 暂时不考虑genertor的编译步骤（更复杂）\r\n */\r\n\r\nconst getData = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(\"data\"), 1000))\r\n\r\n// 这样的一个async函数 应该再1秒后打印data\r\nasync function test() {\r\n  const data = await getData()\r\n  console.log('data: ', data);\r\n  const data2 = await getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\n// async函数会被编译成generator函数 (babel会编译成更本质的形态，这里我们直接用generator)\r\nfunction* testG() {\r\n  // await被编译成了yield\r\n  const data = yield getData()\r\n  console.log('data: ', data);\r\n  const data2 = yield getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\nfunction asyncToGenerator(generatorFunc) {\r\n  return function() {\r\n    const gen = generatorFunc.apply(this, arguments)\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function step(key, arg) {\r\n        let generatorResult\r\n        try {\r\n          generatorResult = gen[key](arg)\r\n        } catch (error) {\r\n          return reject(error)\r\n        }\r\n\r\n        const { value, done } = generatorResult\r\n\r\n        if (done) {\r\n          return resolve(value)\r\n        } else {\r\n          return Promise.resolve(value).then(\r\n            function onResolve(val) {\r\n              step(\"next\", val)\r\n            },\r\n            function onReject(err) {\r\n              step(\"throw\", err)\r\n            },\r\n          )\r\n        }\r\n      }\r\n      step(\"next\")\r\n    })\r\n  }\r\n}\r\n\r\nconst testGAsync = asyncToGenerator(testG)\r\ntestGAsync().then(result => {\r\n  console.log(result)\r\n})\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "sl1673495",
            "url": "https://github.com/sl1673495"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNjQyNzAzNg==",
          "body": "公众号里这篇文章留的 github 网址有误，那个 url 打开 404 ：）",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "crossz",
            "url": "https://github.com/crossz"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NTYzOTU3Mg==",
          "body": "参考 `@bebel/runtime` 的实现代码如下，可在 [asyncToGenerator.js](https://cdn.jsdelivr.net/npm/@babel/runtime@7.13.9/helpers/esm/asyncToGenerator.js) 查看源代码\r\n\r\n``` js\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\r\n  try {\r\n    var info = gen[key](arg);\r\n    var value = info.value;\r\n  } catch (error) {\r\n    reject(error);\r\n    return;\r\n  }\r\n\r\n  if (info.done) {\r\n    resolve(value);\r\n  } else {\r\n    Promise.resolve(value).then(_next, _throw);\r\n  }\r\n}\r\n\r\nexport default function _asyncToGenerator(fn) {\r\n  return function () {\r\n    var self = this,\r\n        args = arguments;\r\n    return new Promise(function (resolve, reject) {\r\n      var gen = fn.apply(self, args);\r\n\r\n      function _next(value) {\r\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\r\n      }\r\n\r\n      function _throw(err) {\r\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\r\n      }\r\n\r\n      _next(undefined);\r\n    });\r\n  };\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2NjU4MzE1NQ==",
          "body": "赞赞赞。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiutian00",
            "url": "https://github.com/qiutian00"
          }
        },
        {
          "id": "IC_kwDODQzyOs411Bef",
          "body": "```js\r\n\r\n(function (done) {\r\n  if (!done) return;\r\n  const getData = () => {\r\n    return new Promise((resolve) => setTimeout(() => resolve(\"data\"), 1000));\r\n  };\r\n  function* testG() {\r\n    // await被编译成了yield\r\n    const data = yield getData();\r\n    console.log(\"data: \", data);\r\n    const data2 = yield getData();\r\n    console.log(\"data2: \", data2);\r\n    return \"success\";\r\n  }\r\n  function genratorWarp(testG) {\r\n    return new Promise((resolve, reject) => {\r\n      let it = testG();\r\n      function next(val) {\r\n        let { value, done } = it.next(val);\r\n        if (done) {\r\n          resolve(value);\r\n        } else {\r\n          Promise.resolve(value).then((data) => {\r\n            next(data);\r\n          }, reject);\r\n        }\r\n      }\r\n      next();\r\n    });\r\n  }\r\n  genratorWarp(testG).then((data) => {\r\n    console.log(data);\r\n  });\r\n})(1);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        },
        {
          "id": "IC_kwDODQzyOs50lQJj",
          "body": "```javascript\r\nfunction _awaiter(fn) {\r\n  let resolveFn = (value) => value\r\n  let rejectFn = (reason) => reason\r\n\r\n  let generator = fn\r\n\r\n  let promise = new Promise((resolve, reject) => {\r\n    resolveFn = resolve\r\n    rejectFn = reject\r\n  })\r\n\r\n  const adopt = (value) => {\r\n    return value instanceof Promise ? value : Promise.resolve(value)\r\n  }\r\n\r\n  const step = (preValue) => {\r\n    try {\r\n      const { value, done } = generator.next(preValue)\r\n      adopt(value).then(\r\n        (nextValue) => {\r\n          if (done) {\r\n            resolveFn(nextValue)\r\n          } else {\r\n            step()\r\n          }\r\n        },\r\n        (reason) => {\r\n          if (done) {\r\n            rejectFn(reason)\r\n          } else {\r\n            step()\r\n          }\r\n        }\r\n      )\r\n    } catch (err) {\r\n      rejectFn(err)\r\n    }\r\n  }\r\n\r\n  step()\r\n  return promise\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hviwen",
            "url": "https://github.com/hviwen"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5ODQxNjI=",
    "number": 242,
    "title": "【Q241】如何使用 async/await 实现 Promise.all 的效果",
    "body": "如获取三个用户的信息，使用 `Promise.all` 的写法\r\n\r\n``` js\r\nconst users = await Promise.all(getUser(1), getUser(2), getUser(3))\r\n```\r\n\r\n那如何不使用 `Promise.all` 实现以上效果",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5OTA3OTQ4Mw==",
          "body": "使用 `async`/`await` 实现\r\n\r\n``` js\r\nconst user1 = getUser(1)\r\nconst user2 = getUser(2)\r\nconst user3 = getUser(3)\r\n\r\nconst u1 =  await user1\r\nconst u2 =  await user2\r\nconst u3 =  await user3\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzODA0MTQ0Mw==",
          "body": "```\r\nconst all = (list) => {\r\n    const res = new Promise((resolve, reject) => {\r\n        let length = list && list.length\r\n        let count = 0\r\n        let result = []\r\n        if(!list || list.length === 0) {\r\n            resolve(result)\r\n        }\r\n        list.forEach(async (item, index) => {\r\n            try {\r\n                const res = await item\r\n                result[index] = res\r\n                count ++\r\n                if(count === length) {\r\n                    resolve(result)\r\n                }\r\n            } catch(err) {\r\n                reject(err)\r\n            }\r\n        });\r\n    })\r\n    return res\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Misxiao",
            "url": "https://github.com/Misxiao"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI2MjM2OA==",
          "body": "> 使用 `async`/`await` 实现\r\n> \r\n> ```js\r\n> const user1 = getUser(1)\r\n> const user2 = getUser(2)\r\n> const user3 = getUser(3)\r\n> \r\n> const u1 =  await user1\r\n> const u2 =  await user2\r\n> const u3 =  await user3\r\n> ```\r\n\r\n这个和上面的 `Promise.all` 并不一样吧。`Promise.all` 是并行操作，`await` 这个是串行操作",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI2NTc1Mw==",
          "body": "> 如获取三个用户的信息，使用 `Promise.all` 的写法\r\n> \r\n> ```js\r\n> const users = await Promise.all(getUser(1), getUser(2), getUser(3))\r\n> ```\r\n> \r\n> 那如何不使用 `Promise.all` 实现以上效果\r\n\r\nPromise.all 后面的参数为数组。。。",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI2ODU1Nw==",
          "body": "```js\r\nlet req1 = () => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=1&q=is%3Aissue+is%3Aopen`);\r\n\r\nlet req2 = () => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=2&q=is%3Aissue+is%3Aopen`);\r\n\r\nlet req3 = () => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=3&q=is%3Aissue+is%3Aopen`);\r\n\r\n// promise.all\r\nconst res = await Promise.all([req1(), req2(), req3()]);\r\n\r\nconst res1 = req1()\r\nconst res2 = req2()\r\nconst res3 = req3()\r\n\r\n// await\r\nconst u1 =  await res1\r\nconst u2 =  await res2\r\nconst u3 =  await res3\r\n\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/57755075/89433879-71e1f280-d775-11ea-8772-6c26e58d29c3.png)\r\n",
          "star": {
            "totalCount": 4
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI3MDUxNA==",
          "body": "所以这个题的答案是\r\n\r\ntan90° \r\n不存在",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "IC_kwDODQzyOs47vwDP",
          "body": "看了一篇这个，好像可以\r\nhttps://blog.csdn.net/github_38589282/article/details/79268484",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "jeff-wangzhen",
            "url": "https://github.com/jeff-wangzhen"
          }
        },
        {
          "id": "IC_kwDODQzyOs5R68xf",
          "body": "如有错误，欢迎指正\r\n\r\n```js\r\nasync function foo(promise){\r\n  const t=[]\r\n  for(let p of promise){\r\n    // 检查传参\r\n    if (p instanceof Promise === false) {\r\n      throw new Error('传参错误')\r\n    }\r\n    // 并行触发\r\n    (async () => {\r\n      try{\r\n        const r=await p\r\n        t.push(r)\r\n      }catch(err){\r\n        // 捕获异常\r\n        return err\r\n      }\r\n    })()\r\n  }\r\n  // 轮询\r\n  const res = await new Promise(resolve=>{\r\n    const timer=setInterval(() => {\r\n      if(t.length===promise.length) {\r\n        clearInterval(timer)\r\n        resolve(t)\r\n      }\r\n    }, 1000);\r\n  })\r\n  return res\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iamphc",
            "url": "https://github.com/iamphc"
          }
        },
        {
          "id": "IC_kwDODQzyOs5akdQm",
          "body": "> 所以这个题的答案是\r\n> \r\n> tan90° 不存在\r\n\r\n### @ghost\r\n\r\n![image](https://user-images.githubusercontent.com/17308328/233923291-66b7c0e6-73a6-43c7-b0d3-beb17589477d.png)\r\n```html\r\n<script>\r\n    async function fn() {\r\n        const req = (i) => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=${i}&q=is%3Aissue+is%3Aopen`, {\r\n            mode: 'no-cors'\r\n        });\r\n\r\n        // promise.all\r\n        const res = await Promise.all([req(1), req(2), req(3)]);\r\n\r\n        // await\r\n        const res1 = req(4)\r\n        const res2 = req(5)\r\n        const res3 = req(6)\r\n        const u1 =  await res1\r\n        const u2 =  await res2\r\n        const u3 =  await res3\r\n    }\r\n    fn()\r\n</script>\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODEyNDc5ODc=",
    "number": 244,
    "title": "【Q242】有没有用过 continuous local storage，用在了哪里",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODEyNTE3NTg=",
    "number": 245,
    "title": "【Q243】有没有遇到 js 捕捉不到异常堆栈信息的情况",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45c2k2",
          "body": "有啊，网络错误，就捕捉不到",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE1OTc0MTM=",
    "number": 246,
    "title": "【Q244】Promise 在异步资源的生命周期 (async_hooks) 中是如何被销毁的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY4MDQ=",
    "number": 247,
    "title": "【Q245】有没有用过 Promise.allSettled() ，它是干什么的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2OTczMzcyNQ==",
          "body": "接收一个可迭代对象，其中每个成员都是`Promise`。在所有给定的`Promise`都已经`fulfilled`或`rejected`后返回一个`Promise`，并带有一个对象数组，每个对象表示对应的`Promise`结果\r\n相较于`Promise.all`，后者会在任何一个`Promise`为`rejected`时立即结束\r\n简单实现\r\n``` js\r\nconst myPromiseSettled = (items) => {\r\n  const onResolved = (value) => ({ status: 'fulfilled', value });\r\n  const onRejected = (reason) => ({ status: 'rejected', reason });\r\n  return Promise.all(items.map((item) => Promise.resolve(item).then(onResolved, onRejected)));\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTA1NTM0MA==",
          "body": "@mrrs878 代码相当简洁了！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5akgV0",
          "body": "```js\r\nfunction allSettled(promises = []) {\r\n    return new Promise((resolve) => {\r\n        let count = 0\r\n        let values = new Array(promises.length)\r\n        const collect = (index, status) => (value) => {\r\n            const prop = status === 'fulfilled' ? 'value' : 'reason'\r\n            values[index] = { status, [prop]: value }\r\n            ++count === promises.length && resolve(values)\r\n        }\r\n        promises.forEach((promise, i) => {\r\n            if (isPromise(promise)) {\r\n                promise.then(\r\n                    collect(i, 'fulfilled'),\r\n                    collect(i, 'rejected')\r\n                )\r\n            } else {\r\n                collect(i, 'fulfilled')(promise)\r\n            }\r\n        })\r\n    })\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY5ODg=",
    "number": 248,
    "title": "【Q246】谈谈你对微服务的理解，试着画一个脑图",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODQzOTE5NTQ=",
    "number": 249,
    "title": "【Q247】在 node 中如何监听异步资源的生命周期",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODg0MTkwNDY=",
    "number": 250,
    "title": "【Q248】测试中 TDD 与 BDD 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk3MDc2NjE=",
    "number": 251,
    "title": "【Q249】使用 js 实现一个 lru cache",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2OTc0MjkxMQ==",
          "body": "可以借助`Map`实现\r\n\r\n``` js\r\nclass LRUCache {\r\n  constructor(limit) {\r\n    this.limit = limit;\r\n    this.cache = new Map();\r\n  }\r\n\r\n  get(key) {\r\n    if (!this.cache.has(key)) return undefined;\r\n    const value = this.cache.get(key);\r\n    this.cache.delete(key);\r\n    this.cache.set(key, value);\r\n    return value;\r\n  }\r\n\r\n  put(key, value) {\r\n    if (this.cache.has(key)) this.cache.delete(key);\r\n    else if (this.cache.size >= this.limit) {\r\n      this.cache.delete(this.cache.keys().next().value);\r\n    }\r\n    this.cache.set(key, value);\r\n  }\r\n}\r\n\r\n// [\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\r\n// [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]\r\nconst lruCache = new LRUCache(2);\r\nlruCache.put(1, 1);\r\nlruCache.put(2, 2);\r\nconst res1 = lruCache.get(1);\r\nlruCache.put(3, 3);\r\nconst res2 = lruCache.get(2);\r\nlruCache.put(4, 4);\r\nconst res3 = lruCache.get(1);\r\nconst res4 = lruCache.get(3);\r\nconst res5 = lruCache.get(4);\r\n\r\nconsole.log(res1, res2, res3, res4, res5);\r\n// 1 undefined undefined 3 4\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        },
        {
          "id": "IC_kwDODQzyOs408EuJ",
          "body": "LRU (最近最少使用) 缓存机制\r\n\r\n- 使用Map做数据保存\r\n- 自建双向链表做元素使用频率保存及空间大小控制\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5IbOdU",
          "body": "数组存key + map\r\n\r\n~~~js\r\nclass LRUCache {\r\n  _stack = [];\r\n  _map = {};\r\n\r\n  constructor(len = 10) {\r\n    this._len = len;\r\n  }\r\n\r\n  put(key, value) {\r\n    if (this._stack.includes(key)) {\r\n      this.update(key, value);\r\n      return;\r\n    }\r\n    // 如果超过缓存的大小，那就删除数组中的最后一个值\r\n    if (this._stack.length >= this._len) {\r\n      const delKey = this._stack[this._len - 1];\r\n      this.delete(delKey);\r\n    }\r\n    this.set(key, value);\r\n  }\r\n\r\n  set(key, value) {\r\n    this._stack.unshift(key);\r\n    this._map[key] = value;\r\n  }\r\n\r\n  get(key) {\r\n    if (this._map[key]) {\r\n      this.update(key);\r\n      return this._map[key];\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  update(key, value) {\r\n    const index = this._stack.indexOf(key);\r\n    this._stack.splice(index, 1);\r\n    this._stack.unshift(key);\r\n    if (value) {\r\n      this._map[key] = value;\r\n    }\r\n  }\r\n\r\n  delete(key) {\r\n    delete this._map[key];\r\n    this._stack.pop();\r\n  }\r\n}\r\n\r\nexport default LRUCache;\r\n\r\n~~~",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "4may-mcx",
            "url": "https://github.com/4may-mcx"
          }
        },
        {
          "id": "IC_kwDODQzyOs5SFaJE",
          "body": "```js\r\nfunction Node(key, val){\r\n  this.prev=null\r\n  this.next=null\r\n  this.key=key\r\n  this.val=val\r\n}\r\nfunction DoubleList(){\r\n  this._node=new Node(null, null)\r\n  this.size=0\r\n  // 插入到头部\r\n  this.addFirst=(node)=>{\r\n    // 找到头节点\r\n    while(this._node){\r\n      this._node=this._node.prev\r\n    }\r\n    // 处理头节点\r\n    this._node.prev=node\r\n    node.next=this._node\r\n    // 找到尾节点\r\n    while(this._node){\r\n      this._node=this._node.next\r\n    }\r\n    // 处理尾节点\r\n    this._node.prev.next=null\r\n    this._node.prev=null\r\n    this.size++\r\n  }\r\n  // 移除一个节点\r\n  this.remove=(node)=>{\r\n    if(!this.size) return -1\r\n    const prev=node.prev\r\n    const next=node.next\r\n    if(prev) {\r\n      node.prev.next=node.next\r\n    }\r\n    if(next){\r\n      node.next.prev=node.prev\r\n    }\r\n    this.size--\r\n  }\r\n  // 移除最后一个节点，并返回该节点\r\n  this.removeLast=()=>{\r\n    if(!this.size) return -1\r\n    while(this._node){\r\n      this._node=this._node.next\r\n    }\r\n    this.remove(this._node)\r\n    return this._node\r\n  }\r\n}\r\nfunction LRUcache(limit) {\r\n  this._limit=limit\r\n  this._doubleList=new DoubleList()\r\n  this._map=new Map()\r\n  // 获取key对应的节点，并将节点提前\r\n  this.get=(key)=>{\r\n    if(!this._map.has(key)) return -1\r\n    const node=this._map.get(key)\r\n    this._doubleList.addFirst(node)\r\n    return node\r\n  }\r\n  // 插入节点，并将节点提前\r\n  this.put=(key, val)=>{\r\n    const node=new Node(key,val)\r\n    if(this._map.has(key)){\r\n      this._doubleList.remove(this._map.get(key))\r\n    }\r\n    if(this._doubleList.size===this._limit){\r\n      const lastNode=this._doubleList.removeLast()\r\n      this._map.delete(lastNode.key)\r\n    }\r\n    this._doubleList.addFirst(node)\r\n    this._map.set(key,node)\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iamphc",
            "url": "https://github.com/iamphc"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk3MzI3NDk=",
    "number": 252,
    "title": "【Q250】刚刚启动了一个服务，如何知道这个服务对应的端口号是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyNDU5NjU0Mg==",
          "body": "在linux系统中，我通常通过 `ps -aux |grep 服务名` 查看服务端口",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "edisonwd",
            "url": "https://github.com/edisonwd"
          }
        },
        {
          "id": "IC_kwDODQzyOs5TUuJq",
          "body": "netstat -tlunp | grep {name}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzhejia",
            "url": "https://github.com/wuzhejia"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk5NDAwODU=",
    "number": 253,
    "title": "【Q251】node --max-old-space-size=4096 是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs52eP4X",
          "body": "修改最大内存限制，防止内存溢出。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "myway42",
            "url": "https://github.com/myway42"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNTk3MzU=",
    "number": 254,
    "title": "【Q252】https 中如何保证证书是可信任的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5rnG7s",
          "body": "数字签名\r\n\r\n数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。\r\n\r\n数字证书和CA\r\n\r\n因为公钥是任何人都可以发布的，所以我们需要引入第三方来保证公钥的可信度，这个“第三方”就是我们常说的 CA（Certificate Authority，证书认证机构），CA 对公钥的签名认证也是有格式的，要包含公钥的序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zxw94FE",
            "url": "https://github.com/zxw94FE"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzAzODE=",
    "number": 255,
    "title": "【Q253】cookie 有哪些字段",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTkwOA==",
          "body": "+ path\r\n+ domain\r\n+ key\r\n+ value\r\n+ httpOnly\r\n+ simeSite",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMjE5NDA2NQ==",
          "body": "name   cookie 名称\r\nvalue    cookie 值\r\ndomain 可以访问cookie的域名\r\npath 可以访问此cookie 的页面路径 \r\nexpires/Max-Age 超时时间\r\nsize  这个cookie 的大小\r\nhttp 字段  cookie的httponly属性\r\nsecure 设置是否只能通过https来传递此条cookie",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "chenheng-cmd",
            "url": "https://github.com/chenheng-cmd"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzQzOTc=",
    "number": 256,
    "title": "【Q254】进程与线程的区别是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTE3NDIzMzU=",
    "number": 257,
    "title": "【Q255】图片防盗链原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzEyMzkzNw==",
          "body": "请求头中的 refer 来判断是否屏蔽图片",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI0MjYzNzE=",
    "number": 258,
    "title": "【Q256】如何理解 Node 的异步非阻塞IO",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ1Mjk=",
    "number": 259,
    "title": "【Q257】爬虫中如何实现一个调度器",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ5ODE=",
    "number": 260,
    "title": "【Q258】如何实现一个分布式的爬虫",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Nzk5NQ==",
          "body": "可以通过 redis 实现一个分布式的 url 调度器 (Set)，多个分布式爬虫的爬取器从调度器中统一取地址进行爬取",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTU0Nzg=",
    "number": 261,
    "title": "【Q259】爬虫如何实现一个去重器",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4939T4",
          "body": "urlMap[url,hash(data)]\r\nurlSet[fullURL]\r\nurlMap存不包含查询字符串的url，data相同也不存储\r\nurlSet存完整url，即Map里没有查询到，则通过完整url去重",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shay-an",
            "url": "https://github.com/shay-an"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTMzMjQ0NjA=",
    "number": 262,
    "title": "【Q260】如何实现单点登录",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Njg0NA==",
          "body": "一张来 [单点登录原理与简单实现](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png) 的图\r\n\r\n![](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTMzNzMyODk=",
    "number": 263,
    "title": "【Q261】当写爬虫时，因爬取过多被禁掉 IP 怎么解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODk2MTMxMA==",
          "body": "可以维护一个 IP 地址池，通过 Proxy 的方式去爬取网页",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3MzY5NzA=",
    "number": 264,
    "title": "【Q262】当一个排期五天的任务需要在两天后上线如何解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTI0NDM2Mg==",
          "body": "1. 分析任务\r\n这个任务是活动页面开发？还是常规需求？\r\n如果是常规需求，可以考虑延期\r\n如果是活动页面，尤其是节假日、特殊纪念日的活动，可以考虑降低用户体验、砍需求等从而降低工作量，继而保证正常上线。因为运营活动的时效性较高\r\n2. 在排期阶段多估算时间，预计是常规工作时间的 1.5 倍\r\n3. 通过加班等方式弥补工期的缺失",
          "star": {
            "totalCount": 1
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3NTQyOTY=",
    "number": 265,
    "title": "【Q263】你们项目的测试覆盖率是怎么做的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3NzI3Mjk=",
    "number": 266,
    "title": "【Q264】当 Node 应用发生 gc 时，如何监控",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTQyOTM1NTE=",
    "number": 267,
    "title": "【Q265】Node 应用中如何查看 gc 的日志",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTM3NjExNg==",
          "body": "通过开启参数 `--trace-gc` 与 `--trace-gc-verbose`\r\n\r\n``` bash\r\n$ node --trace-gc index.js\r\n\r\n[10711:0x3507b20]    36425 ms: Mark-sweep 28.6 (48.2) -> 19.3 (46.7) MB, 3.9 / 0.0 ms  (+ 10.4 ms in 8 steps since start of marking, biggest step 6.9 ms, walltime since start of marking 77 ms) (average mu = 0.997, current mu = 0.997) finalize incremental marking via task GC in old space requested\r\n[10711:0x3507b20]    36434 ms: Scavenge 21.0 (46.7) -> 5.7 (46.7) MB, 1.0 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36494 ms: Scavenge 21.1 (46.7) -> 6.2 (46.7) MB, 2.3 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36562 ms: Scavenge 21.1 (46.7) -> 6.0 (46.7) MB, 2.8 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTQ0NTExNDU=",
    "number": 268,
    "title": "【Q266】bind 与 call/apply 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTUzNg==",
          "body": "他们都是绑定 this 的，但是\r\n\r\n1. `bind` 返回函数\r\n1. `call/apply` 直接执行函数",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTUxNDcwNDg=",
    "number": 269,
    "title": "【Q267】CSP 是干什么用的了",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxNjc5MQ==",
          "body": "http://www.ruanyifeng.com/blog/2016/09/csp.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rex-ll",
            "url": "https://github.com/rex-ll"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyNDQxOTc5Ng==",
          "body": "`CSP` **只允许加载指定的脚本及样式**，**最大限度地防止 `XSS` 攻击**，是解决 XSS 的最优解。CSP 的设置根据加载页面时 http 的响应头 `Content Security Policy` 在服务器端控制。\r\n\r\n1. 外部脚本可以通过指定域名来限制：**`Content-Security-Policy: script-src 'self'`**，`self` 代表只加载当前域名\r\n1. 如果网站必须加载内联脚本 (inline script) ，则可以提供一个 `nonce` 才能执行脚本，攻击者则无法注入脚本进行攻击。**`Content-Security-Policy: script-src 'nonce-xxxxxxxxxxxxxxxxxx'`**\r\n\r\n通过 `devtools -> network` 可见 github 的 CSP 配置如下：\r\n\r\n``` bash\r\nContent-Security-Policy: default-src 'none'; \r\n  base-uri 'self'; \r\n  block-all-mixed-content;\r\n  connect-src 'self' uploads.github.com www.githubstatus.com collector.githubapp.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com cdn.optimizely.com logx.optimizely.com/v1/events wss://alive.github.com; \r\n  font-src github.githubassets.com; \r\n  form-action 'self' github.com gist.github.com; \r\n  frame-ancestors 'none'; \r\n  frame-src render.githubusercontent.com; \r\n  img-src 'self' data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com *.githubusercontent.com; \r\n  manifest-src 'self'; \r\n  media-src 'none'; \r\n  script-src github.githubassets.com; \r\n  style-src 'unsafe-inline' github.githubassets.com; \r\n  worker-src github.com/socket-worker.js gist.github.com/socket-worker.js\r\n```\r\n\r\n## 相关链接\r\n\r\n+ [Content Security Policy 入门教程 - 阮一峰](http://www.ruanyifeng.com/blog/2016/09/csp.html)\r\n+ [Content Security Policy - w3](https://www.w3.org/TR/CSP3/#directive-form-action)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMTUxODY3Nw==",
          "body": "### Content Security Policy (CSP)\r\n\r\n**介绍：**\r\n1. 解决 XSS 最优办法\r\n2. 可以设置信任域名才可以访问 script / audio / video / image ...\r\n\r\n\r\n**防止 XSS 例子：**\r\n攻击者通过 恶意脚本(假设有执行外部脚本) 注入到系统内，显示给访问用户，以此来获取用户信息\r\n我们可以通过 CSP 来设置信任域名才可以执行 .js 脚本。\r\n\r\n\r\n**如何设置：**\r\n1. HTTP 请求头\r\n2. Meta 标签\r\n\r\nMDN：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\r\n\r\n兼容性：IE >= 10",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zzetao",
            "url": "https://github.com/zzetao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTU4NjcwMjA=",
    "number": 270,
    "title": "【Q268】你如何看待 serverless",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTcyNjcyMzE=",
    "number": 271,
    "title": "【Q269】什么是 XSS 攻击，如何避免",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3ODc4MTc2NA==",
          "body": "CSS (Cross Site Scripting)，跨站脚本攻击。可使用以下脚本在指定网站上进行攻击\r\n\r\n``` html\r\n<script>alert('XSS')</script>\r\n\r\n<img src=\"https://devtool.tech/notfound.png\" onerror=\"alert('XSS')\">\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTczMzI4OTc=",
    "number": 272,
    "title": "【Q270】一张员工表，一个字段代表它的上级，如何查询该员工的所有上级",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stkdZ",
          "body": "表中添加上级关系字段，如[1][2][3]，存放员工的所有上级，最末尾的ID为最高领导，这样可以更方便的查询所有上级关系，不过增加了维护该字段的业务工作",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTc4ODU4NjY=",
    "number": 273,
    "title": "【Q271】react hooks 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMTg2OA==",
          "body": "闭包 ➕ 链表",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "newwangyiyang",
            "url": "https://github.com/newwangyiyang"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Bw00o",
          "body": "> \r\n\r\n这也太短了吧。。具体点呢",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "EricWong1994",
            "url": "https://github.com/EricWong1994"
          }
        },
        {
          "id": "IC_kwDODQzyOs5eia43",
          "body": "React Hooks 是 React 16.8 引入的一个新特性，它允许在函数组件中使用状态和其他 React 功能，而无需编写类组件。它的实现原理是通过利用 JavaScript 的闭包和函数式编程的思想来实现。\r\n\r\n每个 Hook 都是一个函数，它可以对组件的状态进行操作或者访问 React 的其他功能。当组件渲染时，React 会根据每个 Hook 调用的顺序来维护内部的状态并执行相应的操作。\r\n\r\n使用 Hook 的过程中，React 维护了每个组件的“Hook 状态链”，它是一个单向链表结构，存储着所有使用 Hook 的状态信息。每次组件更新时，React 会检查使用的 Hook 是否发生变化，并根据变化来更新状态链中的对应状态。\r\n\r\n总体来说，React Hooks 的实现原理是基于函数式编程的思想来实现的，通过函数的调用和闭包的机制来管理状态，使得组件代码更加简洁、易于维护。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hjxhjxhjx1997",
            "url": "https://github.com/hjxhjxhjx1997"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTkzMjk2NjE=",
    "number": 274,
    "title": "【Q272】如何查看你们 JS 项目中应采用的 node 版本",
    "body": "当入职新公司，接手一个新的项目时，如何知道这个项目需要的 node 版本是多少",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxMjU5NQ==",
          "body": "如果项目使用的yarn和typescript，可以查看yarn.lock里的@types/node@* 的version",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rex-ll",
            "url": "https://github.com/rex-ll"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzk0OTc0MA==",
          "body": "1. `packageJson.engines`，第三方模块都会有，自己的项目中有可能有\r\n1. `pm2.app[].interpreter`，如果采用 `pm2` 部署，可以查看 interpreter 选项，但不保证该项存在\r\n1. `FROM`，如果采用 `docker` 部署，查看基础镜像 `Dockerfile` 中 node 的版本号\r\n1. 如果以上方式都不可以，那只有问人了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzk5OTMyMQ==",
          "body": "@DoubleRayWang 我试了一下，这种方法应该是不靠谱的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Dmh_3",
          "body": "`process.env` 里也可以看到 node 版本号，比如 `NODE`, `_` 这两个字段的值。\r\n\r\n个人是用的 NVM，没有在原生的 node 上试过，但后者的 `process.env` 应该也有。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrcaidev",
            "url": "https://github.com/mrcaidev"
          }
        },
        {
          "id": "IC_kwDODQzyOs5U1Biz",
          "body": "我不确定是指 一个完全新的从零开始的项目，还是指已有的项目相对于新人来说的刚接手的“新”。\r\n\r\n1. 如果是一个完全新的从零开始的项目，一般来说，如果均是采用最新稳定版本的依赖包，那么可以采用的node版本，其范围可以确定在 `^14.18.0 || >=16` 不超过node的当前最新稳定版本；而如果由于项目的特殊性，采用了低版本的依赖包，那么需要查看这些包的 `package.json` 的 `engines.node` 以确定这些包支持的node版本，取交集后确定最终采用的node版本。\r\n\r\n2. 如果是一个已有的项目，首先查看的是 项目的 `package.json` 中的 `engines.node` 字段，如果有声明，那么就采用对应的版本，如果没有，那么直接询问该项目的原负责人，确认是否有 node 版本的要求以及应该使用哪个版本，负责人不确定就询问原先用于开发或构建这个项目的机器安装的 node 版本，这样可以保证切换到新人的开发机器上，也有一致的node环境。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "pengzhanbo",
            "url": "https://github.com/pengzhanbo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDAyODAyMjA=",
    "number": 275,
    "title": "【Q273】http2 中的首部压缩的实现原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxNDAzMTYyOA==",
          "body": "`HPACK` 协议，其中原理是**哈夫曼编码**及**索引表** (看来常用的数据结构及算法要有所了解)，以下内容摘自 [谷歌开发者文档：http2](https://developers.google.com/web/fundamentals/performance/http2/)\r\n\r\n> 每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 （请参阅测量和控制协议开销。） 为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：\r\n>\r\n> 1. 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。\r\n> 1. 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。\r\n\r\n实践出真知，通过 `wireshark` 抓包分析 http2 的报文对理解 http2 收益颇多。\r\n\r\n> 你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。\r\n\r\n以下是关于抓包信息的截图\r\n\r\n**http2 通过 `Settings` 帧设置 header table size，进行首部压缩**\r\n\r\n![HTTP2 Settings](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1a9d380a4d47a4aabbbd98af4d3f90~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**http2 通过首部压缩后，:method 伪标头在索引表中的 Index 为 2**\r\n\r\n![HTTP2 Index](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1281937b584bffaa0bbcb9d5621341~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n关于**常用的标头会存储在静态索引表固定的位置**，详见 <https://httpwg.org/specs/rfc7541.html#static.table.definition>\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cef31dd10e64340b49caf35cbc01759~tplv-k3u1fbpfcp-zoom-1.image)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDEyMDEwNDQ=",
    "number": 276,
    "title": "【Q274】如何获取你们 Node 项目的 cpu profile 快照",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDEyMzM5NDg=",
    "number": 277,
    "title": "【Q275】解释下 OLTP 与 OLAP",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stk6e",
          "body": "OLTP（Online Transaction Processing）和OLAP（Online Analytical Processing）是两种数据库处理方式，它们分别服务于不同的应用场景。\r\n\r\nOLTP（Online Transaction Processing）:\r\n用途： OLTP主要用于处理大量的短期事务（交易），例如数据库中的增、删、改、查等操作，通常涉及对实时数据的处理。\r\n特点： OLTP系统注重事务的快速处理和高并发性，支持对数据库进行频繁的读写操作。数据库的设计通常采用规范化的模型，以确保数据的一致性和完整性。\r\n示例： 银行交易系统、在线购物系统、航班订票系统等。\r\n\r\nOLAP（Online Analytical Processing）:\r\n用途： OLAP主要用于支持决策支持和分析，提供对大量历史数据的复杂查询和分析功能。它用于生成报表、统计分析、数据挖掘等。\r\n特点： OLAP系统注重对大规模数据的复杂查询和分析，通常包括聚合、切片、切块等操作，以便用户能够更好地理解数据的趋势和模式。\r\n示例： 数据仓库系统、商业智能系统、在线分析系统等。\r\n总体来说，OLTP关注事务处理，追求快速的读写操作，而OLAP关注数据分析，提供复杂的查询和报表功能。在实际应用中，有时会采用混合的架构，即OLAP和OLTP相结合，以满足不同层次的需求。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2NjM4NTQ=",
    "number": 278,
    "title": "【Q276】如何查看 node_modules(某一文件夹) 的体积有多大",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjA4MjUxNQ==",
          "body": "`du` (disk usage) 命令可以查看磁盘的使用情况，从它可以看出来文件及目录的大小\r\n\r\n``` bash\r\n# -d 搜索深度，0 指当前目录\r\n# -h 以可读性的方式显示大小\r\n$ du -hd 0 node_modules\r\n132M    node_modules\r\n```\r\n\r\n同理，可以使用以下命令查看 `node_modules` 下每个目录所占的大小\r\n\r\n``` bash\r\n$ du -hd 1 node_modules\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ3MDQ=",
    "number": 279,
    "title": "【Q277】redux 解决什么问题，还有什么其他方案",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMjM5MQ==",
          "body": "1. mobx\r\n2. useContext ➕ useReducer",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "newwangyiyang",
            "url": "https://github.com/newwangyiyang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ4NTg=",
    "number": 280,
    "title": "【Q278】为什么不能在表达式里面定义 react hooks",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MDkyNDk4Mg==",
          "body": "https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kffhi",
            "url": "https://github.com/Kffhi"
          }
        },
        {
          "id": "IC_kwDODQzyOs53J5TY",
          "body": "在 React 中，Hooks 是一种特殊的函数，用于在函数组件中添加状态、生命周期等特性。Hooks 可以在函数组件的顶层使用，但不能在条件语句、循环语句或嵌套函数中使用。这是因为 Hooks 的使用依赖于 React 的调用顺序和内部状态的管理机制。\r\n\r\n下面是为什么不能在表达式中定义 React Hooks 的原因：\r\n\r\n1. **Hooks 必须在函数组件的顶层使用**：\r\n   - React Hooks 必须在 React 函数组件的顶层使用，而不是在函数的内部或表达式中使用。这是因为 React 依赖于 Hooks 的调用顺序来确定组件的状态和效果的正确应用。\r\n   - 如果在表达式中定义 Hooks，React 将无法确定 Hooks 的调用顺序，可能会导致状态错误或效果不一致。\r\n\r\n2. **Hooks 需要在每次渲染时保持稳定**：\r\n   - React Hooks 需要在每次组件渲染时保持稳定，以便能够正确地管理组件的状态和效果。\r\n   - 如果在表达式中定义 Hooks，它们的调用可能会随着表达式的求值而发生变化，这将破坏 React 的调用顺序和状态管理机制。\r\n\r\n因此，为了确保 React 组件的正确运行和状态管理，Hooks 必须在函数组件的顶层使用，而不能在表达式中定义。如果需要根据条件动态使用 Hooks，可以考虑使用条件渲染或自定义钩子来管理。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "juvenile-spec",
            "url": "https://github.com/juvenile-spec"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDU2MzU3MTc=",
    "number": 281,
    "title": "【Q279】display: inline 的元素设置 margin 和 padding 会生效吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxODQ3MjE4MQ==",
          "body": "可参考文章 http://maxdesign.com.au/articles/inline/\r\n\r\ninline 元素的 margin 与 padding 左右生效，上下生效，**准确说在上下方向不会使其它元素受到挤压，仿佛不生效**，如下图设置 border 会发现它其实生效了\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/119799247-7ba83280-bf0e-11eb-82ce-3cf6cab2ea41.png)\r\n\r\n代码为，可见于 [行内元素的padding与margin - codepen](https://codepen.io/shanyue/pen/poeraWQ)\r\n\r\n``` html\r\n<div class=\"container\">\r\n  我是<span class=\"item\">行内元素</span>白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。\r\n</div>\r\n```\r\n\r\n为 `.item` 行内元素设置样式，观察效果:\r\n\r\n``` css\r\n.item {\r\n  padding: 1rem;\r\n  border: 1px solid red;\r\n}\r\n\r\n.container {\r\n  margin: 3rem;\r\n  background-color: #ccc;\r\n  height: 10rem;\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTc0MzU2OA==",
          "body": "> inline 元素的 margin 与 padding 左右生效，上下不生效\r\n\r\n不是inline 下 margin 上下失效 ，padding 下 都生效吗 只不过不会撑大父元素而已 ",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "fariellany",
            "url": "https://github.com/fariellany"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYxNDk5ODQ=",
    "number": 282,
    "title": "【Q280】html 的默认 display 属性是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTc4ODU5Nw==",
          "body": "block      ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fariellany",
            "url": "https://github.com/fariellany"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MzM5NzAwOA==",
          "body": "内联元素: inline\r\n块级元素: block",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zzetao",
            "url": "https://github.com/zzetao"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzY1ODc0Ng==",
          "body": "`html` 根元素的默认 `display` 为 `block`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNjg3NTA=",
    "number": 283,
    "title": "【Q281】响应式布局需要注意哪一些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjI2NTUyOQ==",
          "body": "栅格布局？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Innocentw",
            "url": "https://github.com/Innocentw"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_84kz",
          "body": "media-query 媒体查询\r\nrem 相对长度单位，相对于html根元素\r\nvw/vh 网页视口高度和宽度",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Awalter0411",
            "url": "https://github.com/Awalter0411"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNzU0MDU=",
    "number": 284,
    "title": "【Q282】对一个非定长宽的块状元素如何做垂直水平居中",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTc3MTE2Ng==",
          "body": "flex布局",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "huxiamei",
            "url": "https://github.com/huxiamei"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMzQwMjA5NA==",
          "body": "定位\r\n`\r\n.parent{\r\n  position: relative;\r\n}\r\n.child{\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n transform: translate(-50%, -50%);\r\n}\r\n`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "XJHxjh0118",
            "url": "https://github.com/XJHxjh0118"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NjY0NDU2NQ==",
          "body": "css position\r\n```\r\n        .container {\r\n            position: relative;\r\n        }\r\n        .container .item {\r\n            width: 100px;\r\n            height: 50px;\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            bottom: 0;\r\n            right: 0;\r\n            margin: auto;\r\n        }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NTYzOTc2NA==",
          "body": "> css position\r\n> \r\n> ```\r\n>         .container {\r\n>             position: relative;\r\n>         }\r\n>         .container .item {\r\n>             width: 100px;\r\n>             height: 50px;\r\n>             position: absolute;\r\n>             top: 0;\r\n>             left: 0;\r\n>             bottom: 0;\r\n>             right: 0;\r\n>             margin: auto;\r\n>         }\r\n> ```\r\n\r\n非定宽了，你这个不行呀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44oocL",
          "body": "> > css position\r\n> > ```\r\n> >         .container {\r\n> >             position: relative;\r\n> >         }\r\n> >         .container .item {\r\n> >             width: 100px;\r\n> >             height: 50px;\r\n> >             position: absolute;\r\n> >             top: 0;\r\n> >             left: 0;\r\n> >             bottom: 0;\r\n> >             right: 0;\r\n> >             margin: auto;\r\n> >         }\r\n> > ```\r\n> \r\n> 非定宽了，你这个不行呀\r\n\r\n面试官说，做题前要好好读题。😭",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "IC_kwDODQzyOs455sDR",
          "body": "https://github.com/shfshanyue/Daily-Question/issues/10",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JR0Nl",
          "body": "```html\r\n<div class=\"parent\">\r\n  <div class=\"child\">123456</div>\r\n</div>\r\n```\r\n```css\r\n.parent {\r\n  display: flex;\r\n  height: 200px;\r\n  background-color: #222;\r\n}\r\n\r\n.child {\r\n  background-color: red;\r\n  margin: auto;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Kgqdx",
          "body": "```css\r\n---方法一:父级flex\r\n.container{\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n---方法二：父级grid\r\n.container{\r\n  display: grid;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n\r\n---方法三：父级定位，子maigin\r\n.container{\r\n  position: relative;\r\n}\r\n\r\n.container .item{\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n---方法四：父级定位，子位移\r\n.container{\r\n  position: relative;\r\n}\r\n\r\n.container .item{\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%,-50%);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "LIyu2001",
            "url": "https://github.com/LIyu2001"
          }
        },
        {
          "id": "IC_kwDODQzyOs5nUeeV",
          "body": "> ```css\r\n>  top: 0;\r\n>   bottom: 0;\r\n>   left: 0;\r\n>   right: 0;\r\n> ```\r\n方法三设置成和父元素一样大了，这符合题意吗？\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "perterHUAN",
            "url": "https://github.com/perterHUAN"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDg4NjE3NzM=",
    "number": 285,
    "title": "【Q283】http 请求头中的 X-Forwarded-For 代表什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTA2MzMzOQ==",
          "body": "`X-Forwarded-For` 被反向代理器生成，如 nginx，traefik 等，一般用作标识客户端真实的 IP 地址，目前已成为事实上的标准。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk0MzQwODA=",
    "number": 286,
    "title": "【Q284】prefetch 与 preload 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTUyODQ5OQ==",
          "body": "``` html\r\n<link rel=\"prefetch\" href=\"style.css\" as=\"style\">\r\n<link rel=\"preload\" href=\"main.js\" as=\"script\">\r\n```\r\n\r\n1. `preload` 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload\r\n1. `prefetch` 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link  做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\r\n\r\n> prefetch - Prefetch the page in the background. Defaults to true. Any <Link /> that is in the viewport (initially or through scroll) will be preloaded.\r\n\r\n更多信息可参考以下链接：\r\n\r\n+ [用 preload 预加载页面资源](https://juejin.im/post/5a7fb09bf265da4e8e785c38)\r\n+ [Using Preload and Prefetch in Your HTML to Load Assets](https://alligator.io/html/preload-prefetch/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        },
        {
          "id": "MDU6TGFiZWwzMDkwODMwMjI5",
          "name": "perf"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk3MTU2NjE=",
    "number": 287,
    "title": "【Q285】有没有做过裁剪头像图片的需求，如何实现",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5FFd0p",
          "body": "没有",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "awuyumian",
            "url": "https://github.com/awuyumian"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FcYtA",
          "body": "clip-path: circle(40%);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JunJD",
            "url": "https://github.com/JunJD"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk3NDM2NTY=",
    "number": 288,
    "title": "【Q286】在服务端应用中如何获得客户端 IP",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTcxNTI4NA==",
          "body": "**如果有 `x-forwarded-for` 的请求头，则取其中的第一个 IP，否则取建立连接 socket 的 remoteAddr。**\r\n\r\n而 `x-forwarded-for` 基本已成为了基于 proxy 的标准HTTP头，格式如下，可见第一个 IP 代表其真实的 IP，可以参考 MDN [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)\r\n\r\n``` js\r\nX-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178\r\nX-Forwarded-For: <client>, <proxy1>, <proxy2>\r\n```\r\n\r\n以下是 `koa` 获取 IP 的方法\r\n\r\n``` js\r\n  get ips() {\r\n    const proxy = this.app.proxy;\r\n    const val = this.get(this.app.proxyIpHeader);\r\n    let ips = proxy && val\r\n      ? val.split(/\\s*,\\s*/)\r\n      : [];\r\n    if (this.app.maxIpsCount > 0) {\r\n      ips = ips.slice(-this.app.maxIpsCount);\r\n    }\r\n    return ips;\r\n  },\r\n\r\n  get ip() {\r\n    if (!this[IP]) {\r\n      this[IP] = this.ips[0] || this.socket.remoteAddress || '';\r\n    }\r\n    return this[IP];\r\n  },\r\n```\r\n\r\n参见源码: <https://github.com/koajs/koa/blob/master/lib/request.js#L433>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTE5NDk0NDE=",
    "number": 289,
    "title": "【Q287】在 redis 中如何查看版本号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMzUyMTQ0OA==",
          "body": "``` bash\r\n$ redis-server -v\r\nRedis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=fbc6fab733127977\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTI1OTQ4Nzc=",
    "number": 290,
    "title": "【Q288】如何求数组中的 TOP k",
    "body": "求数组中的前 N 个最大的数",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyNDA1NDE1Nw==",
          "body": "1. 取数组中前 k 个数做小顶堆，堆化\r\n1. 数组中的其它数逐一与堆顶元素比较，若大于堆顶元素，则插入该数\r\n\r\n时间复杂度 O(nlg(k))",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3OTY1MDA5NQ==",
          "body": "实现一个优先队列类，默认大顶堆，传入(x,y)=>x>y比较函数则为小顶堆。\r\n首先将前k个数insert，之后的数字如果大于栈顶元素（栈顶元素为堆中最小值），delTop删除栈顶元素，然后insert该数。\r\n维护一个size为k的小顶堆。\r\n最后堆中元素即为数组中最大的k个元素。\r\n\r\n```javascript\r\nclass PriorityQueue {\r\n  constructor(\r\n    // 默认大顶堆\r\n    cmp = (x, y) => {\r\n      return x < y;\r\n    }\r\n  ) {\r\n    this.queue = [];\r\n    this.N = 0;\r\n    this.cmp = (i, j) => {\r\n      return cmp(this.queue[i], this.queue[j]);\r\n    };\r\n    this.parent = function (x) {\r\n      return Math.floor(x / 2);\r\n    };\r\n    this.left = function (x) {\r\n      return x * 2;\r\n    };\r\n    this.right = function (x) {\r\n      return x * 2 + 1;\r\n    };\r\n    this.exch = (x, y) => {\r\n      let temp = this.queue[x];\r\n      this.queue[x] = this.queue[y];\r\n      this.queue[y] = temp;\r\n    };\r\n  }\r\n  swim(k) {\r\n    const { cmp, parent, exch } = this;\r\n    while (k > 1 && cmp(parent(k), k)) {\r\n      exch(parent(k), k);\r\n      k = parent(k);\r\n    }\r\n  }\r\n  sink(k) {\r\n    const { left, right, exch, N, cmp } = this;\r\n    while (left(k) <= N) {\r\n      let older = left(k);\r\n      if (right(k) <= N && cmp(older, right(k))) {\r\n        older = right(k);\r\n      }\r\n      if (cmp(older, k)) break;\r\n      exch(older, k);\r\n      k = older;\r\n    }\r\n  }\r\n  top() {\r\n    return this.queue[1];\r\n  }\r\n  delTop() {\r\n    const { queue, exch } = this;\r\n    let top = queue[1];\r\n    exch(1, this.N);\r\n    queue.pop();\r\n    this.N--;\r\n    this.sink(1);\r\n    return top;\r\n  }\r\n  insert(x) {\r\n    this.N++;\r\n    this.queue[this.N] = x;\r\n    this.swim(this.N);\r\n  }\r\n  size() {\r\n    return this.N;\r\n  }\r\n}\r\n\r\nfunction TopK(arr, k) {\r\n  // 传入cmp，设置为小顶堆\r\n  let pq = new PriorityQueue((x, y) => x > y);\r\n  let i = 0;\r\n  for (i = 0; i < k; i++) {\r\n    pq.insert(arr[i]);\r\n  }\r\n  for (; i < arr.length; i++) {\r\n    if (arr[i] > pq.top()) {\r\n      pq.delTop();\r\n      pq.insert(arr[i]);\r\n    }\r\n  }\r\n  console.log(\"TOP K应为：\", arr.sort((a, b) => b - a).splice(0, k));\r\n\r\n  console.log(\"求出的TOP k：\");\r\n  // 排序，整理，方便对照\r\n  pq.queue.sort((a, b) => b - a).pop();\r\n  console.log(pq.queue);\r\n}\r\nlet arr = [10, 15, 2, 6, 4, 5, 7, 3, 6, 14, 3, 12, 14, 13, 16, 1, 8];\r\nTopK(arr, 10);\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manyyuri",
            "url": "https://github.com/manyyuri"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTcxNzQ=",
    "number": 291,
    "title": "【Q289】Node 中循环引用会发生什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MDY4MTUyNg==",
          "body": "在 CommonJS 规范中，当遇到`require()`语句时，会执行`require`模块中的代码，并缓存执行的结果，当下次再次加载时不会重复执行，而是直接取缓存的结果。正因为此，出现循环依赖时才不会出现无限循环调用的情况。\r\n\r\n``` js\r\n// a.js\r\nconst { b } = require(\"./b\");\r\n\r\nconst a = 11;\r\n\r\nconsole.log('b in a.js', b);\r\n\r\nmodule.exports = { a };\r\n```\r\n\r\n``` js\r\n// b.js\r\nconst { a } = require(\"./a\");\r\n\r\nconst b = 12;\r\n\r\nconsole.log('a in b.js', a);\r\nsetTimeout(() => {\r\n  console.log('a in b.js', a);\r\n}, 1000);\r\n\r\nmodule.exports = { b };\r\n```\r\n\r\n当执行`node a.js`时：\r\n``` shell\r\na in b.js is undefined\r\nb in a.js is 12\r\n(node:23352) Warning: Accessing non-existent property 'a' of module exports inside circular dependency    \r\n(Use `node --trace-warnings ...` to show where the warning was created)\r\na in b.js is undefined\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTk3MTY1OA==",
          "body": "@mrrs878 在 b.js 代码示例中有一个拼写错误",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjI2NTQ2OQ==",
          "body": "@shfshanyue 感谢老哥指正，已修改",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTc0Nzg=",
    "number": 292,
    "title": "【Q290】Node 中 require 时发生了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4074Kq",
          "body": "[http://nodejs.cn/api/modules.html#modules_all_together](http://nodejs.cn/api/modules.html#modules_all_together)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VkkxG",
          "body": "3个步骤：路径分析、模块定位、编译执行\r\n\r\n按顺序加载：系统缓存→系统模块→文件模块→目录模块→node_modules目录",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTU4MjgwMzc=",
    "number": 293,
    "title": "【Q291】简述 node/v8 中的垃圾回收机制",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MzkzMjE3OA==",
          "body": "`v8` 中的垃圾回收机制分为三种\r\n\r\n1. `Scavenge`，工作在新生代，把 `from space` 中的存活对象移至 `to space`\r\n1. `Mark-Sweep`，标记清除。新生代的某些对象由于过度活跃会被移至老生代，此时对老生代中活对象进行标记，并清理死对象\r\n1. `Mark-Compact`，标记整理。\r\n\r\n## 相关链接\r\n\r\n1. [主流的垃圾回收机制都有哪些?](https://www.zhihu.com/question/32373436)\r\n1. [各种编程语言的实现都采用了哪些垃圾回收算法](https://www.zhihu.com/question/20018826)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs49qGKI",
          "body": "当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。\r\n要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。\r\n代际假说（The Generational Hypothesis），是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。\r\n代际假说有以下两个特点：\r\n1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；\r\n2. 是不死的对象，会活得更久。\r\n在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。\r\n● 副垃圾回收器，主要负责新生代的垃圾回收。\r\n● 主垃圾回收器，主要负责老生代的垃圾回收。\r\n\r\n全停顿\r\n![1620974853612-a480b43e-b3bb-452f-a502-3a0162548a7f](https://user-images.githubusercontent.com/19986739/153329224-c2120a5d-4f25-4659-9347-d6217d5a5ce8.png)\r\n\r\n增量标记\r\n![1620975019709-efc33748-fbfc-4fb5-a19d-97abadbf8f97](https://user-images.githubusercontent.com/19986739/153329251-e6a21086-f646-48d5-a23c-c2e3351497ef.png)\r\n\r\n使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，增强用户体验。\r\n\r\n参考： [浏览器工作原理与实践](https://time.geekbang.org/column/article/131233)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wjw-gavin",
            "url": "https://github.com/wjw-gavin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMwNjE1NDk=",
    "number": 294,
    "title": "【Q292】peerDependency 是为了解决什么问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMjc3NDYyOA==",
          "body": "<https://indepth.dev/npm-peer-dependencies/>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgxNjUwMjU4Mw==",
          "body": "避免重复安装",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "micro-kid",
            "url": "https://github.com/micro-kid"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMzMTk4NDM=",
    "number": 295,
    "title": "【Q293】semver 指什么，试图解释一下",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4-9_Wg",
          "body": "语义化版本号。版本格式：主版本号.次版本号.修订号",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjM4NDQzODI=",
    "number": 296,
    "title": "【Q294】optionalDependencies 的使用场景是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMzIxOTM3Mg==",
          "body": "当一个包是可依赖可不依赖时，可采用 `optionalDependencies`，但需要在代码中做好异常处理。\r\n\r\n如 [chokidar](https://github.com/paulmillr/chokidar) 对 `fsevents` 的引入\r\n\r\n``` json\r\n{\r\n  \"optionalDependencies\": {\r\n    \"fsevents\": \"~2.1.2\"\r\n  }\r\n}\r\n```\r\n\r\n``` js\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ2OTc5NDY=",
    "number": 297,
    "title": "【Q295】fetch 中 credentials 指什么意思，可以取什么值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMzg4ODYyNQ==",
          "body": "`credentials` 指在使用 `fetch` 发送请求时是否应当发送 `cookie`\r\n\r\n+ `omit`: 从不发送 `cookie`.\r\n+ `same-origin`: 同源时发送 `cookie`  (浏览器默认值)\r\n+ `include`: 同源与跨域时都发送 `cookie`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JyR5x",
          "body": "标题单词拼错了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shen076",
            "url": "https://github.com/shen076"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MzDBk",
          "body": "@shen076 已修正",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ5NDM2NDc=",
    "number": 298,
    "title": "【Q296】package-lock.json 与 yarn.lock 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjUzODM5MzY=",
    "number": 299,
    "title": "【Q297】服务器的平均负载如何计算",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNDQzNTExOA==",
          "body": "`load average` 指单位时间内运行态进程及不可中断进程的平均进程数，运行态进程指正在使用或者\r\n 等待使用 CPU 的进程，不可中断进程指正等待一些 IO 操作的进程。可使用 `uptime` 查看此指标。\r\n\r\n ```bash\r\n $ uptime\r\n  16:48:09 up 2 days, 23:43,  2 users,  load average: 0.01, 0.21, 0.20\r\n ```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU0NzI2ODk=",
    "number": 300,
    "title": "【Q298】如何创建一个进程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTA1NTY0NQ==",
          "body": "+ `exec`\r\n+ `fork`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        },
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjAzNTQ=",
    "number": 301,
    "title": "【Q299】serverless 中如何得知目前扩容了多少个实例",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
          "name": "serverless"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjEwMzM=",
    "number": 302,
    "title": "【Q300】node 中 exec，fork 与 spawn 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5Vkk0t",
          "body": "- child_process.spawn()：适用于返回大量数据\r\n    \r\n    ```jsx\r\n    const spawn = require('child_process').spawn;\r\n    const child = spawn('ls', ['-l'], { cwd: '/usr' });\r\n    child.stdout.pipe(process.stdout);\r\n    console.log(process.pid, child.pid);\r\n    ```\r\n    \r\n- child_process.exec()：执行命令，有回调函数获知进程情况，可设置超时\r\n    \r\n    ```jsx\r\n    const exec = require('child_process').exec;\r\n    exec(`node -v`, (err, stdout, stderr) => {\r\n      console.log({ err, stdout, stderr });\r\n      // { err: null, stdout: 'v16.14.2\\n', stderr: '' }\r\n    });\r\n    ```\r\n    \r\n- child_process.execFile()：执行可执行文件\r\n    \r\n    ```jsx\r\n    const execFile = require('child_process').execFile;\r\n    execFile('node', ['-v'], (error, stdout, stderr) => {\r\n      console.log({ error, stdout, stderr });\r\n    });\r\n    ```\r\n    \r\n- child_process.fork()：执行js文件，衍生新的进程，每个进程都有自己的实例、内存\r\n    \r\n    ```jsx\r\n    const fork = require('child_process').fork;\r\n    fork('./worker.js');\r\n    ```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyMjAyMjg=",
    "number": 303,
    "title": "【Q301】base64 由哪64个字符构成",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTEwNjk2NQ==",
          "body": "`A-Z`，`a-z`，`0-9`，`+`，`/`",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs407lFS",
          "body": "[https://www.ruanyifeng.com/blog/2008/06/base64.html](https://www.ruanyifeng.com/blog/2008/06/base64.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNTg4NDQ=",
    "number": 304,
    "title": "【Q302】多服务器的系统时间不一致如何解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTIzODU5OA==",
          "body": "ntp服务",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "vincent-sk",
            "url": "https://github.com/vincent-sk"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzY4MDA=",
    "number": 305,
    "title": "【Q303】在 k8s 中如何自定义 CRD 资源",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzc5OTc=",
    "number": 306,
    "title": "【Q304】service mesh 是什么，能够解决什么问题",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjgxMzczMzQ=",
    "number": 307,
    "title": "【Q305】如何删除项目中没有使用到的 package",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNjYwMjUzMQ==",
          "body": "可以采用 [depcheck](https://github.com/depcheck/depcheck) 来完成这件事\r\n\r\n``` js\r\n$ npm install depcheck -g\r\n\r\n$ depcheck\r\nUnused dependencies\r\n* underscore\r\nUnused devDependencies\r\n* jasmine\r\nMissing dependencies\r\n* lodash\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTQ1OTU=",
    "number": 308,
    "title": "【Q306】如何实现左右固定，中间自适应布局",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxMTkzOA==",
          "body": "可以参考 [【Q017】css 如何实现左侧固定300px，右侧自适应的布局](https://github.com/shfshanyue/Daily-Question/issues/18)\r\n\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n  .right\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.right {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjI2Mzk3Mw==",
          "body": "```\r\n.box {\r\ndisplay: flex\r\n}\r\n\r\n\r\n.left,.right {\r\nwidth: 300px\r\n}\r\n\r\n.center {\r\nflex: 1\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Innocentw",
            "url": "https://github.com/Innocentw"
          }
        },
        {
          "id": "IC_kwDODQzyOs44oof-",
          "body": "以前还要用圣杯和双飞翼，现在都直接 flex 了。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_iLyo",
          "body": "```\r\n <div class=\"container\">\r\n        <div class=\"left\"></div>\r\n        <div class=\"main\"></div>\r\n        <div class=\"right\"></div>\r\n  </div>\r\n```\r\n\r\n```\r\n<style>\r\n    /* grid布局 */\r\n    \r\n    .container {\r\n        height: 20rem;\r\n        margin: 2rem;\r\n        background-color: #eeeeee;\r\n        display: grid;\r\n        grid-template-columns: 300px 1fr 300px;\r\n    }\r\n   \r\n    .left {\r\n        height: 100%;\r\n        border: 1px solid black;\r\n    }\r\n    \r\n    .main {\r\n        height: 100%;\r\n    }\r\n    \r\n    .right {\r\n        height: 100%;\r\n        border: 1px solid;\r\n    }\r\n</style>\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Lonely-bear",
            "url": "https://github.com/Lonely-bear"
          }
        },
        {
          "id": "IC_kwDODQzyOs5AU2S2",
          "body": "楼上应该去掉height",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "YanCoeder1",
            "url": "https://github.com/YanCoeder1"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTU0MjE=",
    "number": 309,
    "title": "【Q307】如何实现表格单双行条纹样式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNzQ1MjAyOA==",
          "body": "通过 `css3` 中伪类 `:nth-child` 来实现。其中 `:nth-child(an+b)` 匹配下标 `{ an + b; n = 0, 1, 2, ...} ` 且结果为整数的子元素\r\n\r\n+ `nth-child(2n)`/`nth-child(even)`: 双行样式\r\n+ `nth-child(2n+1)`/`nth-child(odd)`: 单行样式\r\n\r\n其中 `tr` 在表格中代表行，实现表格中单双行样式就很简单了：\r\n\r\n``` css\r\ntr:nth-child(2n) {\r\n  background-color: red;\r\n}\r\n\r\n\r\ntr:nth-child(2n+1) {\r\n  background-color: blue;\r\n}\r\n```\r\n\r\n同理：\r\n\r\n1. 如何匹配最前三个子元素: `:nth-child(-n+3)`\r\n1. 如何匹配最后三个子元素: `:nth-last-child(-n+3)`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5LYWso",
          "body": "不是有odd和even吗\r\n```css\r\ntr:nth-child(even) {background: #CCC}\r\ntr:nth-child(odd) {background: #FFF}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "nanwangjkl",
            "url": "https://github.com/nanwangjkl"
          }
        },
        {
          "id": "IC_kwDODQzyOs5LYWt2",
          "body": "已收到你的邮件，谢谢~~~",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "songcee",
            "url": "https://github.com/songcee"
          }
        },
        {
          "id": "IC_kwDODQzyOs5LYWuA",
          "body": "这是来自QQ邮箱的假期自动回复邮件。你好，我最近正在休假中，无法亲自回复你的邮件。我将在假期结束后，尽快给你回复。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "loveminxo",
            "url": "https://github.com/loveminxo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMDIxMjI=",
    "number": 310,
    "title": "【Q308】node 中 dns.resolve 及 dns.lookup 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44t5J5",
          "body": "`dns.resolve` 返回指定类型或全部类型的dns解析记录，如`A记录`, `CNAME`记录, `MX`记录\r\n`dns.lookup`返回`A记录`(IPv4)或`AAAA记录`(IPv6)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "thundernet8",
            "url": "https://github.com/thundernet8"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-z7Aw",
          "body": "dns.resolve为内核api，无需占用thread pool，优先级更高\r\ndns.lookup为thread pool api，占用thread pool，影响线程池方法（例如fs模块方法等）",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "paul-wj",
            "url": "https://github.com/paul-wj"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMTMxNDk=",
    "number": 311,
    "title": "【Q309】简述下 css specificity",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxNjUyMA==",
          "body": "`css specificity` 即 css 中关于选择器的权重，以下三种类型的选择器依次下降\r\n\r\n1. `id` 选择器，如 `#app`\r\n1. `class`、`attribute` 与 `pseudo-classes` 选择器，如 `.header`、`[type=\"radio\"]` 与 `:hover`\r\n1. `type` 标签选择器和伪元素选择器，如 `h1`、`p` 和 `::before`\r\n\r\n其中通配符选择器 `*`，组合选择器 `+ ~ >`，否定伪类选择器 `:not()` 对优先级无影响\r\n\r\n另有内联样式 `<div class=\"foo\" style=\"color: red;\"></div>` 及 `!important`(最高) 具有更高的权重\r\n\r\n> [`:not` 的优先级影响 - codepen](https://codepen.io/shanyue/pen/dyGQqBe) 可以看出 `:not` 对选择器的优先级无任何影响\r\n\r\n> [CSS Specificity - codepen](https://codepen.io/shanyue/pen/XWMRQOw) 可以看出十几个 class 选择器也没有一个 id 选择器权重高",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkyNzA3MDM=",
    "number": 312,
    "title": "【Q310】Node 中 require json 文件数据时，如何当文件更新时，重新 require",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44t5bG",
          "body": "```js\r\nfunction requireUncached(module) {\r\n    delete require.cache[require.resolve(module)];\r\n    return require(module);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "thundernet8",
            "url": "https://github.com/thundernet8"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk3NzA2MTI=",
    "number": 313,
    "title": "【Q311】当 cookie 没有设置 maxage 时，cookie 会存在多久",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MjI2OTQ2OQ==",
          "body": "不设置max-age和expires，此cookie就是会话级别的，浏览器关闭就没了\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lznbuild",
            "url": "https://github.com/lznbuild"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk4NTYxMjY=",
    "number": 314,
    "title": "【Q312】如何实现 Promise.race",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs438nD_",
          "body": "```javascript\r\nPromise.race = (promiseArray) => {\r\n  return new Promise((resolve, reject) => {\r\n    promiseArray.forEach((item) => {\r\n      Promise.resolve(item).then( val => { \r\n        resolve(val)\r\n      }, reason => {\r\n        reject(reason)\r\n      })\r\n    })\r\n  })\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA0NjU4MTY=",
    "number": 315,
    "title": "【Q313】在浏览器中如何获取剪切板中内容",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MDk4NTczMg==",
          "body": "通过 `Clipboard API` 可以获取剪切板中内容，但需要获取到 `clipboard-read` 的权限，以下是关于读取剪贴板内容的代码：\r\n\r\n``` js\r\n// 是否能够有读取剪贴板的权限\r\n// result.state == \"granted\" || result.state == \"prompt\"\r\nconst result = await navigator.permissions.query({ name: \"clipboard-read\" })\r\n\r\n// 获取剪贴板内容\r\nconst text = await navigator.clipboard.readText()\r\n```\r\n\r\n > 注: 该方法在 `devtools` 中不生效\r\n\r\n相关问题: [【Q019】如何实现选中复制的功能](https://github.com/shfshanyue/Daily-Question/issues/20)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA2ODYyNDE=",
    "number": 316,
    "title": "【Q314】source 与 sh 执行脚本时有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs42wuOI",
          "body": "source 执行是在当前环境下执行\r\nsh执行会新开一个子运行环境，结束后子脚本中的变量无法访问\r\n因此当配置.zshrc这种文件时，通常会source一下",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTA5NjQyNTA2",
          "name": "shell"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDY1OTY=",
    "number": 317,
    "title": "【Q315】'+' 与 '~' 选择器有什么不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MTMzNDkzOQ==",
          "body": "+ `+` 选择器匹配紧邻的兄弟元素\r\n+ `~` 选择器匹配随后的所有兄弟元素",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Dou3_",
          "body": "### ~ + 选择器不同之处\r\n`~` 是匹配元素之后的选择器\r\n\r\n`+` 是匹配相邻元素选择器\r\n\r\n```html\r\n<div>我是div</div>\r\n    <p>我是p</p>\r\n    <p>我是p</p>\r\n    <div>我是div</div>\r\n    <p>我是p</p>\r\n    <div>\r\n        <p>我是div下面的p</p>\r\n        <p>我是div下面的p</p>\r\n    </div>\r\n    <span>我是span</span>\r\n```\r\n\r\n```css\r\n\r\n<style>\r\n    div+p {\r\n        color: red;\r\n    }\r\n\r\n    /* 第一个p标签变红色了 */\r\n\r\n    div~p{\r\n        color:red;\r\n    }\r\n\r\n    /* div后面的p标签都变成红色了 */\r\n</style>\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "QC2168",
            "url": "https://github.com/QC2168"
          }
        },
        {
          "id": "IC_kwDODQzyOs5T9gLx",
          "body": "div后相邻的p标签文字都会变红，而不是只有第一个p标签变红\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Psycho-Monster",
            "url": "https://github.com/Psycho-Monster"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YJ-PN",
          "body": "```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>title</title>\r\n    <style>\r\n      /* + 选择器选取紧接着的相邻连续兄弟元素 */\r\n      .d1 p + p {\r\n        color: red;\r\n      }\r\n\r\n      /* ~ 选择器选取后面所有的同级兄弟元素 */\r\n      .d2 p ~ p {\r\n        font-weight: bold;\r\n      }\r\n    </style>\r\n  </head>\r\n\r\n  <body>\r\n    <div class=\"d1\">\r\n      <p>第一个段落</p>\r\n      <p>第二个段落</p>\r\n      <p>第二个段落</p>\r\n      <span>span</span>\r\n      <p>第三个段落</p>\r\n    </div>\r\n    <br />\r\n    <div class=\"d2\">\r\n      <p>第一个段落</p>\r\n      <p>第二个段落</p>\r\n      <span>span</span>\r\n      <p>第三个段落</p>\r\n    </div>\r\n  </body>\r\n</html>\r\n\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/9338717/226824998-d0061db1-e9fb-4d82-8ac5-c6e2d80ad019.png)\r\n\"+\" 选择器匹配紧邻的连续兄弟元素，这样描述更准确",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yxw007",
            "url": "https://github.com/yxw007"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDg1MTU=",
    "number": 318,
    "title": "【Q316】node 中如何查看函数异步调用栈",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5gNrvs",
          "body": "const async_hooks = require('async_hooks');\r\n\r\n// 创建一个 AsyncHooks 实例\r\nconst asyncHook = async_hooks.createHook({ init, destroy });\r\n\r\n// 初始化回调函数\r\nfunction init(asyncId, type, triggerAsyncId, resource) {\r\n  const currentStack = new Error().stack;\r\n  console.log(`Init asyncId: ${asyncId}, type: ${type}, stack: ${currentStack}`);\r\n}\r\n\r\n// 销毁回调函数\r\nfunction destroy(asyncId) {\r\n  console.log(`Destroy asyncId: ${asyncId}`);\r\n}\r\n\r\n// 启用 AsyncHooks 实例\r\nasyncHook.enable();",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "z54749412",
            "url": "https://github.com/z54749412"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTAzMTY=",
    "number": 319,
    "title": "【Q317】有哪些 css 属性不能展示动画效果",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_843D",
          "body": "display,height\r\ncss不能在display:none和display:block之间进行动画，也不能在height:0和height:auto之间进行动画",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Awalter0411",
            "url": "https://github.com/Awalter0411"
          }
        },
        {
          "id": "IC_kwDODQzyOs5b714H",
          "body": "https://juejin.cn/post/6917061427958120461 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "darkboom",
            "url": "https://github.com/darkboom"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTI3ODk=",
    "number": 320,
    "title": "【Q318】如何设计 prometheus 中的 metric",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTMxNzg=",
    "number": 321,
    "title": "【Q319】css 动画与 js 动画哪个性能更好",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4NTQzNjIzMQ==",
          "body": "CSS3的动画：\r\n　　1.在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化（比如专门新建一个图层用来跑动画）\r\n　　2.代码相对简单\r\n　　3.在动画控制上不够灵活\r\n　　4.兼容性不好\r\n　　5.部分动画功能无法实现（如滚动动画，视差滚动等）\r\nJavaScript的动画：\r\n      正好弥补了css缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。\r\n总结：\r\n       对于一些复杂控制的动画，使用javascript会比较好。而在实现一些小的交互动效的时候，可以多考虑CSS",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1178518969",
            "url": "https://github.com/1178518969"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTQzNzI=",
    "number": 322,
    "title": "【Q320】如何衡量 serverless 的冷启动时间",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
          "name": "serverless"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTk1Njk=",
    "number": 323,
    "title": "【Q321】 css 中属性选择器及类选择器的权重哪个高",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4NTQ0Nzc2Mw==",
          "body": ".box  权重是10  ，div[class=box]权重可以看成11\r\ndiv .box 和 div[class=box]权重是一样的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1178518969",
            "url": "https://github.com/1178518969"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NDA0OTYwMQ==",
          "body": "参考 [css specificity](https://github.com/shfshanyue/Daily-Question/issues/311)，它俩选择器群众一样高\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA4NjYwNDg=",
    "number": 324,
    "title": "【Q322】有没有接触过 fs-extra，它是解决什么问题的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5NlqjH",
          "body": "fs-extra是fs的一个扩展，提供了非常多的便利API，并且继承了fs所有方法和为fs方法添加了promise的支持。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzE1MDA4MzQ=",
    "number": 325,
    "title": "【Q323】在 k8s 中如何通过日志查看某条请求进入的 pod",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzQyNTk1NjY=",
    "number": 327,
    "title": "【Q324】为什么会发生样式抖动",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5B3TLb",
          "body": "因为没有指定元素具体高度和宽度,比如数据还没有加载进来时元素高度是100px(假设这里是100px),数据加载进来后,因为有了数据,然后元素被撑大,所有出现了抖动",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "caro1xxx",
            "url": "https://github.com/caro1xxx"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzQzMjgzOTQ=",
    "number": 328,
    "title": "【Q325】关于 cors 的响应头有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MTYxNjcwNQ==",
          "body": "- `Access-Control-Allow-Origin`\r\n- `Access-Control-Allow-Methods`\r\n- `Access-Control-Allow-Headers`\r\n- `Access-Control-Allow-Credentials`\r\n- `Access-Control-Expose-Headers`\r\n- `Access-Control-Max-Age`\r\n\r\n关于如何写一个 `cors` 的中间件可以参考 [koajs/cors](https://github.com/koajs/cors)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUwODMwMTU=",
    "number": 329,
    "title": "【Q326】如何发现 redis 中的 bigkey",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5E0n9Z",
          "body": "use redis_cli command: redis-cli -h -a --bigkeys.",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liyihang",
            "url": "https://github.com/liyihang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUzMzk3NTg=",
    "number": 330,
    "title": "【Q327】如何避免 CDN 为 PC 端缓存移动端页面",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NzE1NTk1OA==",
          "body": "如果 PC 端和移动端是一套代码则不会出现这个问题。**这个问题出现在 PC 端和移动端是两套代码，却共用一个域名。**\r\n\r\n使用 `nginx` 配置如下，根据 UA 判断是否移动端，而走不同的逻辑 (判断UA是否移动端容易出问题)\r\n\r\n``` conf\r\nlocation / {\r\n    // 默认 PC 端\r\n    root /usr/local/website/web;\r\n    \r\n    # 判断 UA，访问移动端\r\n    if ( $http_user_agent ~* \"(Android|webOS|iPhone|iPad|BlackBerry)\" ){ \r\n        root /usr/local/website/mobile;\r\n    }\r\n \r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\n解决方案通常使用 `Vary` 响应头，来控制 CDN 对不同请求头的缓存。\r\n\r\n**此处可以使用 `Vary: User-Agent` ，代表如果 User-Agent 不一样，则重新发起请求，而非从缓存中读取页面**\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n当然，`User-Agent` 实在过多，此时缓存失效就会过多。\r\n\r\n## 简答\r\n\r\n使用 `Vary: User-Agent`，根据 UA 进行缓存。\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n但最好不要出现这种情况，PC 端和移动端如果是两套代码，建议用两个域名，理由如下\r\n\r\n1. `nginx` 判断是否移动端容易出错\r\n1. 对缓存不友好\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUzNDI3Mzk=",
    "number": 331,
    "title": "【Q328】简述 bloomfilter，及它的使用场景是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5E-yHR",
          "body": "一个以计算来换取空间的概率算法，分配一个连续的内存 （m 位的位数组），将目标通过k个hash函数，每个hash函数映射到位数组上。查询时通过所有的k个hash函数计算是否为1。只要有一个0 则不存在，全部为1也不是一定存在。所以bloomfilter适合希望减少内存占用，但允许判断存在True出现误判。不允许误差的使用的场景是在缓存或数据库的上层加上bloomfilter，判断是否存在，如果不存在就不去操作缓存或者数据库层。允许误差的情况下使用场景就较多，可以参考redis set的使用场景。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liazylee",
            "url": "https://github.com/liazylee"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
          "name": "data-structure"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0ODUwMTQ=",
    "number": 332,
    "title": "【Q329】什么是一致性哈希，可以解决什么问题",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
          "name": "data-structure"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTU1NDQ=",
    "number": 333,
    "title": "【Q330】mysql 如何开启及查看慢查询日志",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5Wuhpc",
          "body": "slow_query_log：是否启用慢查询日志，默认为0，可设置为0、1，1表示开启。\r\nslow_query_log_file：慢查询日志存放的位置，需要MySQL运行账号的可写权限。\r\nlong_query_time：定义慢查询的时间阈值，单位为秒，默认为10。\r\n\r\n如果要查看慢查询日志，你可以直接打开slow_query_log_file指定的文件或者使用工具如pt-query-digest进行分析",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Palai-s",
            "url": "https://github.com/Palai-s"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTcwMDI=",
    "number": 334,
    "title": "【Q331】当分页10000页时数据库查询 offset 过大如何解决性能问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5lmPC8",
          "body": "当数据库查询的 offset 过大时，数据库需要扫描和跳过大量的数据记录，这会导致查询时间显著增加。以下是一些解决性能问题的建议：\r\n\r\n1. 优化查询语句：确保查询语句是有效的和优化的。避免使用复杂的查询语句，而是使用简单的查询语句来检索所需的数据。\r\n2. 使用索引：为经常用于查询的列创建索引。索引可以大大提高查询性能，特别是在处理大量数据时。\r\n3. 批量处理：如果可能，尝试批量处理数据，而不是一次处理大量数据。这可以通过分批处理查询或使用批量插入/更新操作来实现。\r\n4. 分页查询：如果必须使用分页查询，考虑使用基于游标的分页方式，而不是使用 offset 和 limit。游标可以更高效地跳转和管理分页数据。\r\n5. 分区表：如果表的数据量非常大，考虑使用分区表。将数据分成多个逻辑分区可以提高查询性能，因为查询只需要扫描相关的分区。\r\n6. 调整数据库配置：根据数据库的类型和配置，可以调整一些参数来优化性能。例如，可以增加缓冲区大小、调整内存分配等。\r\n7. 使用缓存：如果可能，将常用的数据存储在缓存中，以减少对数据库的查询次数。缓存可以显著提高查询性能，特别是在处理大量数据时。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zcrchong",
            "url": "https://github.com/zcrchong"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTg5MTA=",
    "number": 335,
    "title": "【Q332】当数据库进行版本升级时，如何进行数据迁移",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5stnQx",
          "body": "数据库版本升级时的数据迁移通常需要考虑以下几个步骤：\r\n\r\n备份数据： 在进行任何数据库操作之前，首先要确保备份数据，以防意外情况发生。\r\n数据库 Schema 升级： 如果数据库升级涉及到表结构的变化，需要执行相应的 SQL 脚本或使用数据库迁移工具（如 Flyway、Liquibase 等）来更新数据库 schema。这可能包括添加、修改或删除表、列、索引等。\r\n数据迁移脚本： 如果升级需要迁移现有数据，可以编写数据迁移脚本来将旧数据转移到新的表结构中。这可能涉及到数据格式的调整、合并或拆分等。\r\n应用程序代码升级： 如果升级会影响到应用程序代码（例如 SQL 查询的变化），确保应用程序代码也进行相应的升级。这可能需要修改 ORM 映射、数据库访问层的代码等。\r\n测试： 在正式进行数据库版本升级之前，务必在开发或测试环境中进行全面的测试，确保新的数据库版本和数据迁移脚本没有引入问题。\r\n逐步升级： 如果可能，可以采用逐步升级的方式，先升级测试环境，然后观察应用程序的行为和性能。如果一切正常，再升级生产环境。\r\n监控和回滚计划： 在进行生产环境升级时，监控数据库性能、应用程序行为等，准备好可能的回滚计划，以便在出现问题时能够迅速回滚到之前的版本。\r\n通知团队： 在进行数据库版本升级之前，通知相关团队的成员，确保大家都了解升级的计划和可能的影响。\r\n执行升级： 在完成所有准备工作后，执行数据库版本升级。在升级期间，要谨慎处理数据库连接池、事务处理等问题，以确保平滑过渡。\r\n验证和优化： 完成升级后，验证应用程序的行为是否正常，性能是否符合预期。如果有必要，进行进一步的优化。\r\n文档更新： 更新相关文档，包括数据库 schema 文档、应用程序代码文档等，以反映新的数据库版本和数据结构。\r\n\r\n每个数据库系统和应用程序架构可能有特定的注意事项和最佳实践，因此在进行数据库版本升级时，务必根据具体情况采取适当的措施。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzY0NTM=",
    "number": 336,
    "title": "【Q333】mysql 是如何实现 MVCC 的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5Wuh2Q",
          "body": "MySQL是通过在每行记录后面保存两个隐藏的列来实现MVCC的。这两个列分别是：\r\n\r\nDB_TRX_ID：表示最后修改该行记录的事务ID。\r\nDB_ROLL_PTR：表示指向该行记录上一个版本的指针。\r\n当一个事务要读取一行记录时，它会根据自己的Read View（一个存储了当前活跃事务ID列表的数据结构）来判断该行记录是否对自己可见。如果不可见，它会通过DB_ROLL_PTR找到undo log中的历史版本，并判断是否可见，直到找到合适的版本或者没有更早的版本为止\r\n\r\n这样，每个事务都可以看到数据在某个时间点的快照，从而保证了数据一致性和访问性能。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Palai-s",
            "url": "https://github.com/Palai-s"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzk4NTc=",
    "number": 337,
    "title": "【Q334】position: sticky 如何工作，适用于哪些场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MTk0OTUzMA==",
          "body": "`position: sticky` 可理解为 `relative` 与 `fixed` 的结合体",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-f8qY",
          "body": "MDN的解释：position: sticky 在正常文档流中仍然保有位置，然后会相对于它的最近的滚动祖先和最近的块级祖先根据 top, left, right, bottom 的值进行偏移。元素偏移不会影响其他任何元素的位置，因为会为该元素创建一个新的层叠上下文，从而不会影响到页面上的其他元素\r\n\r\ncss-tricks一篇文章的理解：在窗口的管轮向下滚动没有让该元素完全消失前，该元素的表现就与postion:relative的元素相同，之后该元素的表现就类似于position: fixed 的元素， 只不过该元素是相对于离他最近的滚轮祖先\r\n\r\nReference: \r\nDocs: https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\r\nCode: https://css-tricks.com/almanac/properties/p/position/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CsongL",
            "url": "https://github.com/CsongL"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODE2NDM=",
    "number": 338,
    "title": "【Q335】什么是层叠上下文 (stacking contect)，谈谈对它的理解",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5AFD-t",
          "body": "https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Fengjing95",
            "url": "https://github.com/Fengjing95"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODgzNDQ=",
    "number": 339,
    "title": "【Q336】你用 css 实现过什么不错的效果",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODkzNzY=",
    "number": 340,
    "title": "【Q337】你做前端有多少时间花在写 css 上",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjE5NzQ4NQ==",
          "body": "非常多",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Innocentw",
            "url": "https://github.com/Innocentw"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTIzNTk5NA==",
          "body": "如果说是开发阶段，我会用 20%-30% 的时间写 CSS。\r\n\r\n比你想象的时间更少？\r\n1. 我们开发的是一套内部的管理系统。\r\n2. 其中一个原因是在 UI 设计时遵循了 element-ui 的规范，而开发使用的 UI 框架为 element-ui，因此大多数的界面并不需要写大量的 CSS，因为预设样式已足够使用。\r\n3. 另外一个不得不提的原因是，针对业务场景，我们开发了一批公共组件，剩余的开发部分只需要对组件进行排列组合即可。\r\n4. 最后是，我们的系统对动效的要求不高，不需要花费大量时间去调整动效。",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTAwNTA=",
    "number": 341,
    "title": "【Q338】js 中在 new 的时候发生了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMzQ0Mzk5NQ==",
          "body": "1. 创建了一个新对象\r\n2. 链接到原型\r\n3. 绑定this指向\r\n4.返回这个对象\r\n\r\n```js\r\nfunction _new() {\r\n let obj = {}\r\n let Con = [].shift.call(arguments)\r\n obj.__proto__ = Con.prototype\r\n let result = Con.apply(obj, arguments)\r\n return typeof obj === 'object' ? obj : {}\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "XJHxjh0118",
            "url": "https://github.com/XJHxjh0118"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzUzNzY5OQ==",
          "body": "1. 创建一个新的对象\r\n1. this 指向实例，并且执行函数\r\n1. 如果没有显式返回，则默认返回这个实例",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBeJ4",
          "body": "> 1. 创建了一个新对象\r\n> 2. 链接到原型\r\n> 3. 绑定this指向\r\n>    4.返回这个对象\r\n> \r\n> ```js\r\n> function _new() {\r\n>  let obj = {}\r\n>  let Con = [].shift.call(arguments)\r\n>  obj.__proto__ = Con.prototype\r\n>  let result = Con.apply(obj, arguments)\r\n>  return typeof obj === 'object' ? obj : {}\r\n> }\r\n> ```\r\n\r\n如果构造器返回null 就不对了 因为 ` typeof null === 'object' `   所以应该用 `obj instanceof Object`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FYo_o",
          "body": "> 1. 创建了一个新对象\r\n> 2. 链接到原型\r\n> 3. 绑定这个指向\r\n>    4.返回这个对象\r\n> \r\n> ```js\r\n> function _new() {\r\n>  let obj = {}\r\n>  let Con = [].shift.call(arguments)\r\n>  obj.__proto__ = Con.prototype\r\n>  let result = Con.apply(obj, arguments)\r\n>  return typeof obj === 'object' ? obj : {}\r\n> }\r\n> ```\r\n\r\n这个result没用啊",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuerdev",
            "url": "https://github.com/yuerdev"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JKXrM",
          "body": "1. 关联原型\r\n2. 调用函数，绑定参数\r\n3. 返回执行，特别需要处理 `null` 、`object` 场景\r\n\r\n```js\r\nfunction myNew(...rest) {\r\n    const fn = [].slice.call(rest, 0, 1)[0];\r\n    const params = [].slice.call(rest, 1);\r\n    const ret = Object.create(fn.prototype);\r\n    const result = fn.apply(ret, params);\r\n    return typeof result === 'object' ? result || ret : ret ;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bigbigDreamer",
            "url": "https://github.com/bigbigDreamer"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jigut",
          "body": "```\r\nfunction myNew(fn, ...args) {\r\n  const instance = Object.create(fn.prototype);\r\n  const ret = fn.apply(instance, args);\r\n  return typeof ret === \"object\" && ret !== null ? ret : instance;\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTEwMjE=",
    "number": 342,
    "title": "【Q339】伪类与伪元素有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxNzY4OQ==",
          "body": "1. 伪类使用单冒号，而伪元素使用双冒号。如 `:hover` 是伪类，`::before` 是伪元素\r\n1. 伪元素会在文档流生成一个新的元素，并且可以使用 `content` 属性设置内容\r\n\r\n参考 <https://www.w3.org/TR/CSS2/selector.html#pseudo-elements>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTM5MjU=",
    "number": 343,
    "title": "【Q440】试着讲述数据库的几个范式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5svlKo",
          "body": "数据库的范式是一种设计原则，用于组织关系型数据库中的数据，以减少冗余和提高数据的一致性。主要有以下几个范式：\r\n\r\n第一范式（1NF）： 表中的每个列都包含原子性的值，不可再分。每一列都应该具有原子性，不可再分解为更小的数据项。\r\n第二范式（2NF）： 在满足第一范式的基础上，非主键列完全依赖于主键，而不是依赖于主键的一部分。即，表中的每个非主键列都必须完全依赖于主键。\r\n第三范式（3NF）： 在满足第二范式的基础上，非主键列之间互相独立，不存在传递依赖。即，非主键列之间不能有传递依赖关系。\r\nBC范式（Boyce-Codd范式）： 在满足第三范式的基础上，如果主键只包含一个属性，那么该表就满足BC范式。BC范式是第三范式的一种强化，主要针对主键包含多个属性的情况。\r\n第四范式（4NF）： 在满足BC范式的基础上，如果存在多值依赖关系，那么需要进一步分解表。\r\n第五范式（5NF）： 在满足第四范式的基础上，如果存在联合依赖关系，那么需要进行进一步的分解。\r\n\r\n这些范式的层次递进，每一级范式的目标是消除数据中的某种特定类型的冗余。选择范式的级别通常取决于具体的业务需求和性能优化的考虑。在实际数据库设计中，通常会根据具体情况灵活应用这些范式。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTUyNTQ=",
    "number": 344,
    "title": "【Q341】为什么在 mysql 不能够使用 = null",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5svjJI",
          "body": "在 MySQL 中，使用 = 进行比较时，不能直接用于 NULL 值。这是因为 NULL 代表缺失或未知的值，而在关系型数据库中，NULL 的比较是不确定的。要检查列是否为 NULL，应该使用 IS NULL 或 IS NOT NULL，而不是直接使用 = 或 !=。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTkwMDQ=",
    "number": 345,
    "title": "【Q342】`A, B` 复合索引时，`A=? and B=?` 与 `B=? and A=?` 效果是否一致",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sv8aa",
          "body": "MySQL 复合索引遵循最左前缀匹配原则，这意味着如果你在多列上创建了一个复合索引，那么查询中使用这个索引时，必须按照索引中列的顺序从左到右进行匹配，所以如果符合索引是（A，B），查询 A=? and B=? 会使用到索引，而B=? and A=?不会使用到索引，两者效果是不一致的。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY3NDk0Nzc=",
    "number": 346,
    "title": "【Q343】如何查找地图中某个点两公里内的餐厅",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
          "name": "data-structure"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY3Nzg5NjA=",
    "number": 347,
    "title": "【Q344】如何列出所有已合并到 master 的分支并删除",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MjQ2MTk3MQ==",
          "body": "``` bash\r\n# 列出所有已合并到 master 的分支\r\n$ git branch --merged master\r\n\r\n# 删除所有已合并到 master 的分支\r\n$ git branch --merged master | grep -v '^\\*' | xargs git branch -d\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
          "name": "git"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY5NzcxNjU=",
    "number": 348,
    "title": "【Q345】postgres 中 Index Scan 与 Index Only Scan 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MjY3MjcyOQ==",
          "body": "假设在 `user` 表简历索引 (name, age)\r\n\r\nIndex Scan 指查询中除利用索引外还有额外的查询条件，如 (name, age) 是索引，但是 sex 不是\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10 and sex = 'MALE'\r\n```\r\n\r\nIndex Only Scan 指查询中可以全部利用索引，如 (name, age) 都是索引\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzc1NTM2Njk=",
    "number": 349,
    "title": "【Q346】Sentry 中 `withScope`，`configureScope` 与 直接 setTags 有何区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzc2NzEwNTE=",
    "number": 350,
    "title": "【Q347】在 node 中如何开启 https",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MzIxMjcxMw==",
          "body": "在 `express` 中开启 https，如下代码所示\r\n\r\n``` js\r\nimport path from 'path'\r\nimport fs from 'fs'\r\nimport express from 'express'\r\nimport http from 'http'\r\nimport https from 'https'\r\n\r\nconst app = express();\r\n\r\nconst cred = {\r\n  key: fs.readFileSync(path.resolve(__dirname, '../key.pem')),\r\n  cert: fs.readFileSync(path.resolve(__dirname, '../cert.pem'))\r\n}\r\nconst httpServer = http.createServer(app)\r\nconst httpsServer = https.createServer(cred, app)\r\n\r\nhttpServer.listen(8000);\r\nhttpsServer.listen(8888);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgwODI1NDU=",
    "number": 351,
    "title": "【Q348】node 中 module.exports 与 exports 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MTA5NzQzMQ==",
          "body": "**一句话：`exports` 是 `module.exports` 的引用，如果 `exports` 没有重赋值，则二者没有任何区别**，原理就在于 CommonJS 的 `module_wrapper`，`compiledWrapper.call(thisValue, module.exports, require, module)`。\r\n\r\n类似如下所示\r\n\r\n``` js\r\nconst exports = module.exports\r\n```\r\n\r\n那以下代码结果会如何导出？\r\n\r\n``` js\r\nmodule.exports = 100\r\nexports = 3\r\n```\r\n\r\n很显然会导出 100，毕竟 `exports` 进行了重赋值。\r\n\r\n**那在 node 源码中如何实现的呢？** 从源码里可以看出 **exports** 的实质\r\n\r\n![module wrapper](https://shanyue.tech/assets/img/module-wrapper.70557e4e.png)\r\n\r\n详见源码: <https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1252>，可以看出符合猜想\r\n\r\n众所周知，node 中所有的模块代码都被包裹在这个函数中\r\n\r\n``` js\r\nexports = module.exports\r\n(function(exports, require, module, __filename, __dirname) {\r\n  exports.a = 3\r\n});\r\n```\r\n\r\n而以下源码指出，`exports` 是如何得来\r\n\r\n``` js\r\nconst dirname = path.dirname(filename);\r\nconst require = makeRequireFunction(this, redirects);\r\nlet result;\r\n// 从这里可以看出来 exports 的实质\r\nconst exports = this.exports;\r\nconst thisValue = exports;\r\nconst module = this;\r\nif (requireDepth === 0) statCache = new Map();\r\nif (inspectorWrapper) {\r\n  result = inspectorWrapper(compiledWrapper, thisValue, exports,\r\n                            require, module, filename, dirname);\r\n} else {\r\n\r\n  // 这里是模块包装函数\r\n  result = compiledWrapper.call(thisValue, exports, require, module,\r\n                                filename, dirname);\r\n}\r\n```\r\n\r\n我们再对示例代码放在包裹函数中，最终导出结果如何一目了然\r\n\r\n``` js\r\nconst exports = module.exports\r\n(function(exports, require, module, __filename, __dirname) {\r\n  module.exports = 100\r\n  exports = 3\r\n});\r\n```\r\n\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxMzY2ODg=",
    "number": 352,
    "title": "【Q349】如何把 json 数据转化为 demo.json 并下载文件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MzYwMzAyNA==",
          "body": "json 视为字符串，可以利用 `DataURL` 进行下载\r\n\r\n`Text -> DataURL`\r\n\r\n除了使用 DataURL，还可以转化为 Object URL 进行下载\r\n\r\n`Text -> Blob -> Object URL`\r\n\r\n可以把以下代码直接粘贴到控制台下载文件\r\n\r\n``` js\r\nfunction download (url, name) {\r\n  const a = document.createElement('a')\r\n  a.download = name\r\n  a.rel = 'noopener'\r\n  a.href = url\r\n  // 触发模拟点击\r\n  a.dispatchEvent(new MouseEvent('click'))\r\n  // 或者 a.click()\r\n}\r\n\r\nconst json = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\nconst str = JSON.stringify(json, null, 2)\r\n\r\n// 方案一：Text -> DataURL\r\nconst dataUrl = `data:,${str}`\r\ndownload(dataUrl, 'demo.json')\r\n\r\n// 方案二：Text -> Blob -> ObjectURL\r\nconst url = URL.createObjectURL(new Blob(str.split('')))\r\ndownload(url, 'demo1.json')\r\n```\r\n\r\n## 总结\r\n\r\n1. 模拟下载，可以通过新建一个 `<a href=\"url\" download><a>` 标签并设置 `url` 及 `download` 属性来下载\r\n2. 可以通过把 `json` 转化为 `dataurl` 来构造 URL\r\n3. 可以通过把 `json` 转换为 `Blob` 再转化为 `ObjectURL` 来构造 URL",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTYxODk0Mg==",
          "body": "这里 为啥要split下呢\r\nconst url = URL.createObjectURL(new Blob(str.split('')))\r\n 我看mdn 上面只需要 \r\n const url = URL.createObjectURL(new Blob([str], { type: 'application/json' })) 是有其他的含义吗 虽然都能实现下载的功能？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fariellany",
            "url": "https://github.com/fariellany"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxODQxOTk0NA==",
          "body": "> 这里 为啥要split下呢\r\n> const url = URL.createObjectURL(new Blob(str.split('')))\r\n> 我看mdn 上面只需要\r\n> const url = URL.createObjectURL(new Blob([str], { type: 'application/json' })) 是有其他的含义吗 虽然都能实现下载的功能？\r\n\r\n因为需要Blob的API是var aBlob = new Blob( **array**, options );",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "amandaQYQ",
            "url": "https://github.com/amandaQYQ"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BHmQM",
          "body": "方法一有2个缺点：  \r\n1、无法保留缩进  \r\n2、字符串里面的空格会被删除",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xinconan",
            "url": "https://github.com/xinconan"
          }
        },
        {
          "id": "IC_kwDODQzyOs5GTk7q",
          "body": "@xinconan 我并没有复现你说的方法一的缺点，能贴一段代码或是更详细的说明吗\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JieChongHai",
            "url": "https://github.com/JieChongHai"
          }
        },
        {
          "id": "IC_kwDODQzyOs5GU-ji",
          "body": "> @xinconan 我并没有复现你说的方法一的缺点，能贴一段代码或是更详细的说明吗\r\n\r\n试了下方法一是可以的，说的那两个缺点是因为之前遇到过，但和我之前写法上有些不同。其实这里并不需要加 `application/json;charset=utf-8`\r\n```js\r\nconst dataUrl = `data:application/json;charset=utf-8,${str}`; // 这种写法有问题\r\n```\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "xinconan",
            "url": "https://github.com/xinconan"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxODI2ODI=",
    "number": 353,
    "title": "【Q350】如何实现一个 timeout 的中间件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sv-1q",
          "body": "在请求的方法加个定时器，当超过时长之后直接返回超时错误",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgzMTkyNDk=",
    "number": 354,
    "title": "【Q351】如何得知目前 node 版本的 v8 版本号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Mzc0MzQ5MQ==",
          "body": "在 `process.versions` 中可以查看 node 及相关依赖的版本号\r\n\r\n``` js\r\n> process.versions\r\n{\r\n  node: '12.16.3',\r\n  v8: '7.8.279.23-node.35',\r\n  uv: '1.34.2',\r\n  zlib: '1.2.11',\r\n  brotli: '1.0.7',\r\n  ares: '1.16.0',\r\n  modules: '72',\r\n  nghttp2: '1.40.0',\r\n  napi: '5',\r\n  llhttp: '2.0.4',\r\n  http_parser: '2.9.3',\r\n  openssl: '1.1.1g',\r\n  cldr: '36.0',\r\n  icu: '65.1',\r\n  tz: '2019c',\r\n  unicode: '12.1'\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg0OTQ3MjU=",
    "number": 355,
    "title": "【Q352】k8s 中如何删除所有 Evicted 状态的 pod",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Mzg3MDI2OQ==",
          "body": "``` bash\r\n$ kubectl get pods\r\nNAME                                             READY   STATUS             RESTARTS   AGE\r\ncert-manager-5d8fd69d88-4nxw5                    1/1     Running            0          63d\r\ncert-manager-5d8fd69d88-f7f2w                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-mpgqq                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-s7dtg                    0/1     Evicted            0          232d\r\ncert-manager-5d8fd69d88-vdmrx                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-zlpv4                    0/1     Evicted            0          63d\r\ncert-manager-cainjector-755bbf9c6b-455nm         0/1     Evicted            0          63d\r\n```\r\n\r\n可通过 `kubectl get pods` 来找到 `Evicted` 状态的 POD，通过 `awk` 和 `kubectl delete pod` 选中目标 pod 并删除，命令如下\r\n\r\n``` bash\r\n$  kubectl get pods | grep Evicted | awk '{print $1}' | xargs kubectl delete pod\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NDkwMjk2Mw==",
          "body": "```\r\nkubectl delete po --field-selector status.phase=Evicted\r\n```\r\n\r\n更加精确。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "wi1dcard",
            "url": "https://github.com/wi1dcard"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg2NjQ5OTc=",
    "number": 356,
    "title": "【Q353】k8s 中 Deployment 与 StatefulSet 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDExMTc0NDg=",
    "number": 357,
    "title": "【Q354】在 node 中如何判断一个对象是 stream",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NzY4NTczNg==",
          "body": "`stream` 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。\r\n\r\n**每一个 stream 都有 `pipe` 函数，可以用来判断一个对象是否 `stream`**。\r\n\r\n代码如下，摘自 [is-stream](https://github.com/sindresorhus/is-stream/blob/master/index.js): 一个周下载量两千万的 npm package。\r\n\r\n``` js\r\nconst isStream = stream =>\r\n\tstream !== null &&\r\n\ttypeof stream === 'object' &&\r\n\ttypeof stream.pipe === 'function';\r\n\r\nisStream.writable = stream =>\r\n\tisStream(stream) &&\r\n\tstream.writable !== false &&\r\n\ttypeof stream._write === 'function' &&\r\n\ttypeof stream._writableState === 'object';\r\n\r\nisStream.readable = stream =>\r\n\tisStream(stream) &&\r\n\tstream.readable !== false &&\r\n\ttypeof stream._read === 'function' &&\r\n\ttypeof stream._readableState === 'object';\r\n\r\nisStream.duplex = stream =>\r\n\tisStream.writable(stream) &&\r\n\tisStream.readable(stream);\r\n\r\nisStream.transform = stream =>\r\n\tisStream.duplex(stream) &&\r\n\ttypeof stream._transform === 'function' &&\r\n\ttypeof stream._transformState === 'object';\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNTQ0NjEyMg==",
          "body": "鸭子判断？",
          "star": {
            "totalCount": 0
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDEyMTEzNTY=",
    "number": 358,
    "title": "【Q355】什么是 Iterable 对象，与 Array 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Njk5MTA4Mw==",
          "body": "实现了 `[Symbol.iterator]` 属性的对象即是 `Iterable` 对象，然后可以使用操作符 `for...of` 进行迭代\r\n\r\n``` js\r\n> l = [1, 2, 3, 4]\r\n< (4) [1, 2, 3, 4]\r\n> l[Symbol.iterator]\r\n< ƒ values() { [native code] }\r\n```\r\n\r\n详细参考 <https://javascript.info/iterable>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDI0NzczMTE=",
    "number": 360,
    "title": "【Q356】在 node 端如何向服务器上传文件",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDU2MTg2MDg=",
    "number": 361,
    "title": "【Q357】js 如何全部替代一个子串为另一个子串",
    "body": "假设有一个字符串 `hello. hello. hello. ` 需要替换为 `AAA`，即把 `hello. ` 替换为 `A`",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1MTU2NDM3Ng==",
          "body": "如果需要全量替换字符串，可以使用 `String.prototype.replace(re, replacer)`，其中正则表达式需要开启 `global` flag\r\n\r\n``` js\r\nconst s = 'foo foo foo'\r\ns.replce(/foo/g, 'bar')\r\n```\r\n\r\n那如题中，**是否可以使用正则表达式来替代子串**\r\n\r\n答：**不可以，因为使用子串构建正则时，有可能有特殊字符，就有可能出现问题**，如下\r\n\r\n``` js\r\n// 期待结果: 'AhelloX hello3 '\r\n> 'hello. helloX hello3 '.replace(new RegExp('hello. ', 'g'), 'A')\r\n< \"AAA\"\r\n```\r\n\r\n而在 `javascript` 中替换子串只能使用一种巧妙的办法：`str.split('foo').join('bar')`\r\n\r\n``` js\r\n> 'hello. hello. hello. '.split('hello. ').join('A')\r\n< \"AAA\"\r\n```\r\n\r\n真是一个巧(笨)妙(拙)的办法啊！！！！！**大概 TC39 也意识到了一个问题，于是出了一个新的 API**，在 `ESNext` 中\r\n\r\n``` js\r\nString.prototype.replaceAll()\r\n\r\n'aabbcc'.replaceAll('b', '.'); \r\n// 'aa..cc'\r\n```\r\n\r\n详细文档在 [String.prototype.replaceAll](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\r\n\r\n## 总结(及直接答案)\r\n\r\n两种办法\r\n\r\n+ `str.split('foo').join('bar')`\r\n+ `str.replaceAll('foo', 'bar')`，在 `ESNext` 中，目前支持性不好",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgzOTczNjI4Ng==",
          "body": "正则表达式中有特殊字符的话，可以将其转译：\r\n\r\n```\r\n>  'hello. helloX hello3 '.replace(new RegExp('hello\\\\. ', 'g'), 'A')\r\n< \"AhelloX hello3 \"\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Humilitas",
            "url": "https://github.com/Humilitas"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MTA0MDU0OA==",
          "body": "> 正则表达式中有特殊字符的话，可以将其转译：\r\n> \r\n> ```\r\n> >  'hello. helloX hello3 '.replace(new RegExp('hello\\\\. ', 'g'), 'A')\r\n> < \"AhelloX hello3 \"\r\n> ```\r\n\r\n如果需要正则转义的话，得提前实现一个 `escapeReg` 函数来进行转义，工作量有些大易出错，我试着实现一下\r\n\r\n``` js\r\nconst escapeReg = str => str\r\n  .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\r\n  .replace(/-/g, '\\\\x2d');\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMxOTc1Njk=",
    "number": 363,
    "title": "【Q358】什么情况下会发送 OPTIONS 请求",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMzIyNQ==",
          "body": "[搬运地址](https://blog.csdn.net/kahhy/article/details/81563063)\r\n1:请求的方法不是GET/HEAD/POST\r\n2:POST请求的Content-Type 异常\r\n3:请求设置了自定义的header字段\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nextprops",
            "url": "https://github.com/nextprops"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2NzQ2Nzc0NQ==",
          "body": "**当一个请求跨域且不是简单请求时就会发送 `OPTIONS` 请求**\r\n\r\n满足以下条件就是一个简单请求:\r\n\r\n1. `Method`: 请求的方法是 `GET`、`POST` 及 `HEAD`\r\n1. `Header`: 请求头是 `Content-Type`、`Accept-Language`、`Content-Language` 等\r\n1. `Content-Type`: 请求类型是 `application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`\r\n\r\n而在项目中常见的 `Content-Type: application/json` 及 `Authorization: <token>` 为典型的**非简单请求**，在发送请求时往往会带上 `Options`\r\n\r\n> 更详细内容请参考 [CORS - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMzMzY1MjQ=",
    "number": 364,
    "title": "【Q359】CORS 如果需要指定多个域名怎么办",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NTg2Mjg2NA==",
          "body": "`CORS` 通过控制 `Access-Control-Allow-Origin` 控制哪些域名可以共享资源，取值如下\r\n\r\n``` bash\r\nAccess-Control-Allow-Origin: <origin> | *\r\n```\r\n\r\n其中 `*` 代表所有域名，`origin` 代表指定特定域名，那如何设置多个域名了？\r\n\r\n此时需要通过代码实现，**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，那 Origin 又是什么东西？\r\n\r\n## 请求头: Origin\r\n\r\n并不是所有请求都会自动带上 `Origin`，在浏览器中带 `Origin` 的逻辑如下\r\n\r\n1. 如果存在跨域，则带上 `Origin`，值为当前域名\r\n1. 如果不存在跨域，则不带 `Origin`\r\n\r\n逻辑理清楚后，关于服务器中对于 `Access-Control-Allow-Origin` 设置多域名的逻辑也很清晰了\r\n\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>`\r\n\r\n使用伪代码实现如下:\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n## Vary: Origin\r\n\r\n此时可以给多个域名控制 CORS，但此时假设有两个域名访问 `static.shanyue.tech` 的跨域资源\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`\r\n1. `bar.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: bar.shanyue.tech`\r\n\r\n看起来一切正常，但如果中间有缓存怎么办？\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，被 CDN 缓存\r\n1. **`bar.shanyue.tech`，因由缓存，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，跨域出现问题**\r\n\r\n此时，`Vary: Origin` 就上场了，代表为不同的 `Origin` 缓存不同的资源\r\n\r\n## 总结 (简要答案)\r\n\r\nCORS 如何指定多个域名？\r\n\r\n**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，思路如下\r\n\r\n1. 总是设置 `Vary: Origin`，避免 CDN 缓存破坏 CORS 配置\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明浏览器访问跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>` \r\n\r\n使用伪代码实现如下\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\nctx.set('Vary', 'Origin')\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n>  相关问题：[如何避免 CDN 为 PC 端缓存移动端页面](https://github.com/shfshanyue/Daily-Question/issues/330)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ0ODg0NjQ=",
    "number": 365,
    "title": "【Q360】localhost 与 127.0.0.1 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMDM1Ng==",
          "body": "localhost 可以更改后指向其它地址。\r\n127.0.0.1 是约定的本机IP。\r\n类似互联网中域名与服务器IP的关系。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nextprops",
            "url": "https://github.com/nextprops"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MjIwMTI4Ng==",
          "body": "对99.99%的人来说**没有区别**",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2Mjc4MzMwNw==",
          "body": "如果在浏览器访问时，当前页面的location.hostname(host) 不同，配置代理的时候要注意",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ovarte",
            "url": "https://github.com/ovarte"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2Mjc5NjQxNw==",
          "body": "localhost也叫local ，正确的解释是：本地服务器\r\n\r\n127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）\r\n\r\n他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1\r\n\r\nlocalhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。\r\n\r\n127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。\r\n\r\n一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。\r\n\r\n有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。猜想localhost访问时，系统带的本机当前用户的权限去访问，而用ip的时候，等于本机是通过网络再去访问本机，可能涉及到网络用户的权限。\r\n\r\n摘录自--https://zhuanlan.zhihu.com/p/26503558",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "AureliusPatiens",
            "url": "https://github.com/AureliusPatiens"
          }
        },
        {
          "id": "IC_kwDODQzyOs45_Vcs",
          "body": "> localhost也叫local ，正确的解释是：本地服务器\r\n> \r\n> 127.0.0.1在windows等系统的正确解释是：本机地址（本机服务器）\r\n> \r\n> 他们的解析通过本机的host文件，windows自动将localhost解析为127.0.0.1\r\n> \r\n> localhot（local）是不经网卡传输！这点很重要，它不受网络防火墙和网卡相关的的限制。\r\n> \r\n> 127.0.0.1是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。\r\n> \r\n> 一般设置程序时本地服务用localhost是最好的，localhost不会解析成ip，也不会占用网卡、网络资源。\r\n> \r\n> 有时候用localhost可以，但用127.0.0.1就不可以的情况就是在于此。猜想localhost访问时，系统带的本机当前用户的权限去访问，而用ip的时候，等于本机是通过网络再去访问本机，可能涉及到网络用户的权限。\r\n> \r\n> 摘录自--https://zhuanlan.zhihu.com/p/26503558\r\n\r\n评论中又写到 `127.0.0.1` 也是不进过网卡的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nmsn",
            "url": "https://github.com/nmsn"
          }
        },
        {
          "id": "IC_kwDODQzyOs5E1JJM",
          "body": "`localhost`是本地保存的解析记录，在`/etc/hosts`中，可以修改来指向其它IP。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wizardforcel",
            "url": "https://github.com/wizardforcel"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ1NzUyMDE=",
    "number": 366,
    "title": "【Q361】既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗 ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjY5NzU2Nw==",
          "body": "**对 CORS 一点用也没有**\r\n\r\n1. **`form` 提交不通过 `CORS` 检测**，你可以在本地进行测试\r\n1.  即使通过 `xhr` 及 `fetch` 进行提交被 CORS 拦住，**但是对于简单请求而言，请求仍被发送**，已造成了攻击\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODEwMjg=",
    "number": 367,
    "title": "【Q362】js 动画和 css 动画那个性能比较好",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5BHX16",
          "body": "能用css最好用css 吧，js 比较耗性能",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuli-collov",
            "url": "https://github.com/wuli-collov"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODM0NDM=",
    "number": 368,
    "title": "【Q363】如何获取当前系统中的在线用户数 (并发用户数)",
    "body": "一些 SaaS 系统基于 Pricing 的考虑，会限制团队人数及同时在线数，如何实现",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NzUxMzc5Mw==",
          "body": "> 一些 SaaS 系统基于定价策略的考虑，会限制团队人数及同时在线数，如何实现？\r\n\r\n通过 `redis` 的 `zset` 可实现并发用户数。\r\n\r\n当一个用户请求任何接口时，实现一个 middleware，处理以下逻辑\r\n\r\n``` js\r\n// 当一个用户访问任何接口时，对该用户Id，写入 zset\r\nawait redis.zadd(`Organization:${organizationId}:concurrent`, Date.now(), `User:${userId}`)\r\n\r\n// 查询当前机构的并发数\r\n// 通过查询一分钟内的活跃用户来确认并发数，如果超过则抛出特定异常\r\nconst activeUsers = await redis.zrangebyscore(`Organization:${organizationId}:concurrent`, Date.now() - 1000 * 60, Date.now())\r\n\r\n// 查出并发数\r\nconst count = activeUsers.length\r\n\r\n// 删掉过期的用户\r\nawait redis.zrembyscore(`Organization:${organizationId}:concurrent`, Date.now() - 1000 * 60, Date.now())\r\n```\r\n\r\n## 总结\r\n\r\n1. 每当用户访问服务时，把该用户的 ID 写入优先级队列，权重为当前时间\r\n1. 根据权重(即时间)计算一分钟内该机构的用户数\r\n1. 删掉一分钟以上过期的用户\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTk4Njk1NTk=",
    "number": 369,
    "title": "【Q364】css 如何匹配前N个子元素及最后N个子元素",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2MDQxODQwNA==",
          "body": "见 [【Q307】如何实现表格单双行条纹样式](https://github.com/shfshanyue/Daily-Question/issues/309)\r\n\r\n+ 如何匹配最前三个子元素: `:nth-child(-n+3)`\r\n+ 如何匹配最后三个子元素: `:nth-last-child(-n+3)`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NjM1NjM3NTM=",
    "number": 370,
    "title": "【Q365】node 中 nextTick 与 setTimeout 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44uNzx",
          "body": "`nextTick`属于微任务，`setTimeout`属于宏任务，在事件循环中执行的优先级不一样",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "thundernet8",
            "url": "https://github.com/thundernet8"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Njg4MTI1Nzc=",
    "number": 371,
    "title": "【Q366】如何保存数据库与缓存的双写一致性",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5swB9Q",
          "body": "1.先写缓存，再异步写数据库，这种情形性能比较好，但是可能会存在写数据库失败导致的数据不一致问题，所以要在写数据库环节加上失败重试，以及重试失败后发送写库失败消息给消息队列以便再次异步写入；\r\n2.先写数据库，再写缓存，这个性能较差，因为缓存需要等待数据库写入成功才能更新；\r\n3.使用分布式事务来保证两阶段提交都能成功，一旦某个阶段失败则全部回滚；\r\n4.对于某些强一致性的数据做一个计划任务定时检查缓存与数据库的一致性，一旦不一致则更新缓存；",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        },
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk0OTUzMTE=",
    "number": 372,
    "title": "【Q367】redux 和 mobx 有什么不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs53J4-Q",
          "body": "Redux 和 MobX 都是 JavaScript 应用程序状态管理的库，它们有一些相似之处，但也有一些不同之处。以下是它们之间的主要区别：\r\n\r\n1. **响应性 vs. 不可变性**：\r\n   - Redux 鼓励使用不可变数据（Immutable Data）的概念来管理应用状态。Redux 的状态是通过纯函数（reducer）来处理的，这意味着状态的修改是不可变的，每次修改都会生成一个新的状态。\r\n   - MobX 则采用了响应式编程的思想，它可以自动跟踪状态的变化，并在状态发生变化时自动更新相关的组件。开发者可以直接修改状态，而不需要编写额外的代码来更新视图。\r\n\r\n2. **状态管理的复杂度**：\r\n   - Redux 是一个更加严格和规范的状态管理库，它提供了单一的状态树（Single State Tree）和明确的数据流程。虽然它的使用可能需要编写更多的代码，但也更加灵活和可控。\r\n   - MobX 相对来说更加灵活和简单，它不强制使用单一的状态树或特定的数据流程。开发者可以根据自己的喜好和需求来组织状态和数据流程。\r\n\r\n3. **性能和优化**：\r\n   - 由于 MobX 的响应式特性，它可以在状态发生变化时自动更新相关的组件，这样可以减少手动编写更新逻辑的工作。这使得 MobX 在某些情况下具有更好的性能和更少的重复代码。\r\n   - Redux 的不可变性和严格的数据流程可以帮助开发者更容易地进行状态管理和调试，但在某些情况下可能需要开发者手动进行性能优化。\r\n\r\n4. **社区和生态系统**：\r\n   - Redux 拥有庞大的社区和丰富的生态系统，有许多与之相关的中间件、工具和扩展。\r\n   - MobX 也有相当数量的用户和社区支持，但相对 Redux 而言规模较小，生态系统也相对较小。\r\n\r\n综上所述，Redux 更适合于需要严格数据流程和可预测性的大型应用程序，而 MobX 则更适合于快速开发和简化状态管理的小型到中型应用程序。选择哪一个取决于项目的需求、团队的偏好以及开发者对状态管理的理解和熟悉程度。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "juvenile-spec",
            "url": "https://github.com/juvenile-spec"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk1NjkyMzQ=",
    "number": 373,
    "title": "【Q368】关于 React hooks 的 caputre value，以下输出多少",
    "body": "``` js\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n  const incr = () => {\r\n    setTimeout(() => {\r\n      setCount(count + 1);\r\n    }, 3000);\r\n  };\r\n  return <h1 onClick={incr}>{count}</h1>;\r\n}\r\n```\r\n\r\n当连续点击 10 次时，会输出多少",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczODUyMTA3OA==",
          "body": "应该是1吧，在state被update之前count一直还是0",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zckpp",
            "url": "https://github.com/zckpp"
          }
        },
        {
          "id": "IC_kwDODQzyOs45-kYc",
          "body": "连续点击 10 次是在3s内完成，那传给setTimeout的count都为0，输出应该都是1",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        },
        {
          "id": "IC_kwDODQzyOs47nqMx",
          "body": "验证一下 https://codesandbox.io/s/sharp-dawn-5e5hp?file=/src/capture.js ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cloudXA",
            "url": "https://github.com/cloudXA"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk2MjU4MTY=",
    "number": 374,
    "title": "【Q369】在 React 项目中 immutable 是优化性能的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5kWnbg",
          "body": "\r\n使用不可变数据（immutable data）可以在 React 项目中优化性能。不可变数据是指一旦创建就不能被更改的数据，任何更改操作都会返回一个新的数据副本，而不是直接在原始数据上进行修改。在 React 中，使用不可变数据的主要方式是通过使用类似于 Immutable.js 这样的库，或者使用一些技术手段来确保数据不被直接修改。\r\n\r\n使用不可变数据的优势在于：\r\n\r\n更好的性能： 不可变数据可以帮助 React 更有效地进行虚拟 DOM 的比较。当数据发生变化时，React 需要比较新旧虚拟 DOM 树来确定哪些部分需要更新。使用不可变数据可以减少比较的复杂性，从而提高性能。\r\n\r\n易于追踪变化： 使用不可变数据可以更容易地追踪数据的变化，因为每次变化都会产生一个新的数据副本。这对于调试和性能优化都非常有帮助。\r\n\r\n避免意外的副作用： 直接修改数据可能导致意外的副作用，特别是在 React 中，直接修改数据可能导致组件不正确地重新渲染。\r\n\r\n更好的时间旅行： 在开发者工具中查看 React 组件状态的历史记录时，不可变数据可以确保每个状态都是明确的，并且可以更容易地回溯到之前的状态。\r\n\r\n需要注意的是，尽管不可变数据有很多优势，但也可能增加内存使用量，因为每次变化都会创建新的数据副本。在决定是否使用不可变数据时，需要权衡这些优势和缺点，以及项目的具体情况。在一些场景下，使用不可变数据可以显著提高性能，特别是在处理大规模数据时。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "GithubFuzhengshi",
            "url": "https://github.com/GithubFuzhengshi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk5NDE0NzQ=",
    "number": 375,
    "title": "【Q370】如何使用 CSS 实现网站的暗黑模式 (Dark Mode)",
    "body": "可参考以下文章:\r\n\r\n1. [Dark mode in 5 minutes, with inverted lightness variables](https://lea.verou.me/2021/03/inverted-lightness-variables/)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3MTM2MDkyMw==",
          "body": "``` css\r\n@media (prefers-color-scheme: dark) {\r\n    :root{\r\n    }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-j4sa",
          "body": "实现方式：\r\n```css\r\n    html[theme=\"dark-model\"] {\r\n        filter: invert(1) hue-rotate(180);\r\n        transition: color 300ms, background-color 300ms; /*过渡动画*/\r\n    }\r\n```\r\n\r\n解释：\r\n  css 的 filter属性 是将用于图片上的过滤，颜色变化等图形效果应用与元素上，\r\n  上面所使用到的 invert 可以用来反转应用程序的颜色; hue-rotate 是用来改变图像上的应用色颜色\r\n  通过invert(1)将白色变成黑色，那么为了适配颜色的变化，网页上的图像的颜色应该也做一个改变，这个改变就是通过hue-rotate(180edg)来实现的\r\n  filter属性 其他著名的应用还有:\r\n    * blur() 模糊图像\r\n    * opacity() 图像透明程度\r\n    * drop-shadow() 对图像应用阴影效果\r\n    * ...\r\n\r\n## Reference \r\n[MDN Docs](https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter)\r\n[如何实现网页dark-model](https://segmentfault.com/a/1190000023598551)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "CsongL",
            "url": "https://github.com/CsongL"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk5NDgzNTg=",
    "number": 376,
    "title": "【Q371】在 redux 中如何发送请求",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_aQy2",
          "body": "使用redux-thunk中间件 就能够在redux中发送请求 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "selecaing",
            "url": "https://github.com/selecaing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzAzODU1NTE=",
    "number": 377,
    "title": "【Q372】redis 是如何删掉过期数据的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs493_tZ",
          "body": "懒删除：查询时删除\r\n定时删除：通过定时任务删除",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shay-an",
            "url": "https://github.com/shay-an"
          }
        },
        {
          "id": "IC_kwDODQzyOs5E0oz-",
          "body": "Overview of Redis key eviction policies (LRU, LFU, etc.).details below [ https://redis.io/docs/manual/eviction/](url)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liyihang",
            "url": "https://github.com/liyihang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzA0NzM1NDE=",
    "number": 378,
    "title": "【Q373】如何为你们的前端项目选择状态管理器",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5DGPlS",
          "body": "我选择尽量不使用状态管理器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "dangdangdanglll",
            "url": "https://github.com/dangdangdanglll"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DH2so",
          "body": "> 我选择尽量不使用状态管理器\r\n\r\n能说下理由吗，愿闻其详\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "whale2002",
            "url": "https://github.com/whale2002"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzA5MTA1MDE=",
    "number": 379,
    "title": "【Q374】简单介绍 requestIdleCallback 及使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2ODA0ODk4MQ==",
          "body": "`requestIdleCallback` 维护一个队列，将在浏览器空闲时间内执行。它属于 [Background Tasks API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)，你可以使用 `setTimeout` 来模拟实现\r\n\r\n``` js\r\nwindow.requestIdleCallback = window.requestIdleCallback || function(handler) {\r\n  let startTime = Date.now();\r\n \r\n  return setTimeout(function() {\r\n    handler({\r\n      didTimeout: false,\r\n      timeRemaining: function() {\r\n        return Math.max(0, 50.0 - (Date.now() - startTime));\r\n      }\r\n    });\r\n  }, 1);\r\n}\r\n```\r\n\r\n以上实现过于复杂以及细节化，也可以像 [swr](https://github.com/vercel/swr) 一样做一个简单的模拟实现，以下代码见 <https://github.com/vercel/swr/blob/8670be8072b0c223bc1c040deccd2e69e8978aad/src/use-swr.ts#L33>\r\n\r\n``` js\r\nconst rIC = window['requestIdleCallback'] || (f => setTimeout(f, 1))\r\n```\r\n\r\n在 `rIC` 中执行任务时需要注意以下几点：\r\n\r\n1. 执行重计算而非紧急任务\r\n1. 空闲回调执行时间应该小于 50ms，最好更少\r\n1. 空闲回调中不要操作 DOM，因为它本来就是利用的重排重绘后的间隙空闲时间，重新操作 DOM 又会造成重排重绘\r\n\r\nReact 的时间分片便是基于类似 `rIC` 而实现，然而因为 `rIC` 的兼容性及 50ms 流畅问题，React 自制了一个实现: [scheduler](https://github.com/facebook/react/tree/master/packages/scheduler)\r\n\r\n[use-swr](https://github.com/vercel/swr) 中进行资源的 `revalidate` 时，也是通过 `rIC` 来提高性能\r\n\r\n## 参考\r\n\r\n**强烈推荐 MDN 与 w3c 上的两篇介绍**\r\n\r\n+ [Background Tasks API - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)\r\n+ [requestIdleCallback - W3C](https://w3c.github.io/requestidlecallback/#idle-periods)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE2MzgwNjI=",
    "number": 380,
    "title": "【Q375】在 redux 中如何写一个记录状态变更的日志插件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5u0Ud_",
          "body": "参考面向切面变成的方法，在 dispatch 1个 action 之后，state真正改变的地方进行 log",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "water-in-stone",
            "url": "https://github.com/water-in-stone"
          }
        },
        {
          "id": "IC_kwDODQzyOs5u0Ufz",
          "body": "这是来自QQ邮箱的假期自动回复邮件。你好，我最近正在休假中，无法亲自回复你的邮件。我将在假期结束后，尽快给你回复。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "loveminxo",
            "url": "https://github.com/loveminxo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE2MzgzNzA=",
    "number": 381,
    "title": "【Q376】TCP 四次挥手时为什么需要 2MSL",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2ODk0MDc5OA==",
          "body": "**我们先来看看什么是 2MSL ？**\r\nMSL: Maximum Segment Lifetime, 最长报文段寿命\r\n意思是，需要等候 2 * MSL 时间，才会进入关闭状态\r\n\r\n\r\n------------\r\n\r\n\r\n**然后再来看哪个阶段需要 2MSL ？**\r\n\r\n![image](https://user-images.githubusercontent.com/8110936/89364080-470b8600-d704-11ea-9bc7-edd882481c1e.png)\r\n从上图来看，是在 [发送方] 发送完 ACK 后，进入 **TIME_WAIT** 阶段，这个阶段需要等候 2*MSL，才将 TCP 关闭\r\n\r\n------------\r\n\r\n**为什么要等候 2*MSL ？**\r\n\r\n1. 用足够长的等候时间，来确保 [接收方] 能收到 ACK 包\r\n\r\n\t- 如果 [接收方] 在一定时间没收到 (ACK)，会重发 (FIN, ACK)，[发送方] 收到后，会重发 (ACK)，再重置 2*MSL 定时器\r\n\t.\r\n\r\n\r\n2. 防止当前连接延迟到达的数据段，被新的 TCP 连接收到\r\n\r\n\t- 新的 TCP 连接：相同端口，相同地址\r\n\r\n\r\n------------\r\n\r\n**TIME_WAIT 等候时间长短问题**\r\n\r\n1. 等候时间过短\r\n \r\n\t- 可能会收到上一个 TCP 连接延迟到达的数据段\r\n\t.\r\n\r\n2. 等候时间过长\r\n\r\n \t- TCP 连接一直占用着端口，需要关闭后才能建立新的连接，高并发下压力比较大\r\n\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "zzetao",
            "url": "https://github.com/zzetao"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTA2ODE2NA==",
          "body": "可以参考知乎这个问题：\r\n\r\n目的是为了优雅地关闭 TCP 连接。\r\n\r\n[为什么TCP4次挥手时等待为2MSL？](https://www.zhihu.com/question/67013338)\r\n\r\n#26 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE3NTQ0NTE=",
    "number": 382,
    "title": "【Q377】在 js 中如何实现继承",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4NzUwNjIzMQ==",
          "body": "有以下两种方法可实现继承\r\n\r\n## `class`/`extends`\r\n\r\n``` js\r\nclass Animal {\r\n  constructor (name) {\r\n    this.name = name\r\n  }\r\n\r\n  hello () {\r\n    console.log('hello')\r\n  }\r\n}\r\n\r\nclass Dog extends Animal {\r\n  constructor (name, say) {\r\n    super(name)\r\n    this.say = say\r\n  }\r\n}\r\n```\r\n\r\n## `function`/`new`\r\n\r\n``` js\r\nfunction Animal (name) {\r\n  this.name = name\r\n}\r\n\r\nAnimal.prototype.hello = () => {\r\n  console.log('hello')\r\n}\r\n\r\nfunction Dog (name, say) {\r\n  // 01 继承属性\r\n  Animal.call(this, name)\r\n  this.say = say\r\n}\r\n\r\n// 02 通过连接原型链完成继承\r\nDog.prototype = Object.create(Animal.prototype)\r\n\r\n// 03 再加上 constructor\r\nDog.prototype.constructor = Dog\r\n// Reflect.defineProperty(Dog.prototype, \"constructor\", {\r\n//  value: Dog,\r\n//  enumerable: false, // 不可枚举\r\n//  writable: true\r\n// })\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzIwOTEzNDI=",
    "number": 383,
    "title": "【Q378】React 在 setState 时发生了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyMDg3MTg1OA==",
          "body": "react16\r\n1.setstae 以后会把update队列加入到mount 里面 如果他在生命周期里面 其实他是进行批量去更新的 如果他是在生命周期里面去set 其实数据同步的。如果想要拿到最新的就需要脱离react生命周期，和react事件流 比如在setTimeout里面set值 他拿到的数据就是最新的。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hqylss111",
            "url": "https://github.com/hqylss111"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyMDg3MjM0NA==",
          "body": "例如下面代码  `class App extends React.Component {\r\n  state = { val: 0 }\r\n  componentDidMount() {\r\n    setTimeout(() => {\r\n      // 第一次调用\r\n      this.setState({ val: this.state.val + 1 });\r\n      console.log('first setState', this.state);\r\n  \r\n      // 第二次调用\r\n      this.setState({ val: this.state.val + 1 });\r\n      console.log('second setState', this.state);\r\n    });\r\n  }\r\n  render() {\r\n    return <div> val: { this.state.val } </div>\r\n  }\r\n}\r\n\r\n\r\n\r\nclass App extends React.Component {\r\n  state = { val: 0 }\r\n  componentDidMount() {\r\n     // 第一次调用\r\n     this.setState({ val: this.state.val + 1 });\r\n     console.log('first setState', this.state);\r\n \r\n     // 第二次调用\r\n     this.setState({ val: this.state.val + 1 });\r\n     console.log('second setState', this.state);\r\n\r\n     this.setState({ val: this.state.val + 1 });\r\n\r\n  }\r\n  render() {\r\n    return <div> val: { this.state.val } </div>\r\n  }`\r\n第一个app是 12  第二个是 00 1 验证了我上面说的\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hqylss111",
            "url": "https://github.com/hqylss111"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjAzNjg4MA==",
          "body": "1. 当每次 setState 时，组件会重新渲染\r\n1. 当在函数式组件中 setState 时，如果两次设置的 state 相同时，组件将不会重新渲染\r\n1. 当在事件处理函数中，多次调用 setState，React 将会批量进行渲染\r\n1. 当在事件处理函数外，多次调用 setState，React 将不会重新渲染\r\n1. 在 React18 之后，同一函数多次调用 setState，React 都将会批量进行渲染",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjA0OTI0NA==",
          "body": "在 React18 之后，同一函数多次调用 setState，React 都将会重新渲染 为什么会这样修改那？ 目的是什么那？ 批量修改不是性能更好嘛？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hqylss111",
            "url": "https://github.com/hqylss111"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjM1OTkzMg==",
          "body": "@hqylss111 口误了，其实是都会批量渲染，可以看看我的示例: https://codesandbox.io/s/react18-state-pilianggengxin-75ktu",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI3MzYwMTU=",
    "number": 384,
    "title": "【Q379】你们的后端项目的数据库索引做了哪些优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5swEx0",
          "body": "针对数据库索引优化主要是做以下工作：\r\n1.对于多条件查询语句，看是否可使用复合索引；\r\n2.开启慢查询日志，用Explain语句分析查询慢的语句索引是否有生效，进行优化；\r\n3.检查索引的字段是否遵循不为nil的原则；\r\n4.检查符合索引是否遵循最左原则；",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI3MzcyNjM=",
    "number": 385,
    "title": "【Q380】如何设计一个UI组件库",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5J4e-b",
          "body": "我看看我乱写一个会咋样",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "YANGJUNYAN0715",
            "url": "https://github.com/YANGJUNYAN0715"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI3Mzc3Njc=",
    "number": 386,
    "title": "【Q381】什么是覆盖索引",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2ODY3NjUxMw==",
          "body": "假设一个用户表 `User(id primary, name unique, age)`，此时 name 为唯一索引。\r\n\r\n聚合索引: `select * from User where id in (1, 2, 3, 4, 5)`，由于 id 都在 `B+ tree` 的叶子节点，不需要去磁盘进一步 IO，称作聚合索引\r\n\r\n假设有一个需求: 根据 name 查询该人对应的 age，在现有情况下是这样的：\r\n\r\n1. 根据 name 上的 `B+ tree` 快速找到该行对应的 id\r\n1. 根据 id 上的 `B+ tree` 快速找到该行对应的 age，此时需要通过主键 id 进一步 IO，称作回表\r\n\r\n**如果建立一个联合索引 (name, age)，直接在 name 上的 `B+ tree` 就可以找到它对应的 age，省了回表操作，称为覆盖索引**",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI4MTg0Mzg=",
    "number": 387,
    "title": "【Q382】你有没有造过轮子",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI5MDExNDM=",
    "number": 388,
    "title": "【Q000】你最近学习了哪些新技术",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTA1NzU0OA==",
          "body": "##  20200804\r\n\r\n今天看到了 `tailwindcss`，感觉贼好用，很喜欢。基本上是 `class 即 style`，相比 `css modules`，`style-jsx`，可以说是更高层的抽象。虽然从 `bootstrap` 既可以看到这种雏形，但是 `tailwindcss` 做的更彻底，与现代框架集成的也更好\r\n\r\n<https://tailwindcss.com/docs/installation/>\r\n\r\n## 20200805\r\n\r\n`next.js` 最近升级到了 `v9.5.0`，已正式支持了 `custom-routes` 的配置文件写法，详情可以参考文档 [Next.js rewrites](https://nextjs.org/docs/api-reference/next.config.js/rewrites)。而在以前，只能在 `server.js` 中使用 `koa/express` 进行路由拦截来达成目的。\r\n\r\n有时原理虽说比较重要，但此时往往忽略了 API Design 的重要性，假设你要设计一个 Route 的 rewrite/redirect，你会怎么设计 API？可以参考 `nginx`、`koa-routes`、`react-routes` 等\r\n\r\n由于 `next.js` 升级，因为也升级了我的 `next app` 的模板: <https://github.com/shfshanyue/next-app>\r\n\r\n<https://github.com/vercel/next.js/releases/tag/v9.5.0>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI5MDM3MTE=",
    "number": 389,
    "title": "【Q384】python 中的 self 与 javascript 中的 this 有何不同",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQzNzUzNzU=",
    "number": 390,
    "title": "【Q385】什么是缓存穿透，如何解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3MDgzNDY3NQ==",
          "body": "**当访问数据库中不存在的数据时，此时由于不恰当的缓存策略，每次查询都会穿透缓存打在数据库上，这样在高并发下可能造成缓存穿透**，此时的解决方案：\r\n\r\n1. 当应用访问缓存不存在时，应用继续去访问数据库，即便数据库中不存在数据，此时应用再在缓存中把该值设为空，过期时间以短时间为主\r\n1. 使用过滤器做进一步的过滤，如redis 中的 bitmap 或 set，当不存在该值时，直接返回",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3MTEyOTY5NA==",
          "body": "缓存穿透是指 在 redis缓存中 不存在, 同时数据库也不存在的情况,\r\n一旦被黑客利用了, 通过频繁请求 击垮数据库\r\n做法是加 redis和mysql之间加过滤器\r\n在应用启动的时候 用布隆过滤器 将数据库中的值(如id)加载起来放在布隆过滤器中\r\n布隆过滤器 有一定的误差  能判断出这个数据 一定在数据库中, 不能 判断这个数据一定不在数据库中,\r\n他比set好处是 节约更多内存 以为他不是将数据完整的存下, 而是通过多次hash 标志某个位为1,有更高的效率",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manondidi",
            "url": "https://github.com/manondidi"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Fcxzs",
          "body": "要查询的数据在数据库不存在，并且 redis 中未设置特殊标志。导致每次都会查询数据库，造成大量开销。\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wizardforcel",
            "url": "https://github.com/wizardforcel"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQzNzYwMjk=",
    "number": 391,
    "title": "【Q386】什么是浏览器的关键渲染路径",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3MDAwNTAzMQ==",
          "body": "## 01 DOM\r\n\r\n生成 DOM 会从远程下载 Byte，并根据相应的编码 (如 `utf8`) 转化为字符串，通过 AST 解析为 Token，生成 Node 及最后的 DOM。\r\n\r\n> 以下图片来自于 [构建 OM - Google Developers](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model)\r\n\r\nAST 解析过程可以查看 <https://astexplorer.net/>\r\n\r\n![HTML Parse](https://q.shanyue.tech/assets/html-parse.png)\r\n\r\n可以通过 devtools 中查看该过程\r\n\r\n![HTML Parse By devtools](https://q.shanyue.tech/assets/html-parse-devtool.png)\r\n\r\n## 02 CSSOM\r\n\r\n当解析 CSS 文件时，最终会生成 CSSOM\r\n\r\n![CSSOM Image](https://q.shanyue.tech/assets/cssom.png)\r\n\r\n## 03 Render Tree\r\n\r\nDOM 与 CSSOM 会一起生成 Render Tree，只包含渲染网页所需的节点。\r\n\r\n![render tree](https://q.shanyue.tech/assets/render-tree.png)\r\n\r\n## 04 Layout\r\n\r\n计算每一个元素在设备视口内的确切位置和大小\r\n\r\n> 以下图片来自于 [关键渲染路径 - 掘金](https://juejin.im/post/6844903756820119560)\r\n\r\n![Layout](https://q.shanyue.tech/assets/layout.png)\r\n\r\n## 05 Paint\r\n\r\n将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化\r\n\r\n![Paint](https://q.shanyue.tech/assets/paint.png)\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQ0MDk5Nzk=",
    "number": 392,
    "title": "【Q387】http2 中 server push 与 websocket 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNTkzOTU0MQ==",
          "body": "+ HTTP2 Server Push，一般用以服务器根据解析 `index.html` 同时推送 `JPG/JS/CSS` 等资源，而免了服务器发送多次请求\r\n+ websocket，用以服务器与客户端手动编写代码去推送进行数据通信",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs402F3v",
          "body": "[HTTP/2 服务器推送（Server Push）教程](http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzUxMjY1NTU=",
    "number": 393,
    "title": "【Q388】简述下 TLS 握手过程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3MjkxMTU1OQ==",
          "body": "TLS 握手的详细过程可参考下图：\r\n\r\n![](https://static.shanyue.tech/images/23-09-20/clipboard-1116.0ea7d3.webp)\r\n\r\n> 以上图片来自 [high-performance-browser](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html)\r\n\r\n从 `wireshark` 抓包，也可以看到握手的详细流程，建议抓包加强理解，以下是抓包 `https://q.shanyue.tech` 时的握手流程\r\n\r\n通过 `curl -vvv --head` 来查看握手信息:\r\n\r\n``` bash\r\n$ curl -vvv --head  https://q.shanyue.tech\r\n*   Trying 111.6.180.235...\r\n* TCP_NODELAY set\r\n* Connected to q.shanyue.tech (111.6.180.235) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=q.shanyue.tech\r\n*  start date: Dec  2 00:00:00 2019 GMT\r\n*  expire date: Dec  1 12:00:00 2020 GMT\r\n*  subjectAltName: host \"q.shanyue.tech\" matched cert's \"q.shanyue.tech\"\r\n*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=Encryption Everywhere DV TLS CA - G1\r\n*  SSL certificate verify ok.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7f95ba80dc00)\r\n\r\n``` \r\n\r\n## 握手过程\r\n\r\n在 TLS 1.2 中，握手协议过程需要耗费两个 RTT，过程如下\r\n\r\n+ [OUT] Client Hello，客户端选出自身支持的 TLS 版本号、cipher suites、Client Random、SessionId 传送给服务器端 (有可能可复用 Session)\r\n+ [IN] Server Hello，服务器端选出双方都支持的 TLS 版本，cipher suite 、Server Random、SeesionId 给客户端\r\n+ [IN] Certificate，服务器端给客户端发送证书，用以身份验证及提供公钥\r\n+ [IN] Server Key Exchange，服务器端给客户端发送密钥交换算法的一些参数\r\n+ [IN] Server Finished\r\n+ [OUT] Client Key Exchange，客户端给服务器端发送密钥交换算法的一些参数，计算出预主密钥 (`pre master secret`)，使用密钥交换算法（一般是 ECDHE）传递给服务器端。双方根据（Client Random、Server Random、Pre Master Secret）三个随机数生成对称加密中的密钥（`master secret`）。（再根据 `master secret` 生成 `Session Keys`，包括 `Client MAC Key`、`Client Write Key`、`Server MAC Key`、`Server Write Key`。用以以后对的通信加密。）\r\n+ [OUT] Change Cipher Spec，告知以后的消息开始对称加密通信\r\n+ [OUT] Finished，加密消息并完整性验证，标志着握手阶段成功并结束（对握手消息使用 `Client Write Key` 加解密，并使用 `Client MAC Key` 进行完整性校验）\r\n+ [IN] Change Cipher Spec，告知以后的消息开始对称加密通信。此时服务器端通过密钥交换算法拿到 `pre master secret`，并根据三个随机数生成 `master secret`。\r\n+ [IN] Finished，加密消息并完整性验证，标志着握手阶段成功并结束\r\n\r\n> 注，对于（）内容在面试中可以忽略不答\r\n\r\n## 相关链接\r\n\r\n+ [https握手流程详解](https://juejin.im/post/6844904135230390279#heading-10)\r\n+ [Chapter 4. Transport Layer Security (TLS)](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzU5NTIyMTk=",
    "number": 396,
    "title": "【Q389】以下输出顺序多少 (setTimeout 与 promise 顺序)",
    "body": "``` js\r\nsetTimeout(() => console.log(0))\r\nnew Promise((resolve) => {\r\n  console.log(1)\r\n  resolve(2)\r\n  console.log(3)\r\n}).then(o => console.log(o))\r\n\r\nnew Promise(resolve => {\r\n  console.log(4)\r\n  resolve(5)\r\n}).then(o => console.log(o)).then(() => console.log(6))\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3MTQxNTAyMw==",
          "body": "1 => 3 => 4 => 2 => 5 => 6 => 0",
          "star": {
            "totalCount": 5
          },
          "author": null
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzc4MDY4MTU=",
    "number": 397,
    "title": "【Q390】简单介绍一下 RSA 算法",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        },
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzg1NDE4NDE=",
    "number": 398,
    "title": "【Q391】https 层可以做哪些性能优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3MzU2MzE1Mg==",
          "body": "<https://time.geekbang.org/column/article/111287>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzg1NTEzMjM=",
    "number": 399,
    "title": "【Q392】ECDHE 与 RSA 有何区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzkxOTc4NDI=",
    "number": 400,
    "title": "【Q393】作为 TL 如何管理团队",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NzkyMzk1Njc=",
    "number": 401,
    "title": "【Q394】https 中证书的格式化信息有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3ODY0OTQ3Ng==",
          "body": "在 TLS 握手过程中，服务器端需要给客户端提供证书，**X.509 就是证书的标准格式。**\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/90958724-cbae2080-e4c8-11ea-996e-3257721c89fc.png)\r\n\r\n以下是 github 的证书在 Mac 上显示的内容，可见：\r\n\r\n1. 序列号\r\n1. Subject Name\r\n1. Issuer Name\r\n1. 电子签名\r\n1. 签名算法\r\n1. 公钥\r\n1. 扩展\r\n\r\n\r\n\r\n## 相关链接\r\n\r\n+ [What Is an X.509 Certificate?](https://www.ssl.com/faqs/what-is-an-x-509-certificate/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk0ODQ5NTg=",
    "number": 402,
    "title": "【Q395】https 连接时如何保证证书没被废弃掉",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3NDQxNDI4OQ==",
          "body": "两种方式：\r\n\r\n1. CRL（Certificate Revocation List，证书撤销名单）。PKI 体系中由 CA 维护的一个被撤销证书的列表，浏览器会定时拉取这个文件。但这个文件的实时性及性能都可能有问题\r\n1. OCSP（Online Certificate Status Protocol，在线证书状态协议）。客户端通过 OSCP 服务请求接口来判断某个证书是否有效",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk0ODcxNjU=",
    "number": 403,
    "title": "【Q396】TLS1.3 相比 TLS1.2 有何不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3NTIxNDAwMQ==",
          "body": "以下摘自 [RFC 5246: TLS 1.2](https://tools.ietf.org/html/rfc5246#section-7.3)\r\n\r\n``` txt\r\n      Client                                               Server\r\n\r\n      ClientHello                  -------->\r\n                                                      ServerHello\r\n                                                     Certificate*\r\n                                               ServerKeyExchange*\r\n                                              CertificateRequest*\r\n                                   <--------      ServerHelloDone\r\n      Certificate*\r\n      ClientKeyExchange\r\n      CertificateVerify*\r\n      [ChangeCipherSpec]\r\n      Finished                     -------->\r\n                                               [ChangeCipherSpec]\r\n                                   <--------             Finished\r\n      Application Data             <------->     Application Data\r\n\r\n             Figure 1.  Message flow for a full handshake\r\n\r\n   * Indicates optional or situation-dependent messages that are not\r\n   always sent.\r\n```\r\n\r\n以下摘自 [RFC 8446: TLS 1.3](https://tools.ietf.org/html/rfc8446)\r\n\r\n``` txt\r\n       Client                                           Server\r\n\r\nKey  ^ ClientHello\r\nExch | + key_share*\r\n     | + signature_algorithms*\r\n     | + psk_key_exchange_modes*\r\n     v + pre_shared_key*       -------->\r\n                                                  ServerHello  ^ Key\r\n                                                 + key_share*  | Exch\r\n                                            + pre_shared_key*  v\r\n                                        {EncryptedExtensions}  ^  Server\r\n                                        {CertificateRequest*}  v  Params\r\n                                               {Certificate*}  ^\r\n                                         {CertificateVerify*}  | Auth\r\n                                                   {Finished}  v\r\n                               <--------  [Application Data*]\r\n     ^ {Certificate*}\r\nAuth | {CertificateVerify*}\r\n     v {Finished}              -------->\r\n       [Application Data]      <------->  [Application Data]\r\n\r\n              +  Indicates noteworthy extensions sent in the\r\n                 previously noted message.\r\n\r\n              *  Indicates optional or situation-dependent\r\n                 messages/extensions that are not always sent.\r\n\r\n              {} Indicates messages protected using keys\r\n                 derived from a [sender]_handshake_traffic_secret.\r\n\r\n              [] Indicates messages protected using keys\r\n                 derived from [sender]_application_traffic_secret_N.\r\n\r\n               Figure 1: Message Flow for Full TLS Handshake\r\n\r\n```\r\n\r\n1. 握手时间从以前的 2RTT 缩短到 1RTT，通过 `Pre shared-key` 减少了单独的 ServerKeyExchange 与 ClientKeyExchange 消耗的一个 RTT\r\n1. 0-RTT Resumption",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk3NTMzNjY=",
    "number": 404,
    "title": "【Q397】什么是 oauth2，它解决了什么问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5MZ0Ay",
          "body": "OAuth的作用就是让\"客户端\"安全可控地获取\"用户\"的授权，与\"服务商提供商\"进行互动.  参考: https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lpdswing",
            "url": "https://github.com/lpdswing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk3NTQwMTk=",
    "number": 405,
    "title": "【Q398】在 wireshark 中如何抓包 https/http2",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40kCO5",
          "body": "参考: <https://imququ.com/post/http2-traffic-in-wireshark.html>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODA2NTIzODA=",
    "number": 406,
    "title": "【Q399】实现一个 once 函数，记忆返回结果只执行一次",
    "body": "类似于 `lodash.once`\r\n\r\n``` js\r\nconst f = x => x\r\n\r\nconst onceF = once(f)\r\n\r\n//=> 3\r\nonceF(3)\r\n\r\n//=> 3\r\nonceF(4)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3NTUxOTA0NQ==",
          "body": "简单实现如下：\r\n\r\n``` js\r\nfunction once (f) {\r\n  let result\r\n  let revoked = false\r\n  \r\n  return (...args) => {\r\n    if (revoked) return result\r\n    const r = f(...args)\r\n    revoked = true\r\n    result = r\r\n    return r\r\n  }\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n``` js\r\n> const f = () => {console.log('call'); return 3;}\r\n< undefined\r\n\r\n> once_f = once(f)\r\n< (...args) => {\r\n    if (revoked) return result\r\n    const r = f(...args)\r\n    revoked = true\r\n    result = r\r\n  }\r\n\r\n// 第一次调用\r\n> once_f()\r\n< call\r\n< 3\r\n\r\n// 第二次调用，没有打印 call\r\n> once_f()\r\n< 3\r\n```\r\n\r\n[once](https://npm.devtool.tech/once) 是社区使用最广泛的一个库，代码实现与上大同小异，然而每月下载量可达上亿，比 vue/react/angular 三者一个月的下载量加起来还要高一倍",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBgfl",
          "body": "```js\r\nfunction onceCache(fn) {\r\n  let toggle = false,\r\n    ret = null;\r\n  return function () {\r\n    if (toggle) return ret;\r\n    toggle = true;\r\n    return (ret = fn.apply(this, arguments));\r\n  };\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5UEkQp",
          "body": "惰性函数\r\n```js\r\nfunction once(fn) {\r\n  function o(...args) {\r\n    const res = fn(...args)\r\n    o = () => res\r\n    return o()\r\n  }\r\n  return o\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "eva-asdf",
            "url": "https://github.com/eva-asdf"
          }
        },
        {
          "id": "IC_kwDODQzyOs5m2_hp",
          "body": "```\r\nfunction once(func) {\r\n    let revoke = false\r\n    let ret = null\r\n    return function() {\r\n        if (!revoke) {\r\n            ret = func.apply(this, arguments)\r\n            revoke = true\r\n        }\r\n        return ret\r\n    }\r\n}\r\n\r\n// 测试\r\nfunction test() {\r\n    console.log('test')\r\n    return 1\r\n}\r\n\r\nlet o = once(test)\r\n\r\nconsole.log(o()) // test 1\r\nconsole.log(o()) // 1\r\nconsole.log(o()) // 1\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "plutda",
            "url": "https://github.com/plutda"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        },
        {
          "id": "MDU6TGFiZWwzMDkwODMwMjI5",
          "name": "perf"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODA2NjM1NDg=",
    "number": 407,
    "title": "【Q400】如何评估一台服务器的 CPU 性能",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3ODcxNzQxMg==",
          "body": "## sysbench\r\n\r\n``` bash\r\n$ sysbench --threads=4 --time=30 cpu run\r\n\r\nsysbench 1.0.17 (using system LuaJIT 2.1.0-beta3)\r\n\r\nRunning the test with following options:\r\nNumber of threads: 4\r\nInitializing random number generator from current time\r\n\r\n\r\nPrime numbers limit: 10000\r\n\r\nInitializing worker threads...\r\n\r\nThreads started!\r\n\r\nCPU speed:\r\n    events per second:  3651.16\r\n\r\nGeneral statistics:\r\n    total time:                          30.0010s\r\n    total number of events:              109545\r\n\r\nLatency (ms):\r\n         min:                                    1.08\r\n         avg:                                    1.10\r\n         max:                                    5.78\r\n         95th percentile:                        1.12\r\n         sum:                               119955.35\r\n\r\nThreads fairness:\r\n    events (avg/stddev):           27386.2500/91.56\r\n    execution time (avg/stddev):   29.9888/0.00\r\n```\r\n\r\n## stress",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODEwNjA3NjY=",
    "number": 408,
    "title": "【Q401】在 TLS 层如何优化网站性能",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3OTk0MzYzNg==",
          "body": "1. OSCP Stapling\r\n1. TLS 1.3",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODE1OTE1NDk=",
    "number": 409,
    "title": "【Q402】如何实现一个函数 isPlainObject 判断是否为纯对象",
    "body": "纯对象：通过 `Object` 构造函数或者 `Object.create` 构建，见下示例\r\n\r\n``` js\r\n{ a: 3 }\r\n\r\nObject.create({ a: 3 })\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3NTk1MTQzOA==",
          "body": "``` js\r\nfunction isPlainObject(obj: any): boolean {\r\n  if (typeof obj !== 'object' || obj === null) return false\r\n\r\n  let proto = obj\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto)\r\n  }\r\n\r\n  return Object.getPrototypeOf(obj) === proto                                                  } \r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3NzQ4MjkxNQ==",
          "body": "纯对象 如何定义？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Lstoryc",
            "url": "https://github.com/Lstoryc"
          }
        },
        {
          "id": "IC_kwDODQzyOs40125b",
          "body": "> 纯对象 如何定义？\r\n\r\n通过`Object`构造函数创建或`__proto__`是`null`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5aqcUK",
          "body": "这样也可以吧：\r\n```js\r\nconst isPlainObject = o => Object.prototype.toString.call(o).slice(8, -1) === 'Object'\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODE3MzAzOTM=",
    "number": 410,
    "title": "【Q403】React 中的 dom diff 算法如何从 O(n3) 优化到 O(n) 的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MzY3MDAxMA==",
          "body": "> 参考官方文档: [协调的设计动机](https://zh-hans.reactjs.org/docs/reconciliation.html#motivation)\r\n>\r\n> 此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。\r\n> \r\n> 如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：\r\n> \r\n> 1. 两个不同类型的元素会产生出不同的树；\r\n> 1. 开发者可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变；\r\n>\r\n> 在实践中，我们发现以上假设在几乎所有实用的场景下都成立。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODI2MTk1MDM=",
    "number": 411,
    "title": "【Q404】在 React 应用中如何排查性能问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5fxX5E",
          "body": "1、使用 Performance 录制应用快照，查看调用情况\r\n2、查看network中网络请求情况，是否有资源因过大请求阻塞，导致后续资源无法加载，这种情况一般选择分包或固定资源选择cdn分担（多域名。浏览器设置的http2.0以下同域名仅允许同时最多6个tcp的限制）\r\n3、可以通过 React Developer Tools 的 Profiler 的 Flamegraph（火焰图）或 Ranked（渲染时长排行榜） 查看各组件的渲染时长，根据对应的组件可以进行排查渲染问题，以下作答：\r\na). 通过检查代码中是否有重复触发的 useEffect\r\nb). 检查是否有多次不同渲染周期中触发的setState导致的渲染（比如在一个事件中导致的state更新，导致依赖于该state的useEffect触发，而该effect中又有其他的setState，导致多个有依赖项的useEffect不同批次连环触发）\r\nc). 检查是否在某个超大组件中需要渲染的元素过多，可使用子组件可考虑使用 pureComponent，或 React.mome ，或使用useMome来根据依赖项更新子组件，或在父组件中将子组件需要的props通过使用useMome或useCallback缓存， 或在子组件中使用 shouldComponentUpdate 中校验是否需要更新来减少更新\r\nd). 检查是否存在拖拽业务，这类业务一般会导致大量的diff存在，可以的话可以考虑不使用React的方式去实现，使用第三方非React的JS库去实现。\r\ne). 同上情况，存在大量增删改查逻辑，会导致大量的的diff可以检查列表元素是否存在唯一的key，通过key可以让React复用Fiber从而避免重复创建 Fiber节点与 Dom 节点\r\nf). 存在未清除掉的定时器或dom监听事件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CAN1177",
            "url": "https://github.com/CAN1177"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODI4NTI0NDc=",
    "number": 412,
    "title": "【Q405】你使用过哪些前端性能分析工具",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3ODEyMDQ1OA==",
          "body": "chrome 自带的灯箱",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zxhycxq",
            "url": "https://github.com/zxhycxq"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3ODMzNDc0Mg==",
          "body": "最常见且实用的性能工具有两个：\r\n\r\n1. `lighthouse`: 可在 chrome devtools 直接使用，根据个人设备及网络对目标网站进行分析，并提供各种建议\r\n1. `webpagetest`: 分布式的性能分析工具，可在全球多个区域的服务器资源为你的网站进行分析，并生成相应的报告",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5KFGc1",
          "body": "edge也有lighthouse：https://docs.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/accessibility/lighthouse",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODMyMTk5NzM=",
    "number": 413,
    "title": "【Q406】在你们的后端应用中，redis 用在哪些场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3ODcxNDk3NA==",
          "body": "1. 缓存\r\n1. 限流\r\n1. 队列\r\n1. 分布式锁\r\n1. 并发数控制\r\n1. bitmap\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxMTQ1ODU=",
    "number": 414,
    "title": "【Q407】什么是 CPU 缓存，如何查看缓存命中率",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyNDYwNTYyNg==",
          "body": "CPU 缓存介于 CPU 和内存之间，缓存的是热点的内存数据。这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 在同一个cpu核中， 而在同一个CPU插槽中的多个核共享一个 L3 缓存。\r\n\r\n缓存命中率，即直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。当可以直接通过缓存获取到需要的数据，则命中缓存；否则需要从磁盘等地方读取获取数据。缓存命中率越高，表示直接从缓存获取数据的次数越多，程序执行效率越高。\r\n使用cachestat 可以查看整个个操作系统缓存的读写命中情况：\r\ncachestat安装方式：\r\n`sudo apt install perf-tools-unstable`\r\n\r\n下面以1秒间隔输出三组缓存信息：\r\n```\r\n$ sudo cachestat 1\r\nCounting cache functions... Output every 1 seconds.\r\n    HITS   MISSES  DIRTIES    RATIO   BUFFERS_MB   CACHE_MB\r\n    1989        0       13   100.0%          501       2600\r\n   12969        0     1412   100.0%          501       2600\r\n   16798        0     2803   100.0%          501       2600\r\n```\r\n从结果可以看到，HITS 是缓存命中的次数；MISSES是缓存未命中的次数；DIRTIES是表示新增到缓存中的脏页数；BUFFERS_MB 表示 Buffers 的大小，单位为MB；CACHED_MB表示Cache 的大小，单位为MB。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "edisonwd",
            "url": "https://github.com/edisonwd"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxODc1NjA=",
    "number": 415,
    "title": "【Q408】React 17.0 有什么变化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5DfkwO",
          "body": "1.合成事件的变化，事件委托放在了root元素上，同时去掉了事件池\r\n2.全新jsx的变化，可以单独使用jsx，不需要手动引入react;旧版jsx会被转换为React.createElement, 新版jsx转换为_jsx()",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ducaiwei",
            "url": "https://github.com/ducaiwei"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxOTQxNDE=",
    "number": 416,
    "title": "【Q409】什么是 BNF 与 ABNF",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY5Njc1NDg2OQ==",
          "body": "`BNF` (巴克斯范式) 是一种描述编程语言语法的元语言\r\n\r\n`ABNF` (Augmented BNF)，扩展的 BNF，通过 <https://www.ietf.org/rfc/rfc5234.txt> 规范",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQ1MDY3OTI=",
    "number": 417,
    "title": "【Q410】你最近看的三本书是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs42DzUd",
          "body": "1. 鸟哥的linux私房菜\r\n2. node.js 来一打c++扩展\r\n3. 深入理解Typescript",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs42HjIp",
          "body": "@Asarua 第二本书感觉怎么样",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs42HqKs",
          "body": "> @Asarua 第二本书感觉怎么样\r\n\r\nemm，说实话，我不咋会c++，看到第四章开始就看不太明白了，但是光前三章的还是很不错的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OEo5E",
          "body": "极简主义，认知觉醒，卡片笔记写作法 ",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "lonCocoon",
            "url": "https://github.com/lonCocoon"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OEpqT",
          "body": "象与骑象人，脑与认知科学概论，快感",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "WarrenLee19",
            "url": "https://github.com/WarrenLee19"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OEysX",
          "body": "1.西蒙学习法（学习如何高效学习）\r\n2.古龙作品全集（快意江湖，自己也有个写武侠小说的梦）\r\n3.非暴力沟通 （提高自己的情商）",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Guwei1013",
            "url": "https://github.com/Guwei1013"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OE1J-",
          "body": "> \r\n\r\n我也有一段时间沉迷于古龙作品全集，三少爷的剑，多情剑客无情剑，陆小凤传奇，欢乐英雄，武林外史，绝代双骄",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwNzY3MDM=",
    "number": 418,
    "title": "【Q411】如何找到当前页面出现次数最多的HTML标签",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MDQxNjkxNw==",
          "body": "这是一道前端基础与编程功底具备的面试题：\r\n\r\n+ 如果你前端基础强会了解 `document.querySelectorAll(*)` 能够列出页面内所有标签\r\n+ 如果你编程能力强能够用**递归**/**正则**快速实现同等的效果\r\n\r\n有三种 API 可以列出页面所有标签：\r\n\r\n1. `document.querySelectorAll('*')`，标准规范实现\r\n1. `$$('*')`，devtools 实现\r\n1. `document.all`，非标准规范实现\r\n\r\n``` js\r\n> document.querySelectorAll('*')\r\n< NodeList(593) [html, head, meta, meta, meta, meta, meta, meta, meta, title, link#favicon, link, link#MainCss, link#mobile-style, link, link, link, script, script, script, script, script, script, script, link, script, link, link, script, input#_w_brink, body, a, div#home, div#header, div#blogTitle, a#lnkBlogLogo, img#blogLogo, h1, a#Header1_HeaderTitle.headermaintitle.HeaderMainTitle, h2, div#navigator, ul#navList, li, a#blog_nav_sitehome.menu, li, a#blog_nav_myhome.menu, li, a#blog_nav_newpost.menu, li, a#blog_nav_contact.menu, li, a#blog_nav_rss.menu, li, a#blog_nav_admin.menu, div.blogStats, span#stats_post_count, span#stats_article_count, span#stats-comment_count, div#main, div#mainContent, div.forFlow, div#post_detail, div#topics, div.post, h1.postTitle, a#cb_post_title_url.postTitle2.vertical-middle, span, div.clear, div.postBody, div#cnblogs_post_body.blogpost-body, p, p, strong, p, p, p, strong, div.cnblogs_code, pre, span, span, span, span, span, p, span, strong, pre, strong, span, strong, br, br, br, div.cnblogs_code, pre, span, span, p, p, …]\r\n[0 … 99]\r\n[100 … 199]\r\n[200 … 299]\r\n[300 … 399]\r\n[400 … 499]\r\n[500 … 592]\r\n__proto__: NodeList\r\n```\r\n\r\n使用 `document.querySelectorAll` 实现如下\r\n\r\n``` js\r\n// 实现一个 maxBy 方便找出出现次数最多的 HTML 标签\r\nconst maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n\r\nfunction getFrequentTag () {\r\n  const tags = [...document.querySelectorAll('*')].map(x => x.tagName).reduce((o, tag) => { \r\n    o[tag] = o[tag] ? o[tag] + 1 : 1;\r\n    return o\r\n  }, {})\r\n  return maxBy(Object.entries(tags), tag => tag[1])\r\n}\r\n```\r\n\r\n使用 `element.children` 递归迭代如下 (最终结果多一个 document)\r\n\r\n``` js\r\nfunction getAllTags(el = document) {\r\n  const children = Array.from(el.children).reduce((x, y) => [...x, y.tagName, ...getAllTags(y)], [])\r\n  return children\r\n}\r\n\r\n// 或者通过 flatMap 实现\r\nfunction getAllTags(el = document) {\r\n  const children = Array.prototype.flatMap.call(el.children, x => getAllTags(x))\r\n  return [el, ...children]\r\n}\r\n```\r\n\r\n如果你已经快速答了上来，那么还有两道拓展的面试题在等着你\r\n\r\n1. 如何找到当前页面出现次数前三多的 HTML 标签\r\n2. 如过多个标签出现次数同样多，则取多个标签",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MDY5NjAzMA==",
          "body": "使用`document.querySelectorAll`实现如下（包括可能次数一样多的标签）\r\n```javascript\r\nfunction getMostFrequentTag() {\r\n  const counter = {};\r\n\r\n  document.querySelectorAll(\"*\").forEach((element) => {\r\n    counter[element.tagName] = counter[element.tagName]\r\n      ? counter[element.tagName] + 1\r\n      : 1;\r\n  });\r\n\r\n  const orderedTags = Object.entries(counter).sort((tag1, tag2) => {\r\n    if (tag1[1] < tag2[1]) {\r\n      return 1;\r\n    }\r\n    if (tag1[1] > tag2[1]) {\r\n      return -1;\r\n    }\r\n    return 0;\r\n  });\r\n\r\n  const result = [];\r\n  for (const tag of orderedTags) {\r\n    if (tag[1] < orderedTags[0][1]) {\r\n      break;\r\n    }\r\n    result.push(tag[0]);\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Harry3014",
            "url": "https://github.com/Harry3014"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MDcyNDY5Ng==",
          "body": "使用`Element.children`递归实现如下\r\n```javascript\r\nfunction getMostFrequentTag() {\r\n  const counter = {};\r\n\r\n  const traversalElement = (parent) => {\r\n    if (parent.tagName !== undefined) {\r\n      counter[parent.tagName] = counter[parent.tagName]\r\n        ? counter[parent.tagName] + 1\r\n        : 1;\r\n    }\r\n    const children = parent.children;\r\n    for (let i = 0, length = children.length; i < length; i++) {\r\n      traversalElement(children[i]);\r\n    }\r\n  };\r\n\r\n  traversalElement(document);\r\n\r\n  const orderedTags = Object.entries(counter).sort((tag1, tag2) => {\r\n    if (tag1[1] < tag2[1]) {\r\n      return 1;\r\n    }\r\n    if (tag1[1] > tag2[1]) {\r\n      return -1;\r\n    }\r\n    return 0;\r\n  });\r\n\r\n  const result = [];\r\n  for (const tag of orderedTags) {\r\n    if (tag[1] < orderedTags[0][1]) {\r\n      break;\r\n    }\r\n    result.push(tag[0]);\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Harry3014",
            "url": "https://github.com/Harry3014"
          }
        },
        {
          "id": "IC_kwDODQzyOs44B2bx",
          "body": "[codepen demo](https://codepen.io/hwb2017/pen/vYZPPVw)\r\n```javascript\r\nconst allElements = document.querySelectorAll(\"*\")\r\nconst elementFrequency = Array.from(allElements).reduce((a,b) => {\r\n  a[b.tagName] = a[b.tagName] ? a[b.tagName]+1 : 1\r\n  return a\r\n}, {})\r\nconsole.log(elementFrequency)\r\n\r\nconst sortedElementFrequency = Object.entries(elementFrequency).sort((a, b) => b[1] - a[1])\r\nconsole.log(sortedElementFrequency)\r\n\r\nconst copiedElementFrequency = JSON.parse(JSON.stringify(sortedElementFrequency))\r\nconst mergedElementFrequency = copiedElementFrequency.reduce((a,b) => {\r\n  if (a.length === 0) {\r\n    a.push(b)\r\n    return a\r\n  }\r\n  let lastItem = a[a.length - 1]\r\n  if (lastItem[1] === b[1]) {\r\n    // if (Array.isArray(lastItem[0])) {\r\n    //   lastItem[0].push(b[0])\r\n    // } else {\r\n    //   lastItem[0] = [lastItem[0], b[0]]\r\n    // }\r\n    lastItem[0] = Array.isArray(lastItem[0]) ? lastItem[0].concat([b[0],]) : [lastItem[0], b[0]]\r\n  } else {\r\n    a.push(b)\r\n  }\r\n  return a\r\n}, [])\r\nconsole.log(mergedElementFrequency)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Jx7z9",
          "body": "```js\r\n// 获取当前页面所有HTML标签\r\nconst allelements = document.querySelectorAll('*')\r\n\r\nfunction findMost(arr) {\r\n  let temp = {}\r\n  let maxNum = 0\r\n  let maxEle = null\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let ele = arr[i].tagName  // 标签名\r\n    temp[ele] === undefined ? temp[ele] = 1 : temp[ele]++\r\n    if (temp[ele] > maxNum) {\r\n      maxNum = temp[ele]\r\n      maxEle = ele\r\n    }\r\n  }\r\n  // 应考虑次数相同的情况\r\n  let eleArry=[]\r\n  for (let key in temp) {\r\n    if(temp[key]===maxNum){\r\n      eleArry.push(key)\r\n    }\r\n  }\r\n  return { eleArry ,maxNum}\r\n}\r\nlet result = findMost(allelements)\r\nconsole.log(result);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        },
        {
          "id": "IC_kwDODQzyOs5aK0MD",
          "body": "```javascript\r\n// 利用hash\r\nconst map =new Map();\r\n[...document.querySelectorAll(\"*\")].forEach(item => {\r\n    const tagName = item.tagName.toLowerCase(); \r\n    map.set( tagName , map.has(tagName) ? map.get(tagName)+1 : 1);\r\n});\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "hatedMe",
            "url": "https://github.com/hatedMe"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jjxV2",
          "body": "```\r\nfunction findMostEle() {\r\n  const els = document.querySelectorAll(\"*\");\r\n  const map = new Map();\r\n  for (let i = 0; i < els.length; i++) {\r\n    const el = els[i];\r\n    const tag = el.tagName;\r\n    if (map.has(tag)) {\r\n      map.set(tag, map.get(tag) + 1);\r\n    } else {\r\n      map.set(tag, 1);\r\n    }\r\n  }\r\n  return [...map].sort((a, b) => b[1] - a[1]);\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jkGDv",
          "body": "@Ghaining markdown 没有标记 javascript 语言呀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5l5yX8",
          "body": "文中有个代码有错  `使用 element.children 递归迭代如下 (最终结果多一个 document)`\r\n修改如下：\r\n```js\r\nfunction getAllTags(el = document) {\r\n  const children = Array.from(el.children).reduce(\r\n    (x, y) => [...x, y.tagName, ...getAllTags(y)],\r\n    []\r\n  );\r\n  return children;\r\n}\r\n```\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "601odd",
            "url": "https://github.com/601odd"
          }
        },
        {
          "id": "IC_kwDODQzyOs5l-fSQ",
          "body": "@601odd 已修复",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5obOZ5",
          "body": "```js\r\n// 找到当前页面出现次数前几位的 HTML 标签\r\n// 如果多个标签出现次数同样多，则取多个标签\r\nfunction getMaxFreguentTag(top = 1) {\r\n    const tags = [...document.querySelectorAll('*')]\r\n        .map(el => el.tagName)\r\n        .reduce((res, tag) => {\r\n            res[tag] = res[tag] ? res[tag] + 1 : 1\r\n            return res\r\n        }, {})\r\n    \r\n    // 利用数组把标签排序\r\n    const sortedTags = []\r\n    for (const [k, v] of Object.entries(tags)) {\r\n        sortedTags[v] ||= []\r\n        sortedTags[v].push(k)\r\n    }\r\n\r\n    // 数组末尾 top 个非空元素，即所要的结果\r\n    const res = []\r\n    const len = Math.min(top, sortedTags.length)\r\n    for (let i = 0; i < len;) {\r\n        const tag = sortedTags.pop()\r\n        if (tag) {\r\n            res.push(...tag) // 包含同频次标签\r\n            i++\r\n        }\r\n    }\r\n    return res\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        },
        {
          "id": "IC_kwDODQzyOs5rKpTb",
          "body": "`Object.entries($$('*').map(it => it.tagName.toLowerCase()).reduce((cntArr, tag) => { cntArr[tag] = cntArr[tag] ? cntArr[tag] + 1 : 1; return cntArr }, {})).reduce((x, y) => x[1] > y[1] ? x : y)`",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Si3ver",
            "url": "https://github.com/Si3ver"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwNzg4ODk=",
    "number": 419,
    "title": "【Q412】对以下字符串进行压缩编码",
    "body": "这是一道大厂常考的代码题\r\n\r\n+ Input: 'aaaabbbccd'\r\n+ Output: 'a4b3c2d1'，代表 a 连续出现四次，b连续出现三次，c连续出现两次，d连续出现一次\r\n\r\n有以下测试用例\r\n\r\n``` js\r\n//=> a4b3c2\r\nencode('aaaabbbcc')\r\n\r\n//=> a4b3a4\r\nencode('aaaabbbaaaa')\r\n\r\n//=> a2b2c2\r\nencode('aabbcc')\r\n```\r\n\r\n**如果代码编写正确，则可继续深入：**\r\n\r\n+ 如果只出现一次，不编码数字，如 aaab -> a3b\r\n+ 如果只出现两次，不进行编码，如 aabbb -> aab3\r\n+ 如果进行解码数字冲突如何解决",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3OTYyNjgzMw==",
          "body": "编写函数 `encode` 实现该功能\r\n\r\n> 代码见 [【Q412】对以下字符进行压缩编码 - codepen](https://codepen.io/shanyue/pen/bGWrwWM?editors=0012)\r\n\r\n``` js\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = 0\r\n  for (const s of str) {\r\n    const len = l.length\r\n    const lastChar = len > 0 ? l[len - 1][0] : undefined\r\n    if (lastChar === s) {\r\n      l[len - 1][1]++\r\n    } else {\r\n      l.push([s, 1])\r\n    }\r\n  }\r\n  return l.map(x => x.join('')).join('')\r\n}\r\n\r\n// 另外一种思路的解法\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = -1;\r\n  let lastChar\r\n  for (const char of str) {\r\n    if (char !== lastChar) {\r\n      lastChar = char\r\n      i++\r\n      l[i] = [char, 1];\r\n    } else {\r\n      l[i][1]++\r\n    }\r\n  }\r\n  return l.flat().join('')\r\n}\r\n```\r\n\r\n测试通过\r\n\r\n``` js\r\n> encode('aaab')\r\n< \"a3b1\"\r\n```\r\n\r\n但是面试官往往会继续深入\r\n\r\n1. 如果只出现一次，不编码数字，如 `aaab -> a3b`\r\n1. 如果只出现两次，不进行编码，如 `aabbb -> aab3`\r\n1. 如果进行解码，碰到数字如何处理？\r\n\r\n以下是除数字外的进一步编码\r\n\r\n``` js\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = -1;\r\n  let lastChar\r\n  for (const char of str) {\r\n    if (char !== lastChar) {\r\n      lastChar = char\r\n      i++\r\n      l[i] = [char, 1];\r\n    } else {\r\n      l[i][1]++\r\n    }\r\n  }\r\n  return l.map(([x, y]) => {\r\n    if (y === 1) {\r\n      return x\r\n    }\r\n    if (y === 2) {\r\n      return x + x\r\n    }\r\n    return x + y\r\n  }).join('')\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0NDI3NDMwOA==",
          "body": "const encode = function(input) {\r\n  let obj = {}\r\n  for(const key of input) {\r\n    if(obj[key]) {\r\n      obj[key]++\r\n    } else {\r\n      obj[key] = 1\r\n    }\r\n  }\r\n  return Object.entries(obj).flat().join('')\r\n}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "LiJinWD",
            "url": "https://github.com/LiJinWD"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0NDMxMjg5NQ==",
          "body": "const encode = function(input, n) {\r\n  let obj = {}\r\n  for(const key of input) {\r\n    if(obj[key]) {\r\n      obj[key]++\r\n    } else {\r\n      obj[key] = 1\r\n    }\r\n  }\r\n  return Object.entries(obj).flat().join('')\r\n  // 如果只出现一次，不编码数字\r\n  // return Object.entries(obj).flat().join('').replace(/1/gi, '')\r\n  // 如果只出现N次，不进行编码, N是参数\r\n  /* let objArr = Object.entries(obj);\r\n  objArr.forEach(item => {\r\n    if(item[1] == n) {\r\n      item[1] = (new Array(n - 1)).fill(item[0]).join('')\r\n    }\r\n  })\r\n  return objArr.flat().join('') */\r\n}\r\n\r\n\r\nencode('aaaabbbccd', 2)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "LiJinWD",
            "url": "https://github.com/LiJinWD"
          }
        },
        {
          "id": "IC_kwDODQzyOs40iBXY",
          "body": "```js\r\nvar doEncode=(str,nums=0)=>{\r\n    const res=str.split('').reduce((sum,cur)=>{\r\n        sum[cur]?sum[cur]++:sum[cur]=1;\r\n        return sum;\r\n    },{});\r\n    const filteredArr= Object.entries(res).filter(item=>item[1]>nums);\r\n    //const filteredArr= Object.entries(res).map(item=>{item[1]=item[1]>nums?item[1]:'';return item});\r\n    return filteredArr.flat().join('');\r\n}\r\ndoEncode('aaaabbbccd') //\"a4b3c2d1\"\r\ndoEncode('aaaabbbccd',1) //\"a4b3c2\"\r\ndoEncode('aaaabbbccd',2) //\"a4b3\"\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haiifeng",
            "url": "https://github.com/haiifeng"
          }
        },
        {
          "id": "IC_kwDODQzyOs40iHa2",
          "body": "@haiifeng 注意标记下 js 的语法高亮",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4011LZ",
          "body": "```js\r\nfunction encodeString(string) {\r\n  let result = '';\r\n  let stack = [];\r\n  if (!string || !string.length) {\r\n    return result;\r\n  }\r\n  const strArray = string.split('');\r\n  const pick = () => stack[stack.length - 1];\r\n  const concat = () => result = result + pick() + (stack.length > 1 ? stack.length : '');\r\n  \r\n  stack.push(strArray.shift());\r\n  \r\n  while(strArray.length) {\r\n    const letter = strArray.shift();\r\n    if (pick() !== letter) {\r\n      concat();\r\n      stack.length = 0;\r\n    }\r\n    stack.push(letter);\r\n  }\r\n  if (stack.length) {\r\n    concat();\r\n  }\r\n  return result;\r\n}\r\n\r\nconsole.log(encodeString('aaaabbbccd'));\r\nconsole.log(encodeString('aaaabbbcc'));\r\nconsole.log(encodeString('aaaabbbaaaa'));\r\nconsole.log(encodeString('aabbcc'));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs42BED8",
          "body": "[exercism](https://exercism.io) 上出现了这个题目\r\n\r\n```ts\r\nexport default class RunLengthEncoding {\r\n  static encode(input: string): string {\r\n    if (input === \"\") {\r\n      return input;\r\n    }\r\n\r\n    const encoding: string[] = [];\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n      let charCount = 1;\r\n\r\n      while (input[i] === input[i + 1]) {\r\n        charCount++;\r\n        i++;\r\n      }\r\n\r\n      if (charCount === 1) { // 出现一次不编码数字\r\n        encoding.push(input[i]);\r\n      } else {\r\n        encoding.push(input[i] + charCount);\r\n      }\r\n    }\r\n\r\n    return encoding.join(\"\");\r\n  }\r\n\r\n  static decode(input: string): string {\r\n    if (input === \"\") {\r\n      return input;\r\n    }\r\n\r\n    const decoding: string[] = [];\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n      let charCode = input.charCodeAt(i);\r\n      let charCount: string | number = \"\";\r\n\r\n      while (charCode > 47 && charCode < 58) { // 0 ~ 9\r\n        charCount += input[i];\r\n        i++;\r\n        charCode = input.charCodeAt(i);\r\n      }\r\n\r\n      if (charCount === \"\") {\r\n        charCount += \"1\";\r\n      }\r\n\r\n      charCount = Number(charCount);\r\n\r\n      while (charCount) {\r\n        decoding.push(input[i]);\r\n        charCount--;\r\n      }\r\n    }\r\n\r\n    return decoding.join(\"\");\r\n  }\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "IC_kwDODQzyOs42DX6Y",
          "body": "```javascript\r\nfunction encode(str, ignore) {\r\n  const container = new Map()\r\n  for (const s of str) {\r\n    container.set(\r\n      s,\r\n      (container.get(s) ?? 0) + 1\r\n    )\r\n  }\r\n  return Array.from(\r\n    container.entries()\r\n  ).reduce((ret, [char, num]) => {\r\n    if (num === ignore) {\r\n      ret += char.repeat(num)\r\n    } else {\r\n      ret += char + num\r\n    }\r\n    return ret\r\n  }, '')\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs44EkZF",
          "body": "最基础功能的实现:\r\n```javascript\r\nconst encode = (str) => {\r\n    const encodedArray = Array.from(str).reduce((a,b) => {\r\n        if (a.length === 0) {\r\n            a.push(b, 1)\r\n            return a\r\n        }\r\n        let lastChar = a[a.length - 2]\r\n        if (lastChar === b) {\r\n            a[a.length - 1] += 1\r\n        } else {\r\n            a.push(b, 1)\r\n        }\r\n        return a\r\n    }, [])\r\n    return encodedArray.join(\"\")\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-AaSB",
          "body": "```javascript\r\nfunction solution(s, limit) {\r\n    const n = s.length;\r\n    let res = '';\r\n    for (let i = 0, cnt = 0; i < n; i += cnt) {\r\n        cnt = 1;\r\n        while (s[i] === s[i + cnt]) cnt++;\r\n        res += cnt > limit ? s[i] + cnt : s[i].repeat(cnt);\r\n    }\r\n    return res;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "3N26",
            "url": "https://github.com/3N26"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-Vntu",
          "body": "const encode = word => {\r\n  if(!word) return \"\";\r\n  let ary = word.split('');\r\n  let group = {}\r\n  let result = \"\"\r\n  group[ary[0]] = 1\r\n  for(let i = 1, j = ary.length; i <= j; i++) {\r\n    if(ary[i - 1] != ary[i]) {\r\n      result += Object.entries(group).flat().join('')\r\n      group = {}\r\n      group[ary[i]] = 1\r\n    } else {\r\n      group[ary[i]]++\r\n    }\r\n  }\r\n  return result\r\n\r\n}\r\n\r\n\r\n\r\nconst encode1 = word => {\r\n  return word.replace(/1/gi, '')\r\n}\r\n\r\n\r\nconst encode2 = word => {\r\n  let one = word.substring(0, 1)\r\n  let newWord = ''\r\n  for(item of word) {\r\n    newWord += item == 2 ? one : item\r\n    one = item\r\n  }\r\n  return newWord\r\n}\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "LiJinWD",
            "url": "https://github.com/LiJinWD"
          }
        },
        {
          "id": "IC_kwDODQzyOs5AuoxJ",
          "body": "```js\r\nfunction encode(str) {\r\n  let prefix = \"\"; //初识节点\r\n  let num = 0; //计数器\r\n  let result = \"\"; //结果\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (i == 0) {\r\n      prefix = str[i];\r\n    }\r\n\r\n    if (prefix != str[i] || i == str.length - 1) {\r\n      if (i == str.length - 1) {\r\n        num++;\r\n      }\r\n      if (num == 1|| num == 2) {\r\n        result = result + prefix.repeat(num);\r\n      } else {\r\n        result = result + prefix + num;\r\n      }\r\n\r\n      prefix = str[i];\r\n      num = 0;\r\n    }\r\n    num++;\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuli-lovely",
            "url": "https://github.com/yuli-lovely"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Aupk9",
          "body": "```js\r\n// number<10--适用下面\r\nfunction decode(str) {\r\n  let result = \"\";\r\n  for (let i = 1; i <= str.length; i++) {\r\n    console.log();\r\n    if (typeof parseInt(str[i]) === \"number\") {\r\n      result = result + str[i - 1].repeat(parseInt(str[i]));\r\n    }\r\n  }\r\n  return result;\r\n}\r\n//全场景适用\r\nfunction decode2(str) {\r\n  let datas = Array.from(str.matchAll(/[a-z][0-9]*/g));\r\n  let result = \"\";\r\n  for (elem of datas) {\r\n    elem = elem[0];\r\n    result = result + elem[0];\r\n    if (elem.length > 1) {\r\n      result = result + elem[0].repeat(parseInt(elem.substr(1)) - 1);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuli-lovely",
            "url": "https://github.com/yuli-lovely"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Axs9E",
          "body": "好像没看到用正则的解法，我来补充一下:kissing:\r\n感觉用正则来实现，修改编码条件也挺简单的\r\n\r\n```js\r\nfunction encode (str) {\r\n    let res = ''\r\n    const reg = /(\\w)\\1*/g\r\n    const matchs = str.match(reg)\r\n    matchs.forEach((item) => {\r\n        if (item.length > 1) {\r\n            res += item[0] + item.length\r\n        }   else {\r\n            res += item[0]\r\n        }\r\n    })\r\n\r\n    return res\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liting-yes",
            "url": "https://github.com/liting-yes"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BOM4d",
          "body": "```js\r\n    function encode(str) {\r\n        //\r\n        let index = 0\r\n        let result = ''\r\n        while (index < str.length) {\r\n            let count = 1\r\n            result += str[index]\r\n            while (str[index] == str[index + 1]) {\r\n                index++;\r\n                count++\r\n            }\r\n            index++;\r\n            result += count\r\n        }\r\n        console.log(result);\r\n        return result\r\n\r\n    }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fanfankill",
            "url": "https://github.com/fanfankill"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FO3C-",
          "body": "const encode = (str) => str.replace(/([a-zA-Z])\\1+/g, (all, p1) => p1 + all.length)",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "xyuh111",
            "url": "https://github.com/xyuh111"
          }
        },
        {
          "id": "IC_kwDODQzyOs5PKCj0",
          "body": "```js\r\nconst encode = (str) => {\r\n    let hash = {}\r\n    for (const s of str) {\r\n        hash[s] = hash[s] + 1 || 1\r\n    }\r\n    let s = ''\r\n    for (const [key, value] of Object.entries(hash)) {\r\n        //如果只出现一次，不编码数字\r\n        if (value === 1) {\r\n            s = s + key\r\n        } else if (value === 2) {\t//如果只出现两次，不进行编码\r\n            s = s + key + key\r\n        } else {\r\n            s = s + key + value\r\n        }\r\n    }\r\n    return s\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coderWxs",
            "url": "https://github.com/coderWxs"
          }
        },
        {
          "id": "IC_kwDODQzyOs5g_Pxb",
          "body": "```js\r\n// => a4b3c2\r\nconsole.log(encode('aaaabbbcc'))\r\n\r\n// => a4b3a4\r\nconsole.log(encode('aaaabbbaaaa'))\r\n\r\n// => a2b2c2\r\nconsole.log(encode('aabbcc'))\r\n\r\n// =>a3b\r\nconsole.log(encode('aaab'))\r\n\r\nfunction encode(str) {\r\n  const list = str.split('');\r\n  let res = '';\r\n  let count = 1;\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    if (list[i] !== list[i + 1]) {\r\n      if (count === 1) {\r\n        res += list[i];\r\n      } else {\r\n        res += list[i] + count;\r\n      }\r\n      count = 1;\r\n    } else {\r\n      count++;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jW0xQ",
          "body": "```\r\nfunction encode(str) {\r\n  var result = \"\";\r\n  var count = 1;\r\n  for (var i = 0; i < str.length; i++) {\r\n    if (str[i] === str[i + 1]) {\r\n      count++;\r\n    } else {\r\n      result += str[i] + count;\r\n      count = 1;\r\n    }\r\n  }\r\n  console.log(result);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        },
        {
          "id": "IC_kwDODQzyOs5mW10k",
          "body": "// todo 对以下数字进行编码压缩\r\n```js\r\nfunction encode(string, count = 0) {\r\n  const array = string.split(\"\");\r\n  let resultArray = [];\r\n  for (let index = 0; index < array.length; index++) {\r\n    let charCount = 1;\r\n    while (array[index] === array[index + 1]) {\r\n      index++;\r\n      charCount++;\r\n    }\r\n    resultArray.push([array[index], charCount]);\r\n  }\r\n\r\n  return resultArray.reduce((pre, [item, _count]) => {\r\n    if (count >= _count) {\r\n      pre += item.repeat(_count);\r\n    } else {\r\n      pre += `${item}${_count}`;\r\n    }\r\n    return pre;\r\n  }, \"\");\r\n}\r\n```\r\n// todo 如果进行解码，碰到数字如何处理？\r\n```js\r\nfunction decode(string) {\r\n  let res = \"\";\r\n  const array = string.split(\"\");\r\n  for (let index = 0; index < array.length; index++) {\r\n    const element = array[index];\r\n    const count = Number(element);\r\n    if (isNaN(count)) {\r\n      res += element;\r\n    } else {\r\n      //   将前一个字符重复count-1次\r\n      res += array[index - 1].repeat(count - 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nqsjd178559344",
            "url": "https://github.com/nqsjd178559344"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwODAzMjA=",
    "number": 420,
    "title": "【Q413】如何在生产环境部署一个 Node 应用",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUxMDM5Njg=",
    "number": 421,
    "title": "【Q414】git 如何添加与删除一个 submodule",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY3OTYxOTEwMQ==",
          "body": "**添加 submodule**\r\n\r\n``` bash\r\n$ git submodule add :git-url dep\r\n```\r\n\r\n**删除 submodule**\r\n\r\n+ `vim .gitmodules`，找到该模块位置，删掉\r\n+ `vim .git/config`，找到该模块位置，删除\r\n+ `rm -rf .git/module/dep` \r\n+ `git rm --cached dep`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
          "name": "git"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUxNjQwNTU=",
    "number": 422,
    "title": "【Q415】你有没有重客户端状态前端应用的经验",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUxNjczMjc=",
    "number": 423,
    "title": "【Q416】apollo-client 与 react-apollo 在前端应用中扮演什么角色",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUyNjE0MzA=",
    "number": 424,
    "title": "【Q417】什么是 exit code",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczODAwODA5Nw==",
          "body": "`exit code` 代表一个进程的返回码，通过系统调用 `exit_group` 来触发。在 `POSIX` 中，`0` 代表正常的返回码，`1-255` 代表异常返回码，一般主动抛出的错误码都是 `1`。\r\n\r\n这里有一张关于异常码的附表 [Appendix E. Exit Codes With Special Meanings](http://www.tldp.org/LDP/abs/html/exitcodes.html)。\r\n\r\n异常码在操作系统中随处可见，以下是一个关于 `cat` 命令的异常以及它的 `exit code`，并使用 `strace` 追踪系统调用。\r\n\r\n``` bash\r\n$ cat a\r\ncat: a: No such file or directory\r\n\r\n# 使用 strace 查看 cat 的系统调用\r\n# -e 只显示 write 与 exit_group 的系统调用\r\n$ strace -e write,exit_group cat a\r\nwrite(2, \"cat: \", 5cat: )                    = 5\r\nwrite(2, \"a\", 1a)                        = 1\r\nwrite(2, \": No such file or directory\", 27: No such file or directory) = 27\r\nwrite(2, \"\\n\", 1\r\n)                       = 1\r\nexit_group(1)                           = ?\r\n+++ exited with 1 +++\r\n```\r\n\r\n从系统调用的最后一行可以看出，该进行的 `exit code` 是 1，并把错误信息输出到 `stderr` (标准错误的 fd 为2) 中\r\n\r\n## 如何查看 exit code\r\n\r\n从 `strace` 中可以来判断进程的 `exit code`，但是不够方便过于冗余，特别身处 shell 编程环境中。\r\n\r\n**有一种简单的方法，通过 `echo $?` 来确认返回码**\r\n\r\n``` bash\r\n$ cat a\r\ncat: a: No such file or directory\r\n\r\n$ echo $?\r\n1\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUzMjM3ODQ=",
    "number": 425,
    "title": "【Q418】什么是 coredump，如何配置与分析",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODU0Mzc2Nzk=",
    "number": 426,
    "title": "【Q419】DV、OV、EV 类的证书有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MzI3OTg2NA==",
          "body": "+ `Domain Validation`，最低级别的证书校验，Lets Encrypt 就是这种，因此也不怎么需要花钱\r\n+ `Organization Validation`，校验证书中组织身份，从中可以看出公司名称，所在地等信息\r\n+ `Extended Validation`，最高级别的证书校验",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODU0ODMzOTE=",
    "number": 427,
    "title": "【Q420】https 中是如何进行身份认证的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4NzUwNzM3OQ==",
          "body": "电子签名",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODYyNTQyMjA=",
    "number": 428,
    "title": "【Q421】如何实现一个无限累加的 sum 函数",
    "body": "实现一个 sum 函数如下所示：\r\n\r\n``` js\r\nsum(1, 2, 3).valueOf() //6\r\nsum(2, 3)(2).valueOf() //7\r\nsum(1)(2)(3)(4).valueOf() //10\r\nsum(2)(4, 1)(2).valueOf() //9\r\nsum(1)(2)(3)(4)(5)(6).valueOf() // 21\r\n```\r\n\r\n追问:\r\n\r\n如果不使用 `valueOf`，可直接进行计算，如下示例，应如何处理。\r\n\r\n``` js\r\n//=> 15\r\nsum(1, 2, 3) + sum(4, 5)\r\n\r\n//=> 100\r\nsum(10) * sum(10)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MDgzMzk1NA==",
          "body": "> 这还是字节、快手、阿里一众大厂最为偏爱的题目，实际上有一点技巧问题。\r\n\r\n这是一个关于懒计算的函数，使用 `sum` 收集所有累加项，使用 `valueOf` 进行计算\r\n\r\n1. sum 返回一个函数，收集所有的累加项，使用递归实现\r\n1. 返回函数带有 `valueOf` 属性，用于统一计算\r\n\r\n代码见 [【Q421】如何实现无限累加的一个函数](https://codepen.io/shanyue/pen/LYymamZ?editors=0012)，方便测试与调试\r\n\r\n``` js\r\nfunction sum (...args) {\r\n  const f = (...rest) => sum(...args, ...rest)\r\n  f.valueOf = () => args.reduce((x, y) => x + y, 0)\r\n  return f\r\n}\r\n```",
          "star": {
            "totalCount": 6
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40r7nq",
          "body": "> 这是一个关于懒计算的函数，使用 `sum` 收集所有累加项，使用 `valueOf` 进行计算\r\n> \r\n> 1. sum 返回一个函数，收集所有的累加项，使用递归实现\r\n> 2. 返回函数带有 `valueOf` 属性，用于统一计算\r\n> \r\n> ```js\r\n> function sum (...args) {\r\n>   const f = (...rest) => sum(...args, ...rest)\r\n>   f.valueOf = () => args.reduce((x, y) => x + y, 0)\r\n>   return f\r\n> }\r\n> ```\r\n\r\n看了好多遍才理解，大佬果然是大佬。\r\n关键点在于每次调用后返回自己所返回的东西，也就是函数f。\r\n同时收集每次传进来的参数并做对应的操作。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haiifeng",
            "url": "https://github.com/haiifeng"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CxReI",
          "body": "这算不算函数柯里化?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Mingeax",
            "url": "https://github.com/Mingeax"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBjf8",
          "body": "> > 这还是字节、快手、阿里一众大厂最为偏爱的题目，实际上有一点技巧问题。\r\n> \r\n> 这是一个关于懒计算的函数，使用 `sum` 收集所有累加项，使用 `valueOf` 进行计算\r\n> \r\n> 1. sum 返回一个函数，收集所有的累加项，使用递归实现\r\n> 2. 返回函数带有 `valueOf` 属性，用于统一计算\r\n> \r\n> 代码见 [【Q421】如何实现无限累加的一个函数](https://codepen.io/shanyue/pen/LYymamZ?editors=0012)，方便测试与调试\r\n> \r\n> ```js\r\n> function sum (...args) {\r\n>   const f = (...rest) => sum(...args, ...rest)\r\n>   f.valueOf = () => args.reduce((x, y) => x + y, 0)\r\n>   return f\r\n> }\r\n> ```\r\n\r\n这闭包用的让人虎躯一震 太强了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5EqBRb",
          "body": "写一个啰嗦一点的版本供大家参考：\r\n想法很简单：\r\n1. 用一个变量收集所有的参数。\r\n2. 返回一个带有 valueOf 属性的 function。\r\n```javascript\r\nfunction sum(...args: number[]) {\r\n  // allArgs 收集所有的 args\r\n  let allArgs = args;\r\n\r\n  // 返回一个 function 可以接受参数   \r\n  function fn(...args2) {\r\n    allArgs = allArgs.concat(args2);\r\n    return fn;\r\n  }\r\n  \r\n  // function 上有一个属性叫 valueOf\r\n  fn.valueOf = function () {\r\n    // valueOf 触发时才开始累加\r\n    return allArgs.reduce((res, cur) => (res += cur));\r\n  };\r\n  return fn;\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "wangjs-jacky",
            "url": "https://github.com/wangjs-jacky"
          }
        },
        {
          "id": "IC_kwDODQzyOs5HHLw4",
          "body": "function getNum(...args) {\r\n    return args.reduce((prev, next) => {\r\n      return prev + next\r\n    }, 0)\r\n  }",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zfy171",
            "url": "https://github.com/zfy171"
          }
        },
        {
          "id": "IC_kwDODQzyOs5XWIR7",
          "body": "自己尝试写了一版，不过不是懒计算，调用一次算一次，计算的结果利用闭包缓存：\r\n```ts\r\nfunction sum(\r\n  ...args: number[]\r\n) {\r\n  const value = args.reduce((pre, cur) => pre + cur, 0);\r\n\r\n  const _sum = function (..._arg: number[]) {\r\n    return sum.call(null, value, ..._arg);\r\n  };\r\n\r\n _sum.valueOf = () => console.log(value)\r\n\r\n return _sum\r\n\r\n}\r\n\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kirazZ1",
            "url": "https://github.com/kirazZ1"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YJ5sg",
          "body": "> 追问:\r\n> \r\n> 如果不使用 `valueOf`，可直接进行计算，如下示例，应如何处理。\r\n> \r\n> ```js\r\n> //=> 15\r\n> sum(1, 2, 3) + sum(4, 5)\r\n> \r\n> //=> 100\r\n> sum(10) * sum(10)\r\n> ```\r\n\r\n实现这个效果：覆写 `toString` 或 `Symbol.toPrimitive` 即可。\r\n\r\n```js\r\nfunction sum(...args) {\r\n    const f = (...fArgs) => !fArgs.length ? f.toString() : sum(...args, ...fArgs)\r\n    f.toString = () => args.reduce((cur, next) => cur + next)\r\n    return f\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        },
        {
          "id": "IC_kwDODQzyOs5g1JAM",
          "body": "```js\r\nfunction sum(...args){\r\n  const foo = (...rest) => sum(...args, ...rest)\r\n  foo.toString = () => args.reduce((x, y) => x + y, 0)\r\n  return foo\r\n}\r\nconsole.log(sum(1)(2, 3) + sum(1)) // 7\r\nconsole.log(sum(10) * sum(10)) // 100\r\n```\r\n\r\n被这一波操作秀到了reduce真好用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODY4NjEzMTI=",
    "number": 429,
    "title": "【Q422】JS 如何实现一个同步的 sleep 函数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MTIwMjAyOA==",
          "body": "``` js\r\nconst sleep = ms => Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, milliseconds)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41Uu0b",
          "body": "[SharedArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)被禁用了。。。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kissshot",
            "url": "https://github.com/kissshot"
          }
        },
        {
          "id": "IC_kwDODQzyOs41VKy_",
          "body": "@kissshot 貌似是因为有安全问题...",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs42EWEo",
          "body": "```js\r\nfunction sleep (t = 1000) {\r\n    console.log('>>> sleep start');\r\n    let startTime = +(new Date());\r\n    let curTime = startTime;\r\n    while (true) {\r\n        curTime = +(new Date());\r\n        if (curTime - startTime >= t) break;\r\n    }\r\n    console.log('>>> sleep finish');\r\n}\r\n\r\n// test\r\nsleep(3000);\r\nconsole.log('>>> hi');\r\n\r\n// output\r\n>>> sleep start\r\n// 3s later\r\n>>> sleep finish\r\n>>> hi\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hishengs",
            "url": "https://github.com/Hishengs"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBlVH",
          "body": "```ts\r\nfunction sleepSync(ttl) {\r\n  const now = Date.now();\r\n  ttl *= 1000;\r\n  while (Date.now() - now < ttl) {}\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODY4NjIzODI=",
    "number": 430,
    "title": "【Q423】什么是安全的正则表达式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcwNjg5OTA4OQ==",
          "body": "下边这个正则表达式能把 CPU 跑挂的正则表达式就是一个定时炸弹，回溯次数进入了指数爆炸般的增长。\r\n\r\n> 可以参考文章 [浅析 ReDos 原理与实践](https://www.freebuf.com/articles/network/124422.html)\r\n\r\n``` js\r\nconst safe = require('safe-regex')\r\nconst re = /(x+x+)+y/\r\n\r\n// 能跑死 CPU 的一个正则\r\nre.test('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')\r\n\r\n// 使用 safe-regex 判断正则是否安全\r\nsafe(re)   // false\r\n```\r\n\r\n[safe-regex](https://github.com/substack/safe-regex) 能够发现哪些不安全的正则表达式。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2ODg1Mjc0Nzg=",
    "number": 431,
    "title": "【Q424】TCP 是如何进行流量控制的 (flow control)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4MzU3MDU2Ng==",
          "body": "TCP拥塞控制主要有两种。第一种是滑动窗口，保证以一定的速度传输数据，主要是方式数据丢包等问题。第二种是拥塞处理，主要是防止网络中的数据太过多，造成网络拥塞等问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY4NzUzNzYwOA==",
          "body": "TCP中存在发送窗口和接受窗口，发送窗口发送的帧需要接受窗口进行接受，接受成功则返回确认应答，如果没有确认应答返回则进行超时重传，流量控制也是依靠这一点，通过控制窗口的大小来实现对传输速率的控制。相应，类似这一点的逻辑还有TCP的慢启动，逐渐扩大窗口大小，来测试出链路的最大传输速率。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "gmch1",
            "url": "https://github.com/gmch1"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
          "name": "tcp"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2OTEwNjQzMTM=",
    "number": 432,
    "title": "【Q425】什么是层叠上下文 (stacking context)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczODAwNDk1NQ==",
          "body": "> 我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。\r\n\r\n其中，`z-index` 会影响这个层级的优先性",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs401vq3",
          "body": "有一个问题，`z-index:999`，是不是一定可以展示出来？\r\n\r\n但是：\r\n\r\n普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2OTQzNjU5ODU=",
    "number": 433,
    "title": "【Q426】TCP 报文中的选项 Window scale 是什么意思",
    "body": "![image](https://user-images.githubusercontent.com/13389461/92325971-3f335e80-f081-11ea-8f6e-334d5d9e95f6.png)\r\n",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
          "name": "tcp"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2OTQzNzQxMzI=",
    "number": 434,
    "title": "【Q427】TCP 报文中的 ack number 如何计算",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
          "name": "tcp"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3MDkwNTk1NTA=",
    "number": 435,
    "title": "【Q428】在 nginx 中如何配置负载均衡",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcwNzA4MDU0OQ==",
          "body": "通过 `proxy_pass` 与 `upstream` 即可实现最为简单的负载均衡。如下配置会对流量均匀地导向 `172.168.0.1`，`172.168.0.2` 与 `172.168.0.3` 三个服务器\r\n\r\n``` conf\r\nhttp {\r\n  upstream backend {\r\n      server 172.168.0.1;\r\n      server 172.168.0.2;\r\n      server 172.168.0.3;\r\n  }\r\n\r\n  server {\r\n      listen 80;\r\n      location / {\r\n          proxy_pass http://backend;\r\n      }\r\n  }\r\n}\r\n```\r\n\r\n关于负载均衡的策略大致有以下四种种\r\n\r\n1. round_robin，轮询\r\n1. weighted_round_robin，加权轮询\r\n1. ip_hash\r\n1. least_conn\r\n\r\n## Round_Robin\r\n\r\n轮询，`nginx` 默认的负载均衡策略就是轮询，假设负载三台服务器节点为 A、B、C，则每次流量的负载结果为 ABCABC\r\n\r\n## Weighted_Round_Robin\r\n\r\n加权轮询，根据关键字 weight 配置权重，如下则平均没来四次请求，会有八次打在 A，会有一次打在 B，一次打在 C\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1 weight=8;\r\n  server 172.168.0.2 weight=1;\r\n  server 172.168.0.3 weight=1;\r\n}\r\n```\r\n\r\n## IP_hash\r\n\r\n对每次的 IP 地址进行 Hash，进而选择合适的节点，如此，每次用户的流量请求将会打在固定的服务器上，利于缓存，也更利于 AB 测试等。\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1;\r\n  server 172.168.0.2;\r\n  server 172.168.0.3;\r\n  ip_hash;\r\n}\r\n```\r\n\r\n## Least Connection\r\n\r\n选择连接数最少的服务器节点优先负载\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1;\r\n  server 172.168.0.2;\r\n  server 172.168.0.3;\r\n  least_conn;\r\n}\r\n```\r\n\r\n说到最后，**这些负载均衡策略对于应用开发者至关重要，而基础开发者更看重如何实现这些策略**，如这四种负载算法如何实现？请参考以后的文章",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3MDkwODUxMzQ=",
    "number": 436,
    "title": "【Q429】实现一个函数用来解析 URL 的 querystring",
    "body": "示例，如\r\n\r\n``` js\r\nconst url = 'https://shanyue.tech?a=3&b=4&c=5'\r\n\r\n// 解析后得到 qs 如下\r\nconst qs = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\n```\r\n\r\n镜像问题: [【Q440】实现一个函数用来对 URL 的 querystring 进行编码](https://github.com/shfshanyue/Daily-Question/issues/448)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcwMzU2NjM0MQ==",
          "body": "关于路由中解析 querystring，无论前端开发还是后端开发都无时无刻在使用这项功能，即使几乎没有人手动解析过它。这里来实现一个简单粗暴的解析函数\r\n\r\n1. 如何使用正则解析 qs\r\n1. 如何正确转义汉字\r\n1. 如何正确处理数组\r\n1. **如何处理各种复杂的嵌套对象**\r\n\r\n> 关于如何实现复杂嵌套对象，边界条件过多，强烈推荐一个 npm 库 [qs](https://github.com/ljharb/qs)\r\n\r\n为此总结出以下用例用以检查解析函数的正确性\r\n\r\n``` js\r\n// {}\r\n'https://shanyue.tech' \r\n\r\n// {a: ''}\r\n'https://shanyue.tech?a' \r\n\r\n// {name: '山月'}\r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88'    \r\n\r\n// {name: '山月', a: 3}                \r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3'            \r\n\r\n// {name: '山月', a: [3, 4]}\r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3&a=4'   \r\n\r\n// {name: '山月', a: 3}\r\n'https://shanyue.tech?name=%E5%B1%B1%E6%9C%88&a=3#hash' \r\n\r\n// {name: '1+1=2'}\r\n'https://shanyue.tech?name=1%2B1%3D2' \r\n```\r\n\r\n纯碎使用 `javascript` 完成解析函数，而不利用浏览器 DOM 特性 API，代码如下所示，细节在注释中体现\r\n\r\n``` js\r\nfunction parse(url) {\r\n\r\n  // 一、夹杂在 ? 与 # 之前的字符就是 qs，使用 /\\?([^/?#:]+)#?/ 正则来抽取\r\n  // 使用正则从 URL 中解析出 querystring\r\n  // 二、通过 Optional Chain 来避免空值错误\r\n  const queryString = url.match(/\\?([^/?#:]+)#?/)?.[1]\r\n\r\n  if (!queryString) { return {} }\r\n\r\n  queryObj = queryString.split('&').reduce((params, block) => {\r\n    // 三、如果未赋值，则默认为空字符串\r\n    const [_k, _v = ''] = block.split('=')\r\n    // 四、通过 decodeURIComponent 来转义字符，切记不可出现在最开头，以防 ?tag=test&title=1%2B1%3D2 出错\r\n    const k = decodeURIComponent(_k)\r\n    const v = decodeURIComponent(_v)\r\n\r\n    if (params[k] !== undefined) {\r\n      // 处理 key 出现多次的情况，设置为数组\r\n      params[k] = [].concat(params[k], v)\r\n    } else {\r\n      params[k] = v\r\n    }\r\n    return params\r\n  }, {})\r\n  return queryObj\r\n}\r\n```\r\n\r\n如果引入浏览器特性 API，问题就简单很多迎刃而解，所涉及到的 API 有两个，这里不做展开\r\n\r\n1. `new URL(url)`\r\n1. `new URLSearchParams(paramsString)`",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcwODEzMzUxMg==",
          "body": "一开始`decodeURIComponent(url)`是否不妥，如果query string中的value带有`=`等字符并且已经被`encodeURIComponent`，如`http://example.com?tag=test&title=1%2B1%3D2`中`title=1+1=2`，使用parse解析的结果是错误的。使用`params[k] = decodeURIComponent(v)`是不是更好",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "ly023",
            "url": "https://github.com/ly023"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0NDAyODk3OA==",
          "body": "@ly023 感谢老哥指正",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBmS1",
          "body": "```ts\r\nfunction url2Params(url) {\r\n  const dict = {};\r\n  url.replace(/([^?&]*)=([^&]*)/g, (__, key, val) => {\r\n    key = decodeURIComponent(key);\r\n    val = decodeURIComponent(val);\r\n    if (dict[key]) return (dict[key] = [dict[key], val].flat());\r\n    dict[key] = val;\r\n  });\r\n  return dict;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MNWBQ",
          "body": "使用 URLSearchParams\r\n```javascript\r\nfunction parse() {\r\n  let serach = window.location.search\r\n  let params = new URLSearchParams(serach),queryObj={}\r\n  for(let [k,v] of params.entries()){\r\n    if(queryObj[k]!==undefined){\r\n      queryObj[k] = [].concat(queryObj[k],v)\r\n    }else{\r\n      queryObj[k] = v\r\n    }\r\n  }\r\n return queryObj\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Younglina",
            "url": "https://github.com/Younglina"
          }
        },
        {
          "id": "IC_kwDODQzyOs503SgF",
          "body": "```javascript\r\nfunction qsParse(url = '') {\r\n  const params = {};\r\n  if (url.includes('?')) {\r\n    let startIndex = url.indexOf('?');\r\n    if (startIndex !== -1) {\r\n      url = url.slice(startIndex + 1);\r\n    }\r\n  }\r\n\r\n  const pairs = url.split('&');\r\n  for (let pair of pairs) {\r\n    const [key, value] = pair.split('=');\r\n    const decodeKey = decodeURIComponent(key);\r\n    const decodeValue = decodeURIComponent(value);\r\n\r\n    if (params.hasOwnProperty(decodeKey)) {\r\n      if (Array.isArray(params[decodeKey])) {\r\n        params[decodeKey].push(decodeValue);\r\n      } else {\r\n        params[decodeKey] = [params[decodeKey], decodeValue];\r\n      }\r\n    } else {\r\n      params[decodeKey] = decodeValue;\r\n    }\r\n  }\r\n  return params;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hviwen",
            "url": "https://github.com/hviwen"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3MTg4MDAxODc=",
    "number": 437,
    "title": "【Q430】如何把 DOM 转化为图片",
    "body": "可参考npm package\r\n\r\n1. [html2canvas](https://html2canvas.hertzen.com/): Screenshots with JavaScript\r\n1. [dom-to-image](https://github.com/tsayen/dom-to-image): Generates an image from a DOM node using HTML5 canvas",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMDI1MDg5MA==",
          "body": "https://www.zhangxinxu.com/study/201708/svg-foreignobject-dom-to-image.html\r\n看到这样一篇文章",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "markgong-gd",
            "url": "https://github.com/markgong-gd"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTYyOTA1MA==",
          "body": "DOM -> SVG -> Canvas -> JPEG/PNG",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1NDQ4NTQwNA==",
          "body": "核心 foreignObject",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc0NDkxNDg=",
    "number": 438,
    "title": "【Q431】http 状态码 401 和 403 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODk5MDI0MQ==",
          "body": "401 --- unAuthorized  \r\n403 --- forbidden\r\n区别：前者需要用户验证，验证成功之后服务器会执行请求。\r\n           后者是服务器理解请求，但是拒绝执行。跟用户验证没有关系，服务器主动拒绝执行请求。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "IC_kwDODQzyOs5me1Li",
          "body": "## [401 Unauthorized](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/401)\r\n\r\n401，请求的资源没有权限，需要认证。一般代表没有携带 token，或者 token 失效，而造成对该资源没有权限。需重新认证，传递正确的 token。\r\n\r\n## [403 Forbidden](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/403) \r\n\r\n403，请求的资源禁止访问。一般代表用户所拥有的权限不满足该资源的权限。如学生去访问教师资源，学生 A 访问学生 B 的成绩单等数据资源。还有一种情况是爬虫爬取页面被监控到而返回 403。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc4ODI0NzY=",
    "number": 439,
    "title": "【Q432】如何给 graphql 设计合理的 Rate Limit",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczNzk5ODYyNQ==",
          "body": "对于 Rest API 而言可根据特定的 API 来进行*限流(Rate Limit)*设计\r\n\r\n然而，GraphQL 只有一个 API，无法根据此来限流，一般情况下根据 `Field` 来进行限流，为了更好地设计及声明限流条件，可自定义 `Directive`，如下所示\r\n\r\n``` gql\r\ntype Query {\r\n  todos: [Todo!]! @rateLimit(window: \"1s\", max: 100)\r\n}\r\n```\r\n\r\n可参考以下两个 npm package\r\n\r\n+ [graphql-rate-limit](https://github.com/teamplanes/graphql-rate-limit)\r\n+ [graphql-rate-limit-directive](https://github.com/ravangen/graphql-rate-limit)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc5MDU1MzQ=",
    "number": 440,
    "title": "【Q433】在C语言中，void 是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxNDkwNzMzOA==",
          "body": "`void`，空的意思，意即无需返回。\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n  return;\r\n}\r\n\r\nint main() {\r\n  print();\r\n  return 0;\r\n}\r\n```\r\n\r\n代码如上所示: `return` 没有返回任何东西，为其简便可以省略不写，以下两者是等价的\r\n\r\n``` c\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n  return;\r\n}\r\n\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OPoUI",
          "body": "表示为空，跟 ts 一样的。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuetong3yu",
            "url": "https://github.com/yuetong3yu"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3MzMyNjMxMjI=",
    "number": 441,
    "title": "【Q434】当服务器资源返回 304 时与那些 HTTP 响应头有关",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcxOTYzNTkyNg==",
          "body": "304 Not Modified，表示资源没有发生过改变。\r\n与协商缓存有关，也就是Last-Modify和Etag两个http响应头，在获取资源之前先判断缓存资源是否发生过改变。\r\nno-cache表示使用缓存资源时，都向服务器请求验证。\r\nno-store才表示不使用任何形式的缓存。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "IC_kwDODQzyOs5mjbvy",
          "body": "再次请求时，需要向服务器校验新鲜度，如果资源是新鲜的，返回 304，从浏览器获取资源\r\n\r\n``` bash\r\n           client         server\r\nGET /a.js   ----------->\r\n                   <----------- 200 OK\r\nGET /a.js   ----------->\r\n                   <----------- 304 Not Modified\r\n```\r\n\r\n与之相关的 Request/Response Headers 有以下几个\r\n\r\n+ `Last-Modified`/`If-Modified-Since`\r\n+ `Etag`/`If-None-Match`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3MzQxNTU5OTE=",
    "number": 442,
    "title": "【Q435】JS 如何实现一个 sleep/delay 函数",
    "body": "`sleep` 函数实现较为简单，也常作为对 `Promise` 的代码考察。在日常工作中，特别是 Node 写脚本时，常用它控制频率。\r\n\r\n实现一个 sleep 函数格式如下：\r\n\r\n``` ts\r\ntype sleep = (s: number) => Promise<void>\r\n```\r\n\r\n**追问:**\r\n\r\n实现一个 delay 函数格式如下，在 N 毫秒之后执行函数，并以函数结果作为返回值\r\n\r\n``` ts\r\nfunction delay (func, seconds, ...args) {\r\n\r\n}\r\n\r\n// 在 3s 之后返回 hello, world\r\nawait delay((str) => str, 3000, 'hello, world')\r\n\r\n// 在 3s 之后返回 hello, world，第一个函数可返回 promise\r\nawait delay((str) => Promise.resolve(str), 3000, 'hello, world')\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyNTg2NzU3Nw==",
          "body": "```javascript\r\nfunction delay(time) {\r\n    return new Promise((resolve)=> {\r\n        setTimeout(() => {\r\n            resolve()\r\n        }, time)\r\n    })\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yuuk",
            "url": "https://github.com/yuuk"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczNjM2MDUyMQ==",
          "body": "```ts\r\nconst sleep = (t = 0) => new Promise(resolve => setTimeout(resolve, t));\r\n\r\nconst delay = <T extends (...args: any[]) => any>(\r\n  func: T,\r\n  seconds: number,\r\n  ...args: Parameters<T>\r\n): Promise<ReturnType<T>> => sleep(seconds).then(() => func(...args));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "canvascat",
            "url": "https://github.com/canvascat"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0MjIwMzE2Mw==",
          "body": "```js\r\nfunction sleep(milliseconds) {\r\n  var start = new Date().getTime();\r\n  for (var i = 0; i < 1e7; i++) {\r\n    if ((new Date().getTime() - start) > milliseconds) {\r\n      break;\r\n    }\r\n  }\r\n}\r\n```\r\nfrom: [kurento-utils-js](https://github.com/Kurento/kurento-utils-js/blob/1a9d1720f89540a6beae7b1236788a2ee0b9c379/lib/WebRtcPeer.js#L189-L196)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "canvascat",
            "url": "https://github.com/canvascat"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3Nzk0OTQ5Ng==",
          "body": "`sleep` 函数既是面试中常问到的一道代码题，也是日常工作，特别是测试中常用的一个工具函数。\r\n\r\n实现起来较为简单，一行即可实现，代码如下\r\n\r\n``` js\r\nconst sleep = (seconds) => new Promise(resolve => setTimeout(resolve, seconds))\r\n```\r\n\r\n实现一个 delay 稍微复杂点，代码见 [【Q435】JS 如何实现一个 sleep/delay 函数](https://codepen.io/shanyue/pen/qBmoNRq?editors=0012)\r\n\r\n``` js\r\nfunction delay (func, seconds, ...args) {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      Promise.resolve(func(...args)).then(resolve).catch(reject)\r\n    }, seconds)\r\n  })\r\n}\r\n```\r\n\r\n使用代码测试：\r\n\r\n``` js\r\nconsole.log(new Date())\r\ndelay((str) => {\r\n  console.log(new Date())\r\n  return str\r\n}, 3000, 'shanyue').then(o => console.log(o))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs408-pF",
          "body": "```typescript\r\ntype resolving<P = any> = (res: P) => void\r\n\r\nfunction delay<P extends any[], T extends (...args: P) => any = () => null>\r\n    (func: T, seconds: number = 0, ...args: P): Promise<ReturnType<T>> {\r\n    let _resolve: resolving<ReturnType<T>>\r\n    let _reject: resolving\r\n    setTimeout(() => {\r\n        try {\r\n            _resolve(func(...args))\r\n        } catch(e) {\r\n            _reject(e)\r\n        }\r\n\r\n    }, seconds)\r\n    return new Promise((resolve, reject) => {\r\n        _resolve = resolve\r\n        _reject = reject\r\n    })\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs408_rV",
          "body": "@heretic-G 如果写成 TS 的话，如何标记 type",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs409AHu",
          "body": "```javascript\r\nasync function delay(func, second, ...args) {\r\n  return await new Promise(resolve => {\r\n    setTimeout(() => {\r\n      resolve(func(...args))\r\n    }, second)\r\n  })\r\n}\r\n\r\ndelay(str => str, 3000, 'Hello world').then(res => {\r\n  console.log(res)\r\n})\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hengistchan",
            "url": "https://github.com/hengistchan"
          }
        },
        {
          "id": "IC_kwDODQzyOs409CJv",
          "body": "@HengistChan 如果 return promise 的话，应该可以不需要加 async/await",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CB4F7",
          "body": "使用setTimeout有意义吗",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shengrongchun",
            "url": "https://github.com/shengrongchun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5po5-m",
          "body": "> 实现一个 delay 稍微复杂点，代码见 [【Q435】JS 如何实现一个 sleep/delay 函数](https://codepen.io/shanyue/pen/qBmoNRq?editors=0012)\r\n> \r\n> ```js\r\n> function delay (func, seconds, ...args) {\r\n>   return new Promise((resolve, reject) => {\r\n>     setTimeout(() => {\r\n>       Promise.resolve(func(...args)).then(resolve).catch(reject)\r\n>     }, seconds)\r\n>   })\r\n> }\r\n> ```\r\n@shfshanyue setTimeout 里应该需要 try/catch 一下 Promise.resolve().catch() 捕捉不到异常。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NDEyMjEyMjM=",
    "number": 443,
    "title": "【Q436】如何实现一个 sample 函数，从数组中随机取一个元素",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyODg0ODc5OQ==",
          "body": "function sample(arr){\r\n  const index = Math.floor(Math.random() * arr.length )\r\n  return arr[index]\r\n}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "eriksyuan",
            "url": "https://github.com/eriksyuan"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyOTY0OTU1Nw==",
          "body": "```javascript\r\nArray.prototype.sample = function() {\r\n   if(!Array.isArray(this)) {\r\n       throw new Error(\"not a Array\");\r\n    }\r\n\r\n    return this[Math.floor(Math.random()*this.length)]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "reveriesMeng",
            "url": "https://github.com/reveriesMeng"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMDgxNDM1NQ==",
          "body": "```js\r\nfunction random(n,m) {\r\n            var result = Math.random()*(m+1-n)+n;\r\n            while(result>m) {\r\n                result = Math.random()*(m+1-n)+n;\r\n            }\r\n            return Math.round(result);\r\n        }\r\n\r\nArray.prototype.sample = function() {\r\n   if(!Array.isArray(this)) {\r\n       throw new Error(\"not a Array\");\r\n    }\r\n\r\n    return this[random(0, this.length-1)]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "271853754",
            "url": "https://github.com/271853754"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczMDgzNjY2NQ==",
          "body": "> Math.random() 函数返回一个浮点,  伪随机数在范围从0到小于1，用数学表示就是 [0, 1)，可以利用它来实现 `sample` 函数\r\n\r\n``` js\r\nArray.prototype.sample = function () { return this[Math.floor(Math.random()*this.length)] }\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDczODcxMDI2OQ==",
          "body": "Math.random() 函数返回一个浮点, 伪随机数在范围从0到小于1，用数学表示就是 [0, 1)，可以利用它来实现 sample 函数\r\nArray.prototype.sample = function() {\r\nreturn this[Math.floor(Math.random()*this.length)]\r\n};\r\n@shfshanyue 调用时箭头函数this不是指向调用数组，写成普通函数有效",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "tangli06",
            "url": "https://github.com/tangli06"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0Mzk0MDEwOA==",
          "body": "@tangli06 大意了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NDMwMDA4MzY=",
    "number": 444,
    "title": "【Q437】浏览器的剪切板中如何监听复制事件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDcyOTM0MzcxNw==",
          "body": "在HTML元素上\r\n```html\r\n<input oncopy='cb'>\r\n```\r\n在JS中获取具体元素\r\n```js\r\ndocument.querySelector('p').oncopy = cb\r\ndocument.oncopy = cb\r\n```\r\n或者\r\n```js\r\ndocument.querySelector('p').addEventListener('copy',cb)\r\ndocument.addEventListener('copy',cb)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nishuzumi",
            "url": "https://github.com/nishuzumi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NjEzNzkwNTI=",
    "number": 445,
    "title": "【Q438】数据库设计时 char 与 varchar 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5sxVrn",
          "body": "char和varchar都可以用来储存字符串并且设置长度，但char的长度是固定的，当字符串不够长度的时候会填充空格，varchar的长度是变化的，会储存实际的长度不会填充空格，但是查询的性能char要好于varchar，所以在数据库设计的时候，如果字段长度是固定的就使用char，否则使用varchar。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ansonlovecoding",
            "url": "https://github.com/ansonlovecoding"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NjUyMTc2MDQ=",
    "number": 447,
    "title": "【Q439】JSONP 的原理是什么，如何实现",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0Nzc5ODEyMg==",
          "body": "摘自山月的博客，原文地址: <https://shanyue.tech/code/jsonp/>\r\n\r\n\r\n## 一个正常的请求: JSON\r\n\r\n正常发请求时，`curl` 示例:\r\n\r\n``` bash\r\n$ curl https://shanyue.tech/api/user?id=100\r\n\r\n{\r\n  \"id\": 100,\r\n  \"name\": \"shanyue\",\r\n  \"wechat\": \"xxxxx\",\r\n  \"phone\": \"183xxxxxxxx\"\r\n}\r\n```\r\n\r\n使用 `fetch` 发送请求，示例:\r\n\r\n``` js\r\nconst data = await fetch('https://shanyue.tech/api/user?id=100', {\r\n  headers: {\r\n    'content-type': 'application/json',\r\n  },\r\n  method: 'GET',\r\n}).then(res => res.json())\r\n```\r\n\r\n请求数据后，使用一个函数来处理数据\r\n\r\n``` js\r\nhandleData(data)\r\n```\r\n\r\n## 一个 JSONP 请求\r\n\r\n`JSONP`，全称 `JSON with Padding`，为了解决跨域的问题而出现。虽然它只能处理 GET 跨域，虽然现在基本上都使用 CORS 跨域，但仍然要知道它，毕竟**面试会问**。\r\n\r\n`JSONP` 基于两个原理:\r\n\r\n1. 动态创建 `script`，使用 `script.src` 加载请求跨过跨域\r\n1. `script.src` 加载的脚本内容为 JSONP: 即 `PADDING(JSON)` 格式\r\n\r\n从上可知，使用 `JSONP` 跨域同样需要服务端的支持。`curl` 示例\r\n\r\n``` bash\r\n$ curl https://shanyue.tech/api/user?id=100&callback=padding\r\n\r\npadding({\r\n  \"id\": 100,\r\n  \"name\": \"shanyue\",\r\n  \"wechat\": \"xxxxx\",\r\n  \"phone\": \"183xxxxxxxx\"\r\n})\r\n```\r\n\r\n对于正常的请求有何不同一目了然: **多了一个 callback=padding, 并且响应数据被 padding 包围**，这就是 JSONP\r\n\r\n**那请求数据后，如何处理数据呢？此时的 padding 就是处理数据的函数**。我们只需要在前端实现定义好 padding 函数即可\r\n\r\n``` js\r\nwindow.padding = handleData\r\n```\r\n\r\n基于以上两个原理，这里实现一个简单 jsonp 函数：\r\n\r\n``` js\r\nfunction jsonp_simple ({ url, onData, params }) {\r\n  const script = document.createElement('script')\r\n\r\n  // 一、默认 callback 函数为 padding\r\n  script.src = `${url}?${stringify({ callback: 'padding', ...params })}`\r\n\r\n  // 二、使用 onData 作为 window.padding 函数，接收数据\r\n  window['padding'] = onData\r\n\r\n  // 三、动态加载脚本\r\n  document.body.appendChild(script)\r\n}\r\n\r\n// 发送 JSONP 请求\r\njsonp_simple({\r\n  url: 'http://localhost:10010',\r\n  params: { id: 10000 },\r\n  onData (data) {\r\n    console.log('Data:', data)\r\n  }\r\n})\r\n```\r\n\r\n此时会有一个问题: **window.padding 函数会污染全局变量，如果有多个 JSONP 请求发送如何处理？**\r\n\r\n**使 jsonp 的回调函数名作为一个随机变量，避免冲突**，代码如下\r\n\r\n``` js\r\nfunction jsonp ({ url, onData, params }) {\r\n  const script = document.createElement('script')\r\n\r\n  // 一、为了避免全局污染，使用一个随机函数名\r\n  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`\r\n\r\n  // 二、默认 callback 函数为 cbFnName\r\n  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`\r\n\r\n  // 三、使用 onData 作为 cbFnName 回调函数，接收数据\r\n  window[cbFnName] = onData;\r\n\r\n  document.body.appendChild(script)\r\n}\r\n\r\n// 发送 JSONP 请求\r\njsonp({\r\n  url: 'http://localhost:10010',\r\n  params: { id: 10000 },\r\n  onData (data) {\r\n    console.log('Data:', data)\r\n  }\r\n})\r\n```\r\n\r\n## 服务器端代码\r\n\r\n`JSONP` 需要服务端进行配合，返回 `JSON With Padding` 数据，代码如下:\r\n\r\n``` js\r\nconst http = require('http')\r\nconst url = require('url')\r\nconst qs = require('querystring')\r\n\r\nconst server = http.createServer((req, res) => {\r\n  const { pathname, query } = url.parse(req.url)\r\n  const params = qs.parse(query)\r\n\r\n  const data = { name: 'shanyue', id: params.id }\r\n\r\n  if (params.callback) {\r\n    // 服务端将要返回的字符串\r\n    str = `${params.callback}(${JSON.stringify(data)})`\r\n    res.end(str)\r\n  } else {\r\n    res.end()\r\n  }\r\n})\r\n\r\nserver.listen(10010, () => console.log('Done'))\r\n\r\n```\r\n\r\n## 完整代码附录\r\n\r\n完整代码可见[山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code): <https://github.com/shfshanyue/blog/tree/master/code/jsonp/>\r\n\r\n**JSONP 实现完整代码:**\r\n\r\n``` js\r\nfunction stringify (data) {\r\n  const pairs = Object.entries(data)\r\n  const qs = pairs.map(([k, v]) => {\r\n    let noValue = false\r\n    if (v === null || v === undefined || typeof v === 'object') {\r\n      noValue = true\r\n    }\r\n    return `${encodeURIComponent(k)}=${noValue ? '' : encodeURIComponent(v)}`\r\n  }).join('&')\r\n  return qs\r\n}\r\n\r\nfunction jsonp ({ url, onData, params }) {\r\n  const script = document.createElement('script')\r\n\r\n  // 一、为了避免全局污染，使用一个随机函数名\r\n  const cbFnName = `JSONP_PADDING_${Math.random().toString().slice(2)}`\r\n  // 二、默认 callback 函数为 cbFnName\r\n  script.src = `${url}?${stringify({ callback: cbFnName, ...params })}`\r\n  // 三、使用 onData 作为 cbFnName 回调函数，接收数据\r\n  window[cbFnName] = onData;\r\n\r\n  document.body.appendChild(script)\r\n}\r\n```\r\n\r\n**JSONP 服务端适配相关代码:**\r\n\r\n``` js\r\nconst http = require('http')\r\nconst url = require('url')\r\nconst qs = require('querystring')\r\n\r\nconst server = http.createServer((req, res) => {\r\n  const { pathname, query } = url.parse(req.url)\r\n  const params = qs.parse(query)\r\n\r\n  const data = { name: 'shanyue', id: params.id }\r\n\r\n  if (params.callback) {\r\n    str = `${params.callback}(${JSON.stringify(data)})`\r\n    res.end(str)\r\n  } else {\r\n    res.end()\r\n  }\r\n\r\n})\r\n\r\nserver.listen(10010, () => console.log('Done'))\r\n```\r\n\r\n**JSONP 页面调用相关代码**\r\n\r\n``` html\r\n\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title></title>\r\n</head>\r\n<body>\r\n  <script src=\"./index.js\" type=\"text/javascript\"></script>\r\n  <script type=\"text/javascript\">\r\n  jsonp({\r\n    url: 'http://localhost:10010',\r\n    params: { id: 10000 },\r\n    onData (data) {\r\n      console.log('Data:', data)\r\n    }\r\n  })\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n## JSONP 实现代码示例演示\r\n\r\n+ 从中克隆代码: [山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code)\r\n+ 从中克隆代码: [山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code)\r\n+ 从中克隆代码: [山月博客的 github 仓库](https://github.com/shfshanyue/blog/tree/master/code)\r\n\r\n### 文件结构\r\n\r\n+ `index.js`: jsonp 的简单与复杂实现\r\n+ `server.js`: 服务器接口形式\r\n+ `demo.html`: 前端如何调用 JSONP\r\n\r\n### 快速演示\r\n\r\n``` js\r\n// 开启服务端\r\n$ node server.js\r\n\r\n// 对 demo.html 起一个服务，并且按照提示在浏览器中打开地址，应该是 http://localhost:5000\r\n// 观察控制台输出 JSONP 的回调结果\r\n$ serve .\r\n```\r\n\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NjU0OTM2Mjg=",
    "number": 448,
    "title": "【Q440】实现一个函数用来对 URL 的 querystring 进行编码",
    "body": "示例，如\r\n\r\n``` js\r\nconst data = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\n\r\n// 对 data 编码后得到 querystring 如下\r\n//=> 'a=3&b=4&c=5'\r\nstringify(data)\r\n```\r\n\r\n镜像问题: [【Q429】实现一个函数用来解析 URL 的 querystring](https://github.com/shfshanyue/Daily-Question/issues/436)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0NDM0ODYwMw==",
          "body": "先上几个测试用例:\r\n\r\n``` js\r\n// a=3&b=4\r\nstringify({ a: 3, b: 4 })\r\n\r\n// a=3&b=\r\nstringify({ a: 3, b: null })\r\n\r\n// a=3&%E5%B1%B1=%E6%9C%88\r\nstringify({ a: 3, '山': '月' })\r\n```\r\n\r\n只做一些基本的功能，满足以下条件\r\n\r\n1. 对 null/undefined/object 编码为空字符\r\n1. 对 key/value 记得 encodeURIComponent\r\n1. 不考虑数组及嵌套对象等复杂操作\r\n\r\n``` js\r\nfunction stringify (data) {\r\n  const pairs = Object.entries(data)\r\n  const qs = pairs.map(([k, v]) => {\r\n    let noValue = false\r\n    if (v === null || v === undefined || typeof v === 'object') {\r\n      noValue = true\r\n    }\r\n    return `${encodeURIComponent(k)}=${noValue ? '' : encodeURIComponent(v)}`\r\n  }).join('&')\r\n  return qs\r\n}\r\n```\r\n\r\n这是一个最简单对 querystring 进行编码的函数，如果需要更复杂的需求如嵌套对象与数组可以参考 [qs](https://github.com/ljharb/qs)",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBpv2",
          "body": "```ts\r\nfunction stringify(obj) {\r\n  return encodeURI(Object.entries(obj).reduce((acc, [key, val]) => `${acc ? `${acc}&` : \"?\"}${key}=${val || \"\"}`, \"\"));\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MTgzOTc=",
    "number": 449,
    "title": "【Q441】v8 是如何执行一段 JS 代码的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0NzgzMzMyNA==",
          "body": "## 参考几篇文章\r\n\r\n+ [V8是如何执行JavaScript代码的？](https://zhuanlan.zhihu.com/p/96502646)\r\n+ [[译]JavaScript是如何工作的：深入V8引擎&编写优化代码的5个技巧](https://zhuanlan.zhihu.com/p/57898561)\r\n+ [JavaScript 引擎 V8 执行流程概述](https://zhuanlan.zhihu.com/p/111386872)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MzU4MjY=",
    "number": 450,
    "title": "【Q442】http3 解决了什么问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0Nzg0NDg2NA==",
          "body": "`http3` 基于 `UDP` 协议，这是与以前版本的 http 最大的不同，可以解决 http2 TCP 连接阻塞的问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5B4_uf",
          "body": "我们都知道 `UDP` 不可靠，那么如何保证连接传输的`可靠性`？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "marsk6",
            "url": "https://github.com/marsk6"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MzcyMDk=",
    "number": 451,
    "title": "【Q443】实现一个数组扁平化的函数 flatten ",
    "body": "`flatten` 模拟 `Array.prototype.flat` 实现，默认展开一层，可传递参数用以展开多层\r\n\r\n``` js\r\n// [1, 2, 3, 4, [5, 6]]\r\nflatten([1, 2, 3, [4, [5, 6]]])\r\n\r\n// [1, 2, 3, 4, 5, 6]\r\nflatten([1, 2, 3, [4, [5, 6]]], 2)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MjY3NDg4MQ==",
          "body": "在 ES2019 之前，可通过 **`reduce` + `concat`** 实现，由于 `Array.prototype.concat` 既可以连接数组又可以连接单项，十分巧妙\r\n\r\n``` js\r\nconst flatten = list => list.reduce( (a, b) => a.concat(b), [])\r\n```\r\n\r\n一个更简单的实现方式是 `Array.prototype.concat` 与 `...` 运算符\r\n\r\n``` js\r\nconst flatten = list => [].concat(...list)\r\n```\r\n\r\n如果要求深层数组打平，则如下实现\r\n\r\n``` js\r\nconst flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), [])\r\n```\r\n\r\n如果要求如同原生 API `Array.prototype.flat` 一致的 API，可传入可扁平的深度。代码可见 [【Q443】实现一个数组扁平化的函数 flatten](https://codepen.io/shanyue/pen/xxdjQXG?editors=0012)\r\n\r\n``` js\r\nfunction flatten (list, depth = 1) {\r\n  if (depth === 0) return list\r\n  return list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b, depth - 1) : b), [])\r\n}\r\n```\r\n\r\n在 ES2019 之后，可通过 **`Array.prototype.flat`** 直接实现！",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1ODM0NDM5MQ==",
          "body": "您好作者，您的实现方式最多只能降维一层深度。\r\n```javascript\r\nconst flatten = list => list.reduce( (a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), [])\r\n```\r\n不仅如此，ES2019的flat还支持传入***depth***来降维指定的深度。",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "reveriesMeng",
            "url": "https://github.com/reveriesMeng"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc2MDI2Mjk3MQ==",
          "body": "@reveriesMeng 好的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTQ3MTgxMw==",
          "body": "```\r\nconst flatten = (arr, d = 1) => d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatten(val, d - 1) : val), []) : arr.slice()\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "demon-zhonglin",
            "url": "https://github.com/demon-zhonglin"
          }
        },
        {
          "id": "IC_kwDODQzyOs401tlm",
          "body": "```js\r\nfunction flat(array, depth = Number.MAX_VALUE) {\r\n  let result = [...array];\r\n  while (result.some(i => Array.isArray(i) && depth > 0)) {\r\n    // 注意concat方法的参数valueN，即可是数值也可以是数组，当时数组时存在隐形的展开操作\r\n    // concat方法不改变原数组，返回一个新数组\r\n    result = [].concat(...result);\r\n    depth--;\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs41ELe8",
          "body": "@haotie1990 原生 API 默认是 1，当然这个题目我也没有规定，不过 depth 用 MAX_SAFE_INTEGER 或者 Infinity 好一些？\r\n\r\n而且该 API 也不涉及对数组自身的操作，应该无需 `[...array]`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs442LXr",
          "body": "function flatten(arr) {  \r\n    return arr.reduce((result, item)=> {\r\n        return result.concat(Array.isArray(item) ? flatten(item) : item);\r\n    }, []);\r\n}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs442Mp6",
          "body": "function flatten(arr) {\r\n    return arr.toString().split(',').map(function(item) {\r\n        return Number(item);\r\n    })\r\n} \r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs5AGBc2",
          "body": "一种使用迭代器的实现：\r\n``` JavaScript\r\nconst flatten = function(target, depth = 1) {\r\n  const copy = [...target]\r\n  for(let i = 0; i < depth; ++i){\r\n    const iter = copy[Symbol.iterator]()\r\n    let item = null\r\n    for(item = iter.next(); !item.done; ){\r\n      // 注意：迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是用游标来记录遍历可迭代对象的历程，\r\n      // 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化\r\n      if(Array.isArray(item.value)){\r\n        const temp = [...item.value]\r\n        let size = temp.length\r\n        for(let j = 0; j < size; ++j){\r\n          item = iter.next()\r\n        }\r\n        copy.splice(copy.indexOf(item.value), 1, ...temp)\r\n      }else{\r\n        item = iter.next()\r\n      } \r\n    }\r\n    /* for(let item of copy){\r\n      if(Array.isArray(item)){\r\n        const temp = [...item]\r\n        copy.splice(copy.indexOf(item), 1, ...temp)\r\n      }\r\n    } */\r\n  }\r\n  return copy\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "3fuyang",
            "url": "https://github.com/3fuyang"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DBql5",
          "body": "支持depth为0\r\n```ts\r\nfunction flatten(arr = [], depth = 1) {\r\n  return arr.reduce((acc, cur) => acc.concat(Array.isArray(cur) && depth > 0 ? flatten(cur, --depth) : [cur]), []);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5GVwTi",
          "body": "基于递归实现，不用 Array.concat\r\n```typescript\r\nArray.prototype.myFlat = function (this: any[], depth: number = 1) {\r\n  const myFlat = (arr: any[], flatLength = 1, resultArray = [] as any[], forEachCount = 0) => {\r\n    arr.forEach((d: any) => {\r\n      if (Array.isArray(d) && (flatLength === -1 || forEachCount < flatLength)) {\r\n        myFlat(d, flatLength, resultArray, forEachCount + 1);\r\n      } else {\r\n        resultArray.push(d);\r\n      }\r\n    });\r\n\r\n    return resultArray;\r\n  };\r\n\r\n  return myFlat(this, depth);\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bldf",
            "url": "https://github.com/bldf"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1MzgyMDg=",
    "number": 452,
    "title": "【Q444】介绍 CSS 隐藏页面中某个元素的几种方法",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NTA0NDYyOQ==",
          "body": "CSS方法一：\r\n`display:none`\r\nCSS方法二：\r\n`position:absolute;top:-1000px;left:-1000px;`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "borgle",
            "url": "https://github.com/borgle"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NjE1OTA1OA==",
          "body": "> 更多的隐藏方案可查看: [10 Ways to Hide Elements in CSS](https://www.sitepoint.com/hide-elements-in-css/)\r\n\r\n## 01 display: none\r\n\r\n通过 CSS 操控 display，移出文档流\r\n\r\n``` css\r\ndisplay: none;\r\n```\r\n\r\n## 02 opacity: 0\r\n\r\n透明度为0，仍在文档流中，当作用于其上的事件(如点击)仍有效\r\n\r\n``` css\r\nopacity: 0;\r\n```\r\n\r\n## 03 visibility: hidden\r\n\r\n透明度为0，仍在文档流中，**但作用于其上的事件(如点击)无效**，这也是 `visibility:hidden` 与 `opacity: 0` 的区别\r\n\r\n``` css\r\nvisibility: hidden;\r\n```\r\n\r\n## 04 content-visibility\r\n\r\n移出文档流，但是再次显示时消耗性能低\r\n\r\n``` css\r\ncontent-visibility: hidden;\r\n```\r\n\r\n## 05 绝对定位于当前页面的不可见位置\r\n\r\n``` css\r\nposition: absolute;\r\ntop: -9000px;\r\nleft: -9000px;\r\n```\r\n\r\n## 06 字体大小设置为 0\r\n\r\n``` css\r\nfont-size: 0;\r\n```\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1Mzk1NzM=",
    "number": 453,
    "title": "【Q445】实现一个数组去重函数 unique",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc2MDc1MTgyNw==",
          "body": "```js\r\nfunction unique(arr) {\r\n  if (!Array.isArray(arr)) throw new TypeError();\r\n  return [...new Set(arr)];\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "joyz0",
            "url": "https://github.com/joyz0"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MzY2Njc1OQ==",
          "body": "```\r\nfunction unique(arr){\r\n    const map = new Map()\r\n    arr.forEach(value=>{\r\n        map.set(value,value)\r\n    })\r\n    const list = []\r\n    for (let key of map.keys()) {\r\n      list.push(key)\r\n    }\r\n    return list\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HuiFeiYa",
            "url": "https://github.com/HuiFeiYa"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTY3ODU1Mw==",
          "body": "``` js\r\nconst unique = list => [...new Set(list)]\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs401s27",
          "body": "```js\r\nfunction unique(array) {\r\n  return array.filter((item, index) => array.indexOf(item) === index);\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DJw3C",
          "body": "```ts\r\nfunction unique(arr) {\r\n  return arr.reduce((acc, item) => (acc.includes(item) ? acc : acc.concat(item)), []);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA1NDA5Njk=",
    "number": 454,
    "title": "【Q446】如何实现页面文本不可复制",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0Nzg1MDQ3Mg==",
          "body": "`user-select: none` 不可选中就不可复制👀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ssruoyan",
            "url": "https://github.com/ssruoyan"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0ODE2ODY4OQ==",
          "body": "有 CSS 和 JS 两种方法，以下任选其一或结合使用\r\n\r\n使用 CSS 如下：\r\n\r\n``` css\r\nuser-select: none;\r\n```\r\n\r\n或使用 JS 如下，监听 `selectstart` 事件，禁止选中。\r\n\r\n当用户选中一片区域时，将触发 `selectstart` 事件，Selection API 将会选中一片区域。禁止选中区域即可实现页面文本不可复制。\r\n\r\n``` js\r\ndocument.body.onselectstart = e => {  \r\n  e.preventDefault();\r\n}\r\n\r\ndocument.body.oncopy = e => {  \r\n  e.preventDefault();\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JyELs",
          "body": "https://zhuanlan.zhihu.com/p/348299601",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzA5NjUyNDU=",
    "number": 455,
    "title": "【Q447】如何实现一个数组洗牌函数 shuffle",
    "body": "参考链接：https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n\r\n``` js\r\n// 打乱数组，有可能是 [1, 3, 2, 4]，但对原数组没有影响\r\nshuffle([1, 2, 3, 4])\r\n``` ",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0ODE1MjU2Mw==",
          "body": "先来一个利用 `Array.prototype.sort` 的技巧解法\r\n\r\n``` js\r\nconst shuffle = (list) => list.sort((x, y) => Math.random() - 0.5)\r\n```\r\n\r\n使用以下算法可实现洗牌算法:\r\n\r\n1. 第 N 项数字与前 N 项数字随机选一相互交换\r\n2. 第 N-1 项数字与前 N-1 项数字随机选一相互交换\r\n3. ...\r\n3. 第 2 项数字与前 2 项数字随机选一相互交换\r\n\r\n代码调试及测试可见 [【Q447】如何实现一个数组洗牌函数 shuffle - codepen](https://codepen.io/shanyue/pen/KKmRqZJ?editors=0012)\r\n\r\n``` js\r\nfunction shuffle (list) {\r\n  const len = list.length\r\n  let result = [...list]\r\n  for (let i = len - 1; i > 0; i--) {\r\n    const swapIndex = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[swapIndex]] = [result[swapIndex], result[i]]\r\n  }\r\n  return result\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs401sI3",
          "body": "```js\r\nfunction shuffle(array) {\r\n  let len = array.length;\r\n  let _array = [...array];\r\n  while (len) {\r\n    let index = Math.floor(Math.random() * len--);\r\n    [_array[index], _array[len]] = [_array[len], _array[index]];\r\n  }\r\n  return _array;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DJxCP",
          "body": "```ts\r\nfunction shuffle([...arr]) {\r\n  const arrLen = arr.length;\r\n  for (let i = 0; i < arrLen; i++) {\r\n    const randomIdx = Math.floor(Math.random() * arrLen);\r\n    [arr[randomIdx], arr[i]] = [arr[i], arr[randomIdx]];\r\n  }\r\n  return arr;\r\n}\r\n\r\nfunction shuffle([...arr]) {\r\n  return arr.sort(() => Math.random() - 0.5);\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzE2MTE4MzA=",
    "number": 456,
    "title": "【Q448】异步加载 JS 脚本时，async 与 defer 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0ODk5MzM5OA==",
          "body": "> 以下图片取自 whatwg 的规范，可以说是最权威的图文解释了，详细参考[原文](https://html.spec.whatwg.org/multipage/scripting.html#the-script-element)\r\n\r\n![async 与 defer 区别](https://html.spec.whatwg.org/images/asyncdefer.svg)\r\n\r\n在*正常情况下*，即 `<script>` 没有任何额外属性标记的情况下，有几点共识\r\n\r\n1. JS 的脚本分为**加载、解析、执行**几个步骤，简单对应到图中就是 `fetch` (加载) 和 `execution` (解析并执行)\r\n2. **JS 的脚本加载(fetch)且执行(execution)会阻塞 DOM 的渲染**，因此 JS 一般放到最后头\r\n\r\n而 `defer` 与 `async` 的区别如下:\r\n\r\n+ 相同点: **异步加载 (fetch)** \r\n+ 不同点:\r\n  + async 加载(fetch)完成后立即执行 (execution)，因此可能会阻塞 DOM 解析；\r\n  + defer 加载(fetch)完成后延迟到 DOM 解析完成后才会执行(execution)**，但会在事件 `DomContentLoaded` 之前\r\n\r\n## 拓展\r\n\r\n当以下 `index.js` 加载时，属性是 `async` 与 `defer` 时，输出有何不同？\r\n\r\n**index.html**\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title></title>\r\n</head>\r\n<body>\r\n  <script src=\"./defer.js\" defer></script>\r\n  <script src=\"./async.js\" async></script>\r\n  <script>\r\n    console.log('Start')\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n      console.log('DCL')\r\n    })\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**derfer.js**\r\n\r\n``` js\r\nconsole.log('Defer Script')\r\n```\r\n\r\n\r\n**async.js**\r\n\r\n``` js\r\nconsole.log('Async Script')\r\n```\r\n\r\n答：defer 总是在 DCL 之前输出，但是 async 有可能之前也有可能之后",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzUwOTkzNQ==",
          "body": "start/Async Script/DCL",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhujianxiong",
            "url": "https://github.com/zhujianxiong"
          }
        },
        {
          "id": "IC_kwDODQzyOs5J664v",
          "body": "> start/Async Script/DCL\r\n\r\n应该是 `start` => `defer script` => `DCL`，`async script`是脱离DOM的，和加载自身文件的大小有关，文件比较小的，加载快，然后执行；文件大的加载慢，然后执行。与`DOMContentLoaded`事件关系不确定。但`JS`脚本都是在`Load`事件前加载并执行完毕的，`Load`事件是兜底事件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzIyMTMwMTQ=",
    "number": 457,
    "title": "【Q449】vue3 中，如何监听数组的变化",
    "body": "比如深层数组如何监听",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3NTc3OTYzNA==",
          "body": "不需要额外监听，因为 Proxy 代理后的数据，数组的修改也是可以监听到的，reactive 之后直接修改即可。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "18sby",
            "url": "https://github.com/18sby"
          }
        },
        {
          "id": "IC_kwDODQzyOs40vLxi",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs442ILg",
          "body": "let list = []\r\nconst listProxy = new Proxy(list, {\r\n    set(target, property, value) {\r\n        console.log('set', property, value) //property指下标 value值\r\n        target[property] = value\r\n        return true //表示设置成功\r\n    }\r\n})\r\n\r\nlistProxy.push(100)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzIyMTUyNDE=",
    "number": 458,
    "title": "【Q450】Vue 中 nextTick 的实现原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0OTAwOTQzMw==",
          "body": "+ Promise\r\n+ MutationObserver\r\n+ setImmediate\r\n+ setTimeout",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5RX6vh",
          "body": "nextTick方法主要是使用了宏任务和微任务。它是定义了一个异步方法，如果多次调用nextTick的话，就会将方法存入队列中，通过这个异步方法来清空当前队列，这个nextTick方法就是异步方法",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangenze267",
            "url": "https://github.com/wangenze267"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzIyMTg5NDU=",
    "number": 459,
    "title": "【Q451】同一进程的线程共享那些资源",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc0OTAwODU5Ng==",
          "body": "+ 堆\r\n+ 全局变量\r\n+ 文件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzMwNDI0MzI=",
    "number": 460,
    "title": "【Q452】现代框架如 React、Vue 相比原生开发有什么优势",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs442H_3",
          "body": "render（UI）",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs46IKg7",
          "body": "react、vue：\r\n1、一套代码维护Android和ios两个平台，减少开发成本\r\n2、相同功能可以使用组件复用\r\n3、两个平台可以同时更新，原生代码更新时需要审核",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzYyMzk3NTE=",
    "number": 461,
    "title": "【Q453】typeof 与 instanceof 的区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MjMyNjc5NQ==",
          "body": "1. `typeof` 用以**判断基础数据类型** (null 除外)\r\n2. `instanceOf` 借助原型链**判断复杂数据类型**\r\n\r\n如以下示例：\r\n\r\n``` js\r\n> typeof 3\r\n< \"number\"\r\n> [] instanceof Array\r\n< true\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0Nzc2OTQ0OQ==",
          "body": "`typeof` 能够准确检查除了 null 之外的基础数据类型(number, string, symbol, bigInt, undefined, boolean, null)\r\n\r\n```javascript\r\n> typeof null\r\n\"object\"\r\n```\r\n\r\n`instanceof` 的语义是检查操作符右边的函数原型是否存在于左边对象的原型链中\r\n\r\n知识来源: [JavaScript 忍者秘籍](https://book.douban.com/subject/30143702/)",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzkxODA5Nw==",
          "body": "> `typeof` 能够准确检查除了 null 之外的基础数据类型(number, string, symbol, bingInt, undefined, boolean, null)\r\n> \r\n> ```js\r\n> > typeof null\r\n> \"object\"\r\n> ```\r\n> \r\n> `instanceof` 的语义是检查操作符右边的函数原型是否存在于左边对象的原型链中\r\n> \r\n> 知识来源: [JavaScript 忍者秘籍](https://book.douban.com/subject/30143702/)\r\n\r\n@liweinandever 真是学习了，今天我才注意到 `bigint` 也是基本数据类型，见文档 [Primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)，另外你这里的 `bigint` 有个 typoerror",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DJxiv",
          "body": "我不管你问什么 我就做题\r\n```ts\r\nfunction myInstanceof(obj, clazz) {\r\n  let proto = Object.getPrototypeOf(obj);\r\n  while (proto && proto !== clazz.prototype) {\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n  return !!proto;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzYyNTU3MDc=",
    "number": 462,
    "title": "【Q454】load 事件与 DomContentLoaded 事件的先后顺序",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs401qaK",
          "body": "当初始的 `HTML` 文档被完全加载和解析完成之后，`DOMContentLoaded` 事件被触发，而无需等待样式表、图像和子框架的完全加载.\r\n\r\n当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发`load`事件\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3NzYyNTgyNzg=",
    "number": 463,
    "title": "【Q455】React/Vue 中的 router 实现原理如何",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MzkxNDg0NQ==",
          "body": "前端路由实现的本质是**监听url变化**，实现方式有两种：Hash模式和History模式，无需刷新页面就能重新加载相应的页面。\r\nHash url的格式为`www.a.com/#/`，当#后的哈希值发生变化时，通过hashchange事件监听，然后页面跳转。\r\nHistory url通过`history.pushState`和`history.replaceState`改变url。\r\n两种模式的区别：\r\n\r\n- hash只能改变#后的值，而history模式可以随意设置同源url；\r\n- hash只能添加字符串类的数据，而history可以通过API添加多种类型的数据；\r\n- hash的历史记录只显示之前的`www.a.com`而不会显示hash值，而history的每条记录都会进入到历史记录；\r\n- hash无需后端配置且兼容性好，而history需要配置`index.html`用于匹配不到资源的情况。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MzEyMzAxMw==",
          "body": "前端路由有两种实现方式:\r\n\r\n## history API\r\n\r\n+ 通过 `history.pushState()` 跳转路由\r\n+ 通过 `popstate event` 监听路由变化，但无法监听到 `history.pushState()` 时的路由变化\r\n\r\n## hash\r\n\r\n+ 通过 `location.hash` 跳转路由\r\n+ 通过 `hashchange event` 监听路由变化",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Eutxo",
          "body": "@buzuosheng hash的历史记录也会显示hash值,也会放到历史记录, chrome 102",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zyzweb",
            "url": "https://github.com/zyzweb"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0MDgzMjU=",
    "number": 464,
    "title": "【Q456】简述 RPC 的实现原理",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0MDgzOTU=",
    "number": 465,
    "title": "【Q457】如何对微服务进行拆分",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0NTQ4NDY=",
    "number": 466,
    "title": "【Q458】服务器CPU过高时如何排查及解决问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MzQ3MTIzNA==",
          "body": "1. `htop` 查询CPU使用率最高的进程\r\n2. `pidstat` 监控该进程的变化并调试: `pidstat -u -p pid`\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0NTU4NDg=",
    "number": 467,
    "title": "【Q459】mysql 中 limit offset 过大导致查询缓慢的原因及解决方案",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NjUwOTkwNQ==",
          "body": "``` sql\r\nSELECT * FROM User LIMIT 1000000, 10\r\n```\r\n\r\n如上语句，跳过 1000000 行用户，取其后的 10 个用户。**其中 offset 过大，将会进行 1000000 行扫描，导致磁盘 IO 多大，拖垮数据库**\r\n\r\n解决方案也很简单: **取出这10个用户的 ID，由于查询 ID 使用聚簇索引，避免 100000 行的磁盘 IO，再通过子查询找到这 10 个用户的所有数据**\r\n\r\n更多链接: [Mysql index configuration](https://stackoverflow.com/questions/1612957/mysql-index-configuration)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3Nzc0NzY4NDE=",
    "number": 468,
    "title": "【Q460】在服务端反爬虫有哪些策略",
    "body": "在服务端反爬/防爬有哪些策略",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1MzU3MTgxMw==",
          "body": "## 01 Referer: 当前页面的访问源\r\n\r\nReferer 指当前请求页面的来源页面的地址，用以判断当前页面的访问源。一般用以反爬，比如**图片防盗链**通过判断 `Referer` 是否目标网站而对图片替换为禁止标志的图片。\r\n\r\n## 02 User-Agent: 当前页面的用户代理，如浏览器等\r\n\r\nUser-Agent 指请求当前页面的用户代理，用以标识请求方环境，如浏览器等，如果没有这个字符串可以视为爬虫。同时为了避免伪造用户代理，可以对 User-Agent 进行**限流**，但同时也有随机生成 UA 的库\r\n\r\n+ [random-useragent](https://github.com/skratchdot/random-useragent)\r\n\r\n## 03 Rate-Limit: 限流\r\n\r\n+ 对 IP 地址进行限流\r\n+ 对 UA 进行限流\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3ODIwODY5MzE=",
    "number": 469,
    "title": "【Q461】如何计算白屏时间和首屏时间",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwOTg4MTgxNA==",
          "body": "\r\n白屏时间: window.performance.timing.domLoading - window.performance.timing.navigationStart\r\n\r\n首屏时间: window.performance.timing.domInteractive  - window.performace.timing.navigationStart",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "hhhpw",
            "url": "https://github.com/hhhpw"
          }
        },
        {
          "id": "IC_kwDODQzyOs48HWVi",
          "body": "首屏时间: window.performance.timing.domInteractive - window.performace.timing.navigationStart\r\n\r\nwindow.performace.timing.navigationStart\r\n\r\nperformace ->  performance少了个n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuyuehui",
            "url": "https://github.com/wuyuehui"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3ODIwOTA5NTg=",
    "number": 470,
    "title": "【Q462】JS 如何翻转一个字符串",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc1NjczNjA5Ng==",
          "body": "``` js\r\nconst reverse = s => s.split('').reverse().join('')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc2Nzk1MTkwMg==",
          "body": "```js\r\nconst reverse = s => [...s].reduceRight((acc, cur) => acc + cur)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Bulandent",
            "url": "https://github.com/Bulandent"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3ODM5MDIwNzQ=",
    "number": 471,
    "title": "【Q463】前端如何实现文件上传功能",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40ySSx",
          "body": "Blob -> ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BCRHN",
          "body": "将input的类型设置为file，再加一个按钮就行 \r\n```html\r\n<input type=\"file\" ref=\"referenceUpload\" @change=\"onUpload\"></input> \r\n<button type=\"primary\" style=\"margin: 0px 0px 0px -83px;\">上传文件</button> \r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hsq777",
            "url": "https://github.com/hsq777"
          }
        },
        {
          "id": "IC_kwDODQzyOs5O4K1L",
          "body": "html 中直接设置 input 的类型为 file 就可以实现上传了\r\n\r\n```html\r\n// HTML\r\n<input type=\"file\" id=\"upload\"/>\r\n```\r\n```js\r\n// JS\r\nconst uploadInput = document.getElementById('upload');\r\nconst handleUpload = (event) => {\r\n  const file = event.target.files[0];\r\n  const formData = new FormData();\r\n  formData.append('file', file);\r\n  // 文件上传操作\r\n}\r\nuploadInput.addEventListener('change', handleUpload) \r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HydratedPig",
            "url": "https://github.com/HydratedPig"
          }
        },
        {
          "id": "IC_kwDODQzyOs5O4MWd",
          "body": "> html 中直接设置 input 的类型为 file 就可以实现上传了\r\n> \r\n> ```\r\n> // HTML\r\n> <input type=\"file\" id=\"upload\"/>\r\n> ```\r\n> \r\n> ```js\r\n> // JS\r\n> const uploadInput = document.getElementById('upload');\r\n> const handleUpload = (event) => {\r\n>   const file = event.target.files[0];\r\n>   const formData = new FormData();\r\n>   formData.append('file', file);\r\n>   // 文件上传操作\r\n> }\r\n> uploadInput.addEventListener('change', handleUpload) \r\n> ```\r\n\r\n当然也可以放在表单里，统一提交表单\r\n[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#examples)的示例里还告诉我们input 各个浏览器长得不一样，我们也可以用其他东西隐藏 input ",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "HydratedPig",
            "url": "https://github.com/HydratedPig"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3ODY1MzE3ODg=",
    "number": 472,
    "title": "【Q464】什么是重排重绘，如何减少重拍重绘",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc2MDY2MDE4Nw==",
          "body": "重排和重绘是关键渲染路径中的两步，可以参考另一个问题: [什么是关键渲染路径](https://q.shanyue.tech/fe/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/391.html)\r\n\r\n+ 重排(Reflow)：元素的位置发生变动时发生重排，也叫回流。此时在关键渲染路径中的 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高\r\n    ![](https://q.shanyue.tech/assets/layout.png)\r\n\r\n+ 重绘(Repaint): 元素的样式发生变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化\r\n    ![](https://q.shanyue.tech/assets/paint.png)\r\n\r\n另外，重排必定会造成重绘。以下是避免过多重拍重绘的方法\r\n\r\n1. 使用 `DocumentFragment` 进行 DOM 操作，不过现在原生操作很少也基本上用不到\r\n2. CSS 样式尽量批量修改\r\n3. 避免使用 table 布局\r\n4. 为元素提前设置好高宽，不因多次渲染改变位置\r\n\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Gkk_e",
          "body": "问题描述\r\n重拍 -> 重排",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ZhengZhouXu",
            "url": "https://github.com/ZhengZhouXu"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3OTM4MjA1Njk=",
    "number": 473,
    "title": "【Q465】css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc2OTczMzExOQ==",
          "body": "页面布局元素如下，item 数量不固定\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n</div>\r\n```\r\n\r\n使用 Grid 布局可以轻松解决这个问题，如若使用其它方案，控制好等分的同时再控制好间距也是一个十分头疼的问题:\r\n\r\n1. `grid-template-columns`: 控制等分\r\n2. `gap`: 控制间隙\r\n\r\n效果可见 [codepen](https://codepen.io/shanyue/pen/rNyLvBe)\r\n\r\n``` css\r\n@media (min-width: 768px) {\r\n  .container {\r\n    grid-template-columns: repeat(2, minmax(0,1fr));\r\n  }\r\n}\r\n\r\n@media (min-width: 1024px) {\r\n  .container {\r\n    grid-template-columns: repeat(3, minmax(0, 1fr));\r\n  }\r\n}\r\n\r\n.container {\r\n  display: grid;\r\n}\r\n\r\n.conainer {\r\n  gap: 1rem;\r\n}\r\n```\r\n\r\n`TailwindCSS` 是一款非常方便的 CSS 原子类框架，只需要一行即可搞定\r\n\r\n``` html\r\n<div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\"></div>\r\n```\r\n\r\n但是这就够了吗？\r\n\r\n这远远不够，这也足够复杂！\r\n\r\n1. 需要媒体查询\r\n2. 需要人为设置 breakpoint，设置大小屏幕的边界\r\n\r\n## 终极解决方案\r\n\r\n`Grid` 布局可以自动判断容器大小，无论大小屏幕自动撑满并均分，请看以下属性\r\n\r\n``` css\r\n.container {\r\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr))\r\n}\r\n```\r\n\r\n1. `repeat`: 用以 N 整分\r\n1. `auto-fill`：表示自动填充\r\n2. `minmx`: 即书面意思，最小宽度为 `300px`\r\n\r\n[使用终极解决方案的在线页面](https://devtool.tech/fe-logo)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MzIxMzk0MQ==",
          "body": "终极解决方案 正好在用。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiutian00",
            "url": "https://github.com/qiutian00"
          }
        },
        {
          "id": "IC_kwDODQzyOs46c2J2",
          "body": "> 页面布局元素如下，item 数量不固定\r\n> \r\n> ```\r\n> <div class=\"container\">\r\n>   <div class=\"item\"></div>\r\n>   <div class=\"item\"></div>\r\n>   <div class=\"item\"></div>\r\n>   <div class=\"item\"></div>\r\n>   <div class=\"item\"></div>\r\n>   <div class=\"item\"></div>\r\n> </div>\r\n> ```\r\n> \r\n> 使用 Grid 布局可以轻松解决这个问题，如若使用其它方案，控制好等分的同时再控制好间距也是一个十分头疼的问题:\r\n> \r\n> 1. `grid-template-columns`: 控制等分\r\n> 2. `gap`: 控制间隙\r\n> \r\n> 效果可见 [codepen](https://codepen.io/shanyue/pen/rNyLvBe)\r\n> \r\n> ```css\r\n> @media (min-width: 768px) {\r\n>   .container {\r\n>     grid-template-columns: repeat(2, minmax(0,1fr));\r\n>   }\r\n> }\r\n> \r\n> @media (min-width: 1024px) {\r\n>   .container {\r\n>     grid-template-columns: repeat(3, minmax(0, 1fr));\r\n>   }\r\n> }\r\n> \r\n> .container {\r\n>   display: grid;\r\n> }\r\n> \r\n> .conainer {\r\n>   gap: 1rem;\r\n> }\r\n> ```\r\n> \r\n> `TailwindCSS` 是一款非常方便的 CSS 原子类框架，只需要一行即可搞定\r\n> \r\n> ```\r\n> <div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\"></div>\r\n> ```\r\n> \r\n> 但是这就够了吗？\r\n> \r\n> 这远远不够，这也足够复杂！\r\n> \r\n> 1. 需要媒体查询\r\n> 2. 需要人为设置 breakpoint，设置大小屏幕的边界\r\n> \r\n> ## 终极解决方案\r\n> `Grid` 布局可以自动判断容器大小，无论大小屏幕自动撑满并均分，请看以下属性\r\n> \r\n> ```css\r\n> .container {\r\n>   grid-template-columns: repeat(auto-fill, minmax(300px, 1fr))\r\n> }\r\n> ```\r\n> \r\n> 1. `repeat`: 用以 N 整分\r\n> 2. `auto-fill`：表示自动填充\r\n> 3. `minmx`: 即书面意思，最小宽度为 `300px`\r\n> \r\n> [使用终极解决方案的在线页面](https://devtool.tech/fe-logo)\r\n\r\n链接跳过去是图标大全",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nmsn",
            "url": "https://github.com/nmsn"
          }
        },
        {
          "id": "IC_kwDODQzyOs46eVs1",
          "body": "@nmsn 这是效果，查看源码即可",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3OTc3MDYxOTQ=",
    "number": 474,
    "title": "【Q466】在 SSR 项目中如何判断当前环境时服务器端还是浏览器端",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1Mjg0MzgwNw==",
          "body": "1. SSR渲染的时候，服务端与客户端走不同的webpack打包配置。\r\n那么就可以在打包的时候写入区分环境的环境变量。\r\n2. 服务器端是没有window document 等浏览器宿主环境对象的，可以通过 类型检测 这些对象 来区分。\r\n``` typeof window === undefined ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "listenecho",
            "url": "https://github.com/listenecho"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzUxMzgzMA==",
          "body": "``` js\r\nconst isServer = typeof window === 'undefined'\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzUxNDA4Mw==",
          "body": "> 1. SSR渲染的时候，服务端与客户端走不同的webpack打包配置。\r\n>    那么就可以在打包的时候写入区分环境的环境变量。\r\n> 2. 服务器端是没有window document 等浏览器宿主环境对象的，可以通过 类型检测 这些对象 来区分。\r\n\r\n一般就是通过第二条来区分了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3OTc4OTM2NjY=",
    "number": 475,
    "title": "【Q467】前端打包时 cjs、es、umd 模块有何不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MTQwNDU5MA==",
          "body": "## cjs (commonjs)\r\n\r\n`commonjs` 是 Node 中的模块规范，通过 `require` 及 `exports` 进行导入导出 (进一步延伸的话，`module.exports` 属于 `commonjs2`)\r\n\r\n同时，webpack 也对 `cjs` 模块得以解析，因此 `cjs` 模块可以运行在 node 环境及 webpack 环境下的，但不能在浏览器中*直接*使用。但如果你写前端项目在 webpack 中，也可以理解为它在浏览器和 Node 都支持。\r\n\r\n比如，著名的全球下载量前十10的模块 [ms](https://npm.devtool.tech/ms) 只支持 `commonjs`，但并不影响它在前端项目中使用(通过webpack)，但是你想通过 cdn 的方式直接在浏览器中引入，估计就会出问题了\r\n\r\n``` js\r\n// sum.js\r\nexports.sum = (x, y) => x + y\r\n\r\n// index.js\r\nconst { sum } = require('./sum.js')\r\n```\r\n\r\n由于 `cjs` 为动态加载，可直接 `require` 一个变量\r\n\r\n``` js\r\nrequire(`./${a}`)\r\n```\r\n\r\n## esm (es module)\r\n\r\n`esm` 是 tc39 对于 ESMAScript 的模块话规范，正因是语言层规范，**因此在 Node 及 浏览器中均会支持**。\r\n\r\n它使用 `import/export` 进行模块导入导出.\r\n\r\n``` js\r\n// sum.js\r\nexport const sum = (x, y) => x + y\r\n\r\n// index.js\r\nimport { sum } from './sum'\r\n```\r\n\r\n`esm` 为静态导入，正因如此，可在编译期进行 **Tree Shaking**，减少 js 体积。\r\n\r\n如果需要动态导入，tc39 为动态加载模块定义了 API: `import(module)` 。可将以下代码粘贴到控制台执行\r\n\r\n``` js\r\nconst ms = await import('https://cdn.skypack.dev/ms@latest')\r\n\r\nms.default(1000)\r\n```\r\n\r\nesm 是未来的趋势，目前一些 CDN 厂商，前端构建工具均致力于 cjs 模块向 esm 的转化，比如 `skypack`、 `snowpack`、`vite` 等。\r\n\r\n目前，在浏览器与 node.js 中均原生支持 esm。\r\n\r\n+ cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用\r\n+ cjs 模块是运行时加载，esm 是编译时加载\r\n\r\n示例: [array-uniq](https://cdn.jsdelivr.net/npm/array-uniq/index.js)\r\n\r\n## umd\r\n\r\n一种兼容 `cjs` 与 `amd` 的模块，既可以在 node/webpack 环境中被 `require` 引用，也可以在浏览器中直接用 CDN 被 `script.src` 引入。\r\n\r\n``` js\r\n(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD\r\n    define(['jquery'], factory);\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = factory(require('jquery'));\r\n  } else {\r\n    // 全局变量\r\n    root.returnExports = factory(root.jQuery);\r\n  }\r\n}(this, function ($) {\r\n  // ...\r\n}));\r\n```\r\n\r\n示例: [react-table](https://cdn.jsdelivr.net/npm/react-table/), [antd](https://cdn.jsdelivr.net/npm/antd/)\r\n\r\n这三种模块方案大致如此，部分 npm package 也会同时打包出 commonjs/esm/umd 三种模块化格式，供不同需求的业务使用，比如 [antd](https://cdn.jsdelivr.net/npm/antd/)。\r\n\r\n+ [antd 的 cjs](https://cdn.jsdelivr.net/npm/antd@4.17.2/lib/index.js)\r\n+ [antd 的 umd](https://cdn.jsdelivr.net/npm/antd@4.17.2/dist/antd.js)\r\n+ [antd 的 esm](https://cdn.jsdelivr.net/npm/antd@4.17.2/es/index.js)\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs46348f",
          "body": "webpack 打包使用的是 cjs， vite使用的是esm，这样理解对吗\r\nrollup使用的是啥模块化方案？\r\n\r\nwebpack也有tree-shaking吗和rollup的有啥不同",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1gehunzi",
            "url": "https://github.com/1gehunzi"
          }
        },
        {
          "id": "IC_kwDODQzyOs4635Bn",
          "body": "已收到你的邮件，谢谢~~~",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "songcee",
            "url": "https://github.com/songcee"
          }
        },
        {
          "id": "IC_kwDODQzyOs5oxqXd",
          "body": "webpack是运行在node环境中的程序，也就是说webpack环境其实就是node环境，感觉没区别呢。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "misakisaysyes",
            "url": "https://github.com/misakisaysyes"
          }
        },
        {
          "id": "IC_kwDODQzyOs5oxqiq",
          "body": "已收到你的邮件，谢谢~~~",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "songcee",
            "url": "https://github.com/songcee"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3OTg5MTA1NjY=",
    "number": 476,
    "title": "【Q468】前端开发中如何进行多主题配置",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3OTg5MTg5MTg=",
    "number": 477,
    "title": "【Q469】HTML 中的 input 标签有哪些 type",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MDQ0Mzk5Mg==",
          "body": "## button\r\n没有默认行为的按钮，上面显示 value 属性的值，默认为空。\r\n\r\n``` html\r\n<input  type=\"button\" name=\"button\" />\r\n```\r\n\r\n## checkbox\r\n复选框，可设为选中或未选中。\r\n\r\n``` html\r\n<input  type=\"checkbox\" name=\"checkbox\"/>\r\n```\r\n\r\n## color\r\n用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。\r\n\r\n``` html\r\n<input  type=\"color\" name=\"color\"/>\r\n```\r\n\r\n## date\r\n输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。\r\n\r\n``` html\r\n<input  type=\"date\" name=\"date\"/>\r\n```\r\n\r\n## datetime-local\r\n输入日期和时间的控件，不包括时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。\r\n\r\n``` html\r\n<input  type=\"datetime-local\" name=\"datetime-local\"/>\r\n```\r\n\r\n## email\r\n编辑邮箱地址的区域。类似 text 输入，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘。\r\n\r\n``` html\r\n<input type=\"email\" name=\"email\"/>\r\n```\r\n\r\n## file\r\n让用户选择文件的控件。使用accept属性规定控件能选择的文件类型。\r\n\r\n``` html\r\n<input type=\"file\" accept=\"image/*, text/*\" name=\"file\"/>\r\n```\r\n\r\n## hidden\r\n不显示的控件，其值仍会提交到服务器。举个例子，右边就是一个隐形的控件。\r\n\r\n``` html\r\n\r\n```\r\n\r\n## image\r\n带图像的 submit 按钮。显示的图像由 src 属性规定。如果 src 缺失，alt 属性就会显示。\r\n\r\n``` html\r\n<input type=\"image\" name=\"image\" src=\"\" alt=\"image input\"/>\r\n```\r\n\r\n## month\r\n输入年和月的控件，没有时区。\r\n\r\n``` html\r\n<input type=\"month\" name=\"month\"/>\r\n```\r\n\r\n## number\r\n用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘。\r\n\r\n``` html\r\n<input  type=\"number\" name=\"number\"/>\r\n```\r\n\r\n## password\r\n单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户。\r\n\r\n``` html\r\n<input  type=\"password\" name=\"password\"/>\r\n```\r\n\r\n## radio\r\n单选按钮，允许在多个拥有相同 name 值的选项中选中其中一个。\r\n\r\n``` html\r\n<input type=\"radio\" name=\"radio\"/>\r\n```\r\n\r\n## range\r\n此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用htmlattrdefmin   和 htmlattrdefmax来规定值的范围。\r\n\r\n``` html\r\n<input type=\"range\" name=\"range\" min=\"0\" max=\"25\"/>\r\n```\r\n\r\n## reset\r\n此按钮将表单的所有内容重置为默认值。不推荐。\r\n\r\n``` html\r\n<input  type=\"reset\" name=\"reset\"/>\r\n```\r\n\r\n## search\r\n用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。\r\n\r\n``` html\r\n<input  type=\"search\" name=\"search\"/>\r\n```\r\n\r\n## submit\r\n用于提交表单的按钮。\r\n\r\n``` html\r\n<input type=\"submit\" name=\"submit\"/>\r\n```\r\n\r\n## tel\r\n用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。\r\n\r\n``` html\r\n<input  type=\"tel\" name=\"tel\"/>\r\n```\r\n\r\n## text\r\n默认值。单行的文本区域，输入中的换行会被自动去除。\r\n\r\n``` html\r\n<input type=\"text\" name=\"text\"/>\r\n```\r\n\r\n## time\r\n用于输入时间的控件，不包括时区。\r\n\r\n``` html\r\n<input  type=\"time\" name=\"time\"/>\r\n```\r\n\r\n## url\r\n用于输入 URL 的控件。类似 text 输入，但有验证参数，在支持动态键盘的设备上有相应的键盘。\r\n\r\n``` html\r\n<input type=\"url\" name=\"url\"/>\r\n```\r\n\r\n## week\r\n用于输入以年和周数组成的日期，不带时区。\r\n\r\n``` html\r\n<input type=\"week\" name=\"week\"/>\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU3OTkyNzA4NjQ=",
    "number": 478,
    "title": "【Q470】什么是 Data URL",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3MjQ5ODI0MA==",
          "body": "Data URL是将图片转换为base64直接嵌入到了网页中，使用`<img src=\"data:[MIME type];base64\"/>`这种方式引用图片，不需要再发请求获取图片。\r\n使用Data URL也有一些缺点：\r\n- base64编码后的图片会比原来的体积大三分之一左右。\r\n- Data URL形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将Data URL写入到CSS文件中随着CSS被缓存下来。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "IC_kwDODQzyOs401ksH",
          "body": "[Data URLs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5A9Kph",
          "body": "Data URL是前缀为`data:`协议的URL；\r\n它允许内容创建者向文档中嵌入小文件，比如图片等。\r\nData URL由四部分组成：\r\n- 前缀`data:`\r\n- 指示数据类型的MIME类型。例如`image/jpeg`表示JPEG图像文件；如果此部分被省略，则默认值为`text/plain;charset=US-SACII`\r\n- 如果为非文本数据，则可选base64做标记\r\n- 数据\r\n```text\r\ndata:[mediatype][;base63], data\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hsq777",
            "url": "https://github.com/hsq777"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDI4NDg2OTA=",
    "number": 479,
    "title": "【Q471】如何自定义滚动条的样式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3NDU4ODQwMA==",
          "body": "滚动条相关样式都是伪元素，以 `scrollbar` 打头，有以下伪元素，从 `-webkit` 中可见兼容性一般，不过无所谓，现在 Chrome 浏览器占大头\r\n\r\n+   `::-webkit-scrollbar` — 整个滚动条.\r\n+   `::-webkit-scrollbar-button` — 滚动条上的按钮 (上下箭头).\r\n+   `::-webkit-scrollbar-thumb` — 滚动条上的滚动滑块.\r\n+   `::-webkit-scrollbar-track` — 滚动条轨道.\r\n+   `::-webkit-scrollbar-track-piece` — 滚动条没有滑块的轨道部分.\r\n+   `::-webkit-scrollbar-corner` — 当同时有垂直滚动条和水平滚动条时交汇的部分.\r\n+   `::-webkit-resizer` — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).\r\n\r\n但其实最常用的是以下几个伪元素：**滚动条、滑块、轨道**，如下滚动条设置成功\r\n\r\n``` css\r\n::-webkit-scrollbar {\r\n    width: 6px;\r\n    height: 6px\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    border-radius: 3px;\r\n    background: rgba(0,0,0);\r\n    box-shadow: inset 0 0 5px rgba(0,0,0,.08)\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    border-radius: 3px;\r\n    background: rgba(0,0,1);\r\n    box-shadow: inset 0 0 10px rgba(0,0,0,.2)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lQYqc",
          "body": "书接山月上文，我们给出示例demo\r\n[自定义滚动条](https://stackblitz.com/edit/web-platform-dx7thc?file=index.html)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Neisun",
            "url": "https://github.com/Neisun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDMyMjI5OTY=",
    "number": 480,
    "title": "【Q472】什么是 HTML 的实体编码 (HTML Entity Encode)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4Mjg2MzY4MA==",
          "body": "- 不可分的空格:＆nbsp;\r\n- <(小于符号):＆lt;\r\n- (大于符号):＆gt;\r\n- ＆(与符号):＆amp;\r\n- ″(双引号):＆quot;\r\n- '(单引号):'＆apos;\r\n- ……",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kglive",
            "url": "https://github.com/kglive"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4ODU2NzY2NQ==",
          "body": "HTML 实体是一段以连字号（&）开头、以分号（;）结尾的字符串。用以显示不可见字符及保留字符 (如 HTML 标签)\r\n\r\n在前端，一般为了避免 XSS 攻击，会将 `<>` 编码为 `&lt;` 与 `&gt;`，这些就是 HTML 实体编码。\r\n\r\n在 [whatwg](https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references) 中可查看实体编码数据。\r\n\r\n在 HTML 转义时，仅仅只需要对六个字符进行编码: `&`, `<`, `>`, `\"`, `'`,  `\\``。可使用 [he](https://npm.devtool.tech/he) 这个库进行编码及转义\r\n\r\n``` js\r\n// 实体编码\r\n> he.encode('<img src=\"\"></img>')\r\n< \"&#x3C;img src=&#x22;&#x22;&#x3E;&#x3C;/img&#x3E;\"\r\n\r\n// 转义\r\n> he.escape('<img src=\"\"></img>')\r\n< \"&lt;img src=&quot;&quot;&gt;&lt;/img&gt;\"\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDM0OTcyMzE=",
    "number": 481,
    "title": "【Q473】关于模块化，什么是 amd 和 umd",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3NTY3OTUxOA==",
          "body": "`amd` 是一种浏览器中的模块格式，关键字为 `define`，`cjs` 是一种 Node 中的模块格式，也是广为人所熟悉的 `require/exports`。\r\n\r\n而 `umd` 是 `amd` 与 `cjs` 两种格式的兼容。既可以跑在浏览器，又可以跑在 Node 中\r\n\r\n**amd**\r\n\r\n``` js\r\ndefine(['jquery', 'underscore'], function ($, _) {});\r\n```\r\n\r\n**umd**\r\n\r\n``` js\r\n(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD\r\n    define(['jquery'], factory);\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = factory(require('jquery'));\r\n  } else {\r\n    // 全局变量\r\n    root.returnExports = factory(root.jQuery);\r\n  }\r\n}(this, function ($) {\r\n  // ...\r\n}));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDM2NTk2MjU=",
    "number": 482,
    "title": "【Q474】简单介绍以下浏览器中的 module",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs401jHW",
          "body": "`<script type=\"module\">`\r\n\r\n- 模块自动使用严格模式\r\n- 需要使用 defer 属性，模块会自动延迟加载",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDQxODQ3NTE=",
    "number": 483,
    "title": "【Q475】什么是 commonjs2 ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5Vki1v",
          "body": "commonjs 规范只定义了exports，而 module.exports是nodejs对commonjs的实现，实现往往会在满足规范前提下作些扩展，我们这里把这种实现称为了commonjs2.",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDcxNjEwNjM=",
    "number": 484,
    "title": "【Q476】textarea 如何禁止拉伸",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc3ODE0MTY5MQ==",
          "body": "使用 CSS 样式可以避免拉伸\r\n\r\n``` css\r\ntextarea {\r\n  resize: none;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MDc3NTkyMzc=",
    "number": 485,
    "title": "【Q477】在 Canvas 中如何处理跨域的图片",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwOTg3OTQ1OQ==",
          "body": "img.setAttribute(\"crossOrigin\", \"anonymous\");",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hhhpw",
            "url": "https://github.com/hhhpw"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MTE2MDMyNTA=",
    "number": 486,
    "title": "【Q478】如何实现容器中子元素三个三列布局，子元素两个则两列布局",
    "body": "及容器中有三个及以上元素，则三列布局\r\n容器只有两个元素，两列布局平分\r\n容器只有一个元素，一列布局全占",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46qkj-",
          "body": "[代码演示](https://codepen.io/9527yl/pen/dyVyQJV)\r\n\r\ncss布局阔以使用`flex`，`grid`.\r\n\r\n关健在于如何判断有多少元素。我们只需要判断有1个，有2个的情况，其他都是三列布局\r\n\r\n```css\r\n\r\n/* 有1个元素 */\r\n.item:nth-last-child(1):first-child {\r\n  flex: 1;\r\n}\r\n\r\n.item:nth-last-child(1):first-child ~ .item {\r\n  flex: 1;\r\n}\r\n\r\n/* 有2个元素 */\r\n.item:nth-last-child(2):first-child {\r\n  flex: 1;\r\n}\r\n\r\n.item:nth-last-child(2):first-child ~ .item {\r\n  flex: 1;\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "9527YL",
            "url": "https://github.com/9527YL"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BkGyB",
          "body": "反过来，前3个设置`flex:1`，超过3个就重置为`none`\r\n```css\r\n/*前3个flex：1*/\r\n.item:nth-child(-n+3) {\r\n    flex: 1;\r\n}\r\n\r\n/*超过3个则none*/\r\n.item:nth-last-child(4), .item:nth-last-child(4) ~ .item {\r\n    flex: none;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Telanx",
            "url": "https://github.com/Telanx"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lQdOx",
          "body": "grid和flex都可以实现，下边给出实现demo\r\n[根据子元素个数动态多列](https://stackblitz.com/edit/web-platform-zgwv8y?file=index.html,styles.css)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Neisun",
            "url": "https://github.com/Neisun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MTQwMzgwMzA=",
    "number": 487,
    "title": "【Q479】前端上传文件时如何读取文件内容",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4MzgzMTgyNw==",
          "body": "``` html\r\n<input type=\"file\" id=\"input\" onchange=\"handleFiles(this.files)\">\r\n```\r\n\r\n在浏览器中，通过 `input[type=file]` 来点击上传文件，此时监听 `onChange` 事件，可以获取到 `File` 对象，其中从中可以读取文件内容\r\n\r\n而读取文件内容，需要转化 `File/Blob` 到 `Text`，一般使用以下两种方案\r\n\r\n## FileReader API\r\n\r\n这是最常用处理上传文件的 API，但是却繁琐冗余难记，每次使用基本上都要查文档！\r\n\r\n`FileReader API` 用以读取 File/Blob 内容，正因为繁琐难记，以下实现一个 `readBlob` 函数读取内容。\r\n\r\n``` js\r\nfunction readBlob (blob) {\r\n  return new Promise(resolve => {\r\n    const reader = new FileReader()\r\n    reader.onload = function (e) {\r\n      resolve(e.target.result)  \r\n    }\r\n    reader.readAsText(blob)\r\n  })\r\n}\r\n```\r\n\r\n## Response API\r\n\r\n而是用 `Response API` 只需要一行内容\r\n\r\n``` js\r\nconst readBlob = (blob) => new Response(blob).text()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MTUyMTkyODk=",
    "number": 488,
    "title": "【Q480】你最喜欢的三个 js 库是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDkxNDY0Ng==",
          "body": "\r\n这三个库是我喜欢也用的相当多的库，如果是自己的项目基本上都用了:\r\n\r\n1. [next](https://npm.devtool.tech/next)\r\n2. [swr](https://npm.devtool.tech/swr)\r\n3. [graphql](https://npm.devtool.tech/graphql)\r\n\r\n此外，[npm.devtool](https://npm.devtool.tech/) 中收集了最流行的 1000 个库，可以去瞧瞧\r\n\r\n## next\r\n\r\nVercel 出品\r\n\r\n> The React Framework for Production.\r\n\r\n好用！一点基于它的 SSR，一点基于它的开箱即用。\r\n\r\n1. SSR，如果你想提高你的前端水平，那就使用 Next 做一个同构的项目吧，其中遇到的问题比纯客户端渲染更有挑战力，更加棘手。严格来说这是一个需要部署在服务器上的服务器项目，你需要对服务器端开始了解，可能遇到内存爆掉，需要记录服务器日志，需要 Metric 监控内存、CPU 等，需要报警等。而这些在平常的前端项目接触不到。同构要求一份代码既能在 Node 环境中运行，又能在浏览器中运行，其中也会遇到一些问题，比如一个库客户端可以加载服务端不行，或者相反。或者一个疏忽让客户端打包了一个特别大的包(其实仅仅服务端需要)，造成页面加载过慢。\r\n1. 开箱即用，内置路由、ts支持、webpack 配置等等。即使你想扩展你的 webpack 配置，仅仅需要在 `next.config.js` 添加几行代码。而不像 `create-react-app` 基本上都要 `eject`，从而需要管理许多配置\r\n\r\n## swr\r\n\r\n``` js\r\nconst { data: projects, error } = useSWR('/api/projects')\r\n```\r\n\r\n或者一个可选的库: `React-Query`。\r\n\r\n同样也是 Vercel 出品\r\n\r\n最大的好处就是通过 `hooks` 形式加载数据，简单方便。与 `React-Query` 相比，个人感觉:\r\n\r\n1. `react-query` 对于 `mutation` 可使用 hooks，支持更多选项 (如 keepPreviousData)，功能更多，更适合 API 复杂的项目\r\n1. `swr` 相对轻量，可随处使用，不像 react-query 需要在父组件设置 Provider 等，只有读请求的小项目可以用 swr\r\n\r\n## graphql\r\n\r\nGraphQL，按需请求数据。可以简单对接数据库、第三方服务，并扔到客户端，由于面向字段(field)，所以更容易针对字段进行缓存。\r\n\r\n同时也更有利于客户端，`graphql` 的强类型很容易通过 AST 转化为 types，因此客户端请求数据时的 ts 可以根据 query 自动生成。\r\n\r\n现在，Github 最新的 API 也是 graphql 形式的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs442Hhg",
          "body": "lodash  封装了很多有用的库\r\naxios  体积小，比原生好用太多\r\nreact-query 通过hooks封装，把请求还做了缓存",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MjAxMjgwODg=",
    "number": 489,
    "title": "【Q481】网站设置字体时，如何设置优先使用系统默认字体",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5MjY4NzQwMg==",
          "body": "``` css\r\nfont-family: system-ui;\r\n```\r\n\r\n`system-ui` 将会自动选取系统默认字体作为字体，如 [`bootstrap` 的样式规则](https://github.com/twbs/bootstrap/blob/main/scss/_variables.scss#L419)\r\n\r\n``` scss\r\n$font-family-sans-serif: system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", \"Liberation Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\" !default;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MjIxOTkzNjU=",
    "number": 490,
    "title": "【Q482】现代化前端框架中如何进行调试",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MjQyNTE2MTk=",
    "number": 491,
    "title": "【Q483】如何使用 redis 计算 wordcount，并计算出现频率最高的词",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MjUyMjQ2NjE=",
    "number": 492,
    "title": "【Q484】express 中间件的原理是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MjU2ODY0OTE=",
    "number": 493,
    "title": "【Q485】写 CSS 时如何避免命名样式冲突",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDc5Mzg4MTM3MA==",
          "body": "\r\n## 1. BEM 式: `.home-page .home-page-btn`\r\n\r\n``` css\r\n.home-page {\r\n  .home-page-btn {}\r\n}\r\n```\r\n\r\nBEM 有一个缺点，就是有些太长，可适当简化，只包裹该页面组件的根类名，但有可能增加样式冲突的风险\r\n\r\n``` css\r\n.home-page {\r\n  .btn {}\r\n}\r\n```\r\n\r\n## 2. CSS Scoped\r\n\r\n`scoped css` 会对当前组件(scope)下所有元素生成唯一的属性或类名，对所有 CSS 规则将携带唯一属性实现作用域的命名保护\r\n\r\n``` css\r\n// 手动写\r\n.btn {}\r\n\r\n// 编译后\r\n.btn .jsx-1287234 {}\r\n\r\n```\r\n\r\n![css scoped demo](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c0676b0f8cc4f40b925dcb983778dd8~tplv-k3u1fbpfcp-watermark.image)\r\n\r\n## 3. CSS Module\r\n\r\n+ [css-modules repo](https://github.com/css-modules/css-modules)\r\n+ [css-modules demo](https://css-modules.github.io/webpack-demo/)\r\n\r\n`module css` 会对类名进行 hash 化\r\n\r\n![css modules demo](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/072649f56f8f4f80afa226879b94a6bf~tplv-k3u1fbpfcp-watermark.image)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MjkxMzkyODc=",
    "number": 495,
    "title": "【Q486】什么是前端工程化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs401huM",
          "body": "前端工程化的主要目标就是解放生产力、提高生产效率。通过制定一系列的规范，借助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题。\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5bcW7n",
          "body": "来自 ChatGPT：\r\n\r\n前端工程化是指通过使用工具和技术来优化前端开发流程，提高开发效率和代码质量，以及降低项目维护成本的一种开发方式。它包括但不限于以下几个方面：\r\n1. 自动化构建：使用构建工具和任务管理器（如webpack、Gulp、Grunt等）对前端资源进行打包、编译、压缩、合并、优化等操作，以提高前端项目的性能和可维护性。\r\n2. 模块化开发：通过使用模块化规范（如CommonJS、AMD、ES6）将程序分解成独立的功能模块，使代码更易于维护和测试。\r\n3. 组件化开发：将UI组件抽象成独立的模块，以便于在不同的项目中复用，从而提高生产效率。\r\n4. 自动化测试：通过使用单元测试、端对端测试、性能测试等多种测试手段来确保代码的质量和稳定性。\r\n5. 代码规范和静态检查：通过使用代码规范和静态检查工具（如ESLint、JSLint、JSHint、Prettier等）来保证代码的规范和质量，减少出错概率，提高团队协作的效率和代码的可维护性。\r\n\r\n6. 版本控制和协作：使用版本控制工具（如Git、SVN等）来管理代码，协同开发和维护项目。\r\n\r\n通过前端工程化的实践，可以提高前端开发的效率和质量，减少错误和重复工作，提高可维护性和可扩展性，从而实现快速迭代和持续交付的目标。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MzcxMDI1NjE=",
    "number": 496,
    "title": "【Q487】OAuth 2.0 的原理是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4MzcxMDI3MDc=",
    "number": 497,
    "title": "【Q488】JWT 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5MZ2wl",
          "body": "https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lpdswing",
            "url": "https://github.com/lpdswing"
          }
        },
        {
          "id": "IC_kwDODQzyOs5NlJgG",
          "body": "json web token，由header payload signature组成，使用base64加密\r\n\r\n用户登录，将信息在服务器上验证，验证成功服务器根据密钥加密生成jwt，发送请求时携带token，对token进行解密，验证成功返回数据。在服务器存放相同密钥可以实现单点登录",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4Mzc4MzI3NDc=",
    "number": 498,
    "title": "【Q489】如何实现一个函数 lodash.merge",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNDE1MTc0Ng==",
          "body": "`Array.prototype.flatMap` 已经是 EcmaScript 的标准，看一个例子，它的输出是多少？\r\n\r\n``` js\r\n[1, 2, [3], 4].flatMap(x => x + 1)\r\n//=> [2, 3, '31', 5]\r\n```\r\n\r\n很可惜，不是 `[2, 3, 4, 5]`，原因在于 `flatMap` 实际上是先 `map` 再 `flat`，实现如下\r\n\r\n``` js\r\nArray.prototype.flatMap = function (mapper) {\r\n  return this.map(mapper).flat()\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44K-NQ",
          "body": "```javascript\r\nconst getRawType = (val) => {\r\n  return Object.prototype.toString.call(val).slice(8,-1)\r\n}\r\nconst isPlainObject = (val) => {\r\n  return getRawType(val) === 'Object'\r\n}\r\n\r\nconst isPlainObjectOrArray = (val) => {\r\n  return isPlainObject(val) || Array.isArray(val)\r\n}\r\n\r\nconst merge = (object, ...sources) => {\r\n  for (const source of sources) {\r\n    for (const key in source) {\r\n      if (source[key] === undefined && key in object) {\r\n        continue\r\n      }\r\n      if (isPlainObjectOrArray(source[key])) {\r\n        if (isPlainObjectOrArray(object[key]) && getRawType(object[key]) === getRawType(source[key])) {\r\n          if (isPlainObject(object[key])) {\r\n            merge(object[key], source[key])\r\n          } else {\r\n            object[key] = object[key].concat(source[key])\r\n          }\r\n        } else {\r\n          object[key] = source[key]\r\n        }\r\n      } else {\r\n        object[key] = source[key]\r\n      }\r\n    }\r\n  }  \r\n}\r\n\r\n// merge array\r\nvar object = {\r\n  'a': [{ 'b': 2 }, { 'd': 4 }]\r\n};\r\nmerge(object, {'a': [{ 'c': 3 }, { 'e': 5 }]});\r\nconsole.log(object)\r\n\r\n// merge object\r\nvar object = {\r\n  'a': { 'b': { 'c': 1 } },\r\n};\r\nmerge(object, { 'a': { 'b': { 'd': 2 } } });\r\nconsole.log(object)\r\n\r\n// overwrite primitive value\r\nobject = {\r\n  'a': {'b': 1}\r\n};\r\nmerge(object, { 'a': {'b': 2} })\r\nconsole.log(object)\r\n\r\n// skip undefined\r\nobject = {\r\n  'a': {'b': 1}\r\n};\r\nmerge(object, { 'a': { 'b': undefined } })\r\nconsole.log(object)\r\n\r\n// multiple sources\r\nvar object = {\r\n  'a': { 'b': { 'c': 1 , 'd': [1] } },\r\n};\r\nmerge(object, { 'a': { 'b': { 'e': 2 } } }, { 'a': { 'b': { 'd': [2] } } });\r\nconsole.log(JSON.stringify(object))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NDA0MTc1MjI=",
    "number": 499,
    "title": "【Q490】如何实现一个 promise.any",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44MZer",
          "body": "Promise.any 的行为跟 Promise.all 刚好相反\r\n```javascript\r\nPromise.any = (promiseArray) => {\r\n  return new Promise((resolve, reject) => {\r\n    const _promiseArray = Array.from(promiseArray)\r\n    const length = _promiseArray.length\r\n    const rejectedArray = []\r\n    _promiseArray.forEach(item => {\r\n      Promise.resolve(item).then(val => {\r\n        resolve(val)\r\n      }, reason => {\r\n        rejectedArray.push(reason)\r\n        if (rejectedArray.length === length) {\r\n          reject(new AggregateError(rejectedArray))\r\n        }\r\n      })\r\n    })\r\n  })\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs5o1ZI9",
          "body": "> Promise.any 的行为跟 Promise.all 刚好相反\r\n> \r\n> ```js\r\n> Promise.any = (promiseArray) => {\r\n>   return new Promise((resolve, reject) => {\r\n>     const _promiseArray = Array.from(promiseArray)\r\n>     const length = _promiseArray.length\r\n>     const rejectedArray = []\r\n>     _promiseArray.forEach(item => {\r\n>       Promise.resolve(item).then(val => {\r\n>         resolve(val)\r\n>       }, reason => {\r\n>         rejectedArray.push(reason)\r\n>         if (rejectedArray.length === length) {\r\n>           reject(new AggregateError(rejectedArray))\r\n>         }\r\n>       })\r\n>     })\r\n>   })\r\n> }\r\n> ```\r\n\r\n错误的顺序应该按照promise的顺序返回",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cloudGrin",
            "url": "https://github.com/cloudGrin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NDE0OTkzODA=",
    "number": 500,
    "title": "【Q491】如何实现一个 Promise.all",
    "body": "``` js\r\nawait Promise.all([1, 2, 3])\r\n//-> [1, 2, 3]\r\n\r\nawait Promise.all([1, Promise.resolve(2), 3])\r\n//-> [1, 2, 3]\r\n\r\nawait Promise.all([1, Promise.resolve(2)])\r\n//-> [1, 2]\r\n\r\nawait Promise.all([1, Promise.reject(2)])\r\n//-> Throw Error: 2\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgwNzkwMjE4Ng==",
          "body": "> 代码可在线调试: [如何实现一个 Promise.all - codepen](https://codepen.io/shanyue/pen/JjWEqBL?editors=0012)\r\n\r\n有一次头条面试，一道手写题目是：如何手写实现 `promise.all`。\r\n\r\n我从来没有想过要手写实现 promise.all 函数，稍微一想，大概就是维护一个数组，把所有 promise 给 resolve 了之后都扔进去，这有啥子好问的。没想到，一上手还稍微有点棘手。\r\n\r\n先来看一个示例吧:\r\n\r\n``` js\r\nawait Promise.all([1, Promise.resolve(2)])\r\n//-> [1, 2]\r\n\r\nawait Promise.all([1, Promise.reject(2)])\r\n//-> Throw Error: 2\r\n```\r\n\r\n1. 传入一个 Iterable，但大部分情况下是数组，以下以数组代替\r\n1. 传入一个数组，其中可包含 Promise，也可包含普通数据\r\n1. 数组中 Prmise 并行执行\r\n1. 但凡有一个 Promise 被 Reject 掉，Promise.all 失败\r\n1. 保持输出数组位置与输入数组一致\r\n1. 所有数据 resolve 之后，返回结果\r\n\r\n``` js\r\nfunction pAll (_promises) {\r\n  return new Promise((resolve, reject) => {\r\n    // Iterable => Array\r\n    const promises = Array.from(_promises)\r\n    // 结果用一个数组维护\r\n    const r = []\r\n    const len = promises.length\r\n    let count = 0\r\n    for (let i = 0; i < len; i++) {\r\n      // Promise.resolve 确保把所有数据都转化为 Promise\r\n      Promise.resolve(promises[i]).then(o => { \r\n        // 因为 promise 是异步的，保持数组一一对应\r\n        r[i] = o;\r\n\r\n        // 如果数组中所有 promise 都完成，则返回结果数组\r\n        if (++count === len) {\r\n          resolve(r)\r\n        }\r\n        // 当发生异常时，直接 reject\r\n      }).catch(e => reject(e))\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n为了测试，实现一个 sleep 函数\r\n\r\n``` js\r\nconst sleep = (seconds) => new Promise(resolve => setTimeout(() => resolve(seconds), seconds))\r\n```\r\n\r\n以下示例进行测试，没有问题\r\n\r\n``` js\r\npAll([1, 2, 3]).then(o => console.log(o))\r\npAll([\r\n  sleep(3000),\r\n  sleep(2000),\r\n  sleep(1000)\r\n]).then(o => console.log(o))\r\npAll([\r\n  sleep(3000),\r\n  sleep(2000),\r\n  sleep(1000),\r\n  Promise.reject(10000)\r\n]).then(o => console.log(o)).catch(e => console.log(e, '<- Error'))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400sVN",
          "body": "```js\r\nPromise.all = function(promises) {\r\n  const len = promises.length;\r\n  const result = new Array(len);\r\n  let countDone = 0;\r\n  return new Promise((resolve, reject) => {\r\n    if (len === 0) {\r\n      resolve(result);\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n      const promise = promises[i];\r\n      Promise.resolve(promise)\r\n        .then(data => {\r\n          result[i] = data;\r\n          countDone++;\r\n          if (countDone === len) {\r\n            resolve(result);\r\n          }\r\n        }, error => {\r\n          reject(error);\r\n        });\r\n    }\r\n  });\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DJyfC",
          "body": "```ts\r\nfunction all(arr) {\r\n  return new Promise((resolve, reject) => {\r\n    const results = [];\r\n    arr.forEach(async (val) => {\r\n      Promise.resolve(val)\r\n        .then((data) => {\r\n          results.push(data);\r\n          if (results.length === arr.length) return resolve(results);\r\n        })\r\n        .catch((e) => reject(e));\r\n    });\r\n  });\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5KEYaW",
          "body": "> ```ts\r\n> function all(arr) {\r\n>   return new Promise((resolve, reject) => {\r\n>     const results = [];\r\n>     arr.forEach(async (val) => {\r\n>       Promise.resolve(val)\r\n>         .then((data) => {\r\n>           results.push(data);\r\n>           if (results.length === arr.length) return resolve(results);\r\n>         })\r\n>         .catch((e) => reject(e));\r\n>     });\r\n>   });\r\n> }\r\n> ```\r\n\r\n @Vi-jay 这个写法里，每个 promise 结束时间可能不一样，直接用 push 而不是数组循环索引去记录的话感觉可能会有问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "voezy",
            "url": "https://github.com/voezy"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YKAkC",
          "body": "```js\r\nPromise.all = function (promises = []) {\r\n    return new Promise((resolve, reject) => {\r\n        let count = 0\r\n        let values = new Array(promises.length)\r\n        const collect = index => value => {\r\n            values[index] = value\r\n            ++count === promises.length && resolve(values)\r\n        }\r\n        promises.forEach((promise, i) => {\r\n            if (promise instanceof Promise) {\r\n                promise.then(collect(i), reject)\r\n            } else {\r\n                collect(i)(promise)\r\n            }\t\r\n        })\r\n    })\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NDIwNDM2MjY=",
    "number": 501,
    "title": "【Q492】CSS 如何设置方格背景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NDE1NzgzMg==",
          "body": "``` css\r\nbackground: linear-gradient(90deg, rgba(200, 200, 200, .1) 3%, transparent 0), linear-gradient(rgba(200, 200, 200, .1) 3%, transparent 0);\r\nbackground-size: 20px 20px;\r\n```\r\n![image](https://user-images.githubusercontent.com/38256126/124486859-9a88c700-dde0-11eb-810f-842cd9b212d4.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lQ0se",
          "body": "在不引入图片和额外的元素，可以使用背景图的方式实现\r\n[具体的实现demo](https://stackblitz.com/edit/web-platform-jqbh2z?file=styles.css)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Neisun",
            "url": "https://github.com/Neisun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NDI4ODI4OTI=",
    "number": 502,
    "title": "【Q493】如何取消请求的发送",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgxNDY4Njg4Mw==",
          "body": "根据发送网络请求的API不同，取消方法不同\r\n- xhr\r\n- fetch \r\n- axios \r\n\r\n如果使用`XMLHttpRequest`发送请求可以使用`XMLHttpRequest.abort()`\r\n\r\n如果使用`fetch`发送请求可以使用`AbortController`\r\n```\r\nconst controller = new AbortController();\r\nconst signal = controller.signal;\r\nfetch('https://somewhere', { signal })\r\ncontroller.abort()\r\n```\r\n\r\n如果使用`axios`，取消原理同fetch\r\n```\r\nvar CancelToken = axios.CancelToken;\r\nvar source = CancelToken.source();\r\n\r\naxios.get('/https://somewhere', {\r\n  cancelToken: source.token\r\n}\r\n\r\nsource.cancel()\r\n```\r\n\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "evle",
            "url": "https://github.com/evle"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyMzI1Njg1Mg==",
          "body": "## 001 XHR 使用 `xhr.abort()`\r\n\r\n``` js\r\nconst xhr = new XMLHttpRequest(),\r\n    method = \"GET\",\r\n    url = \"https://developer.mozilla.org/\";\r\nxhr.open(method, url, true);\r\n\r\nxhr.send();\r\n\r\n// 取消发送请求\r\nxhr.abort();\r\n```\r\n\r\n## 002 fetch 使用 `AbortController` \r\n\r\n> `AbortController` 文档见 [AbortSignal - MDN](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)，它不仅可以取消 Fetch 请求发送，同样也可以取消事件的监听(通过 `addEventListener` 的第三个参数 `signal` 控制)\r\n\r\n1. 发送请求时使用一个 `signal` 选项控制 fetch 请求\r\n2. `control.abort()` 用以取消请求发送\r\n3. 取消请求发送之后会得到异常 `AbortError`\r\n\r\n``` js\r\nconst controller = new AbortController()\r\nconst signal = controller.signal\r\n\r\nconst downloadBtn = document.querySelector('.download');\r\nconst abortBtn = document.querySelector('.abort');\r\n\r\ndownloadBtn.addEventListener('click', fetchVideo);\r\n\r\n// 点击取消按钮时，取消请求的发送\r\nabortBtn.addEventListener('click', function() {\r\n  controller.abort();\r\n  console.log('Download aborted');\r\n});\r\n\r\nfunction fetchVideo() {\r\n  ...\r\n  fetch(url, {signal}).then(function(response) {\r\n    ...\r\n  }).catch(function(e) {\r\n   // 请求被取消之后将会得到一个 AbortError\r\n    reports.textContent = 'Download error: ' + e.message;\r\n  })\r\n}\r\n```\r\n\r\n### 003 Axios: `xhr` 与 `http/https`\r\n\r\n`Axios` 中通过 `cancelToken` 取消请求发送\r\n\r\n``` js\r\nconst CancelToken = axios.CancelToken;\r\nconst source = CancelToken.source();\r\n\r\naxios.get('/user/12345', {\r\n  cancelToken: source.token\r\n}).catch(function (thrown) {\r\n  if (axios.isCancel(thrown)) {\r\n    console.log('Request canceled', thrown.message);\r\n  } else {\r\n    // handle error\r\n  }\r\n});\r\n\r\naxios.post('/user/12345', {\r\n  name: 'new name'\r\n}, {\r\n  cancelToken: source.token\r\n})\r\n\r\n// cancel the request (the message parameter is optional)\r\nsource.cancel('Operation canceled by the user.');\r\n```\r\n\r\n而其中的原理可分为两部分\r\n\r\n+ 浏览器端: 基于 XHR，`xhr.abort()`，见源码[axios/lib/adapters/xhr.js](https://github.com/axios/axios/blob/v0.21.1/lib/adapters/xhr.js#L165)\r\n+ Node端: 基于 http/https/follow-redirects，使用 `request.abort()`，见源码[axios/lib/adapters/http.js](https://github.com/axios/axios/blob/v0.21.1/lib/adapters/http.js#L289)",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyMzI2OTY3Ng==",
          "body": "@evle 可以使用 js 代码高亮一下，其实 CancelToken 的底部原理是基于 xhr 的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NDQ2MDg3MTA=",
    "number": 503,
    "title": "【Q494】如何过滤数组中的 falsy value",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgxMDI5NTYwMQ==",
          "body": "falsy value 包含：`false`, `null`, `0`, `\"\"`, `undefined`, `NaN `\r\n\r\n使用以下即可过滤\r\n\r\n``` js\r\nfunction compact (array) {\r\n  return array.filter(Boolean)\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5arKdE",
          "body": "```js\r\nconst compact = (array) => array.filter(x => x)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NDk2NjM4OTE=",
    "number": 504,
    "title": "【Q495】如何把一个数组随机打乱",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgxMjg2OTk5MA==",
          "body": "使用原生实现，Math.rondom() - 0.5 有时大于0，有时小于0会达成这样的效果\r\n\r\n``` js\r\n[1, 2, 3, 4].sort((x, y) => Math.random() - 0.5)\r\n```\r\n\r\n借用 `lodash` 可更方便\r\n\r\n``` js\r\n_.shuffle([1, 2, 3, 4])\r\n//-> [3, 2, 4, 1]\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NTc3MjYwMjI=",
    "number": 505,
    "title": "【Q496】如何更好地给元素设置 z-index",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5nTjXD",
          "body": "在给元素设置z-index时，有几点需要注意：\r\n  1. 确保元素的z-index值是唯一的，否则可能会出现元素重叠的问题。\r\n  2. 尽量将具有高z-index值的元素放在较低z-index值的元素的上面，以确保元素的堆叠顺序正确。\r\n  3. 避免在多个元素上同时使用z-index，因为这可能会导致元素重叠或显示不正确。\r\n  4. 如果需要设置多个元素的z-index值，可以使用CSS的层叠上下文（z-index stacking context）来解决。层叠上下文可以将元素分组，使得每个组内的元素按照z-index值的大小进行堆叠。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Jupiter-u",
            "url": "https://github.com/Jupiter-u"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NTc5MDUyOTc=",
    "number": 506,
    "title": "【Q497】React.setState 是同步还是异步的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyNzY1NDk0Mw==",
          "body": "setState并不能保证是同步的，在生命周期函数和合成事件中是异步的，在原生事件和setTimeout中是同步的。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "IC_kwDODQzyOs5aVrrl",
          "body": "用createRoot之后所有的setState都是异步了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "muzichen",
            "url": "https://github.com/muzichen"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NjA4MTg4NDE=",
    "number": 507,
    "title": "【Q498】什么是服务器渲染 (SSR)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyNzUzODkzMw==",
          "body": "服务端渲染SSR：在服务端将请求的所有资源生成HTML，客户端收到后可以直接渲染。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTY1MzQyOA==",
          "body": "1. `renderToString`\r\n1. `hydrate`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400qVy",
          "body": "服务器渲染 (SSR)：将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。这个过程可以成为服务端渲染。\r\n\r\n优势：\r\n\r\n- 更好的 SEO\r\n\r\n- 更快的内容到达时间 (time-to-content)\r\n\r\n[Vue.js 服务器端渲染指南](https://ssr.vuejs.org/zh/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5nbHud",
          "body": "你们都好短🤔，贴个英文文档吧，https://web.dev/rendering-on-the-web/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JuctTr",
            "url": "https://github.com/JuctTr"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NjA4MjkzMTM=",
    "number": 508,
    "title": "【Q499】在 React 中如何实现代码分割 (code splitting)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs401f8G",
          "body": "[https://zh-hans.reactjs.org/docs/code-splitting.html](https://zh-hans.reactjs.org/docs/code-splitting.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NjIzODMwODY=",
    "number": 510,
    "title": "【Q500】在 React 中如何做好性能优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyNzYwODA1NQ==",
          "body": "- 代码分割\r\n- React.memo()、shouldComponentUpdate()等防止不必要的渲染\r\n- Fragments避免额外标记\r\n- 错误边界避免组件在出错时破坏整个应用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NjIzODkxOTk=",
    "number": 511,
    "title": "【Q501】在 React 中发现状态更新时卡顿，此时应该如何定位及优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5j8-Lv",
          "body": "在 React 中，当状态更新时出现卡顿，可能是由于以下原因导致的：\r\n\r\n1. 大量计算：当组件进行大量计算时，可能会导致状态更新时出现卡顿。这种情况下，可以考虑使用 `useMemo` 或 `useCallback` 来优化计算性能。\r\n\r\n2. 大量渲染：当组件进行大量渲染时，可能会导致状态更新时出现卡顿。这种情况下，可以考虑使用 `React.memo` 或 `shouldComponentUpdate` 来避免不必要的渲染。\r\n\r\n3. 大量数据：当组件需要处理大量数据时，可能会导致状态更新时出现卡顿。这种情况下，可以考虑使用分页或虚拟滚动等技术来优化性能。\r\n\r\n4. 异步更新：当组件进行异步更新时，可能会导致状态更新时出现卡顿。这种情况下，可以考虑使用 `React.lazy` 或 `Suspense` 来异步加载组件，从而避免卡顿。\r\n\r\n针对以上情况，可以采取以下优化措施：\r\n\r\n1. 使用性能分析工具：可以使用 Chrome 开发者工具中的 Performance 面板或 React DevTools 中的 Profiler 面板来分析组件的性能瓶颈，并找到需要优化的地方。\r\n\r\n2. 拆分组件：可以将组件拆分成更小的组件，从而减少组件的复杂度，提高性能。\r\n\r\n3. 使用异步更新：可以使用 `React.lazy` 或 `Suspense` 来异步加载组件，从而避免卡顿。\r\n\r\n4. 使用分页或虚拟滚动：可以使用分页或虚拟滚动等技术来优化处理大量数据时的性能。\r\n\r\n5. 使用 `useMemo` 或 `useCallback`：可以使用 `useMemo` 或 `useCallback` 来优化计算性能。\r\n\r\n6. 使用 `React.memo` 或 `shouldComponentUpdate`：可以使用 `React.memo` 或 `shouldComponentUpdate` 来避免不必要的渲染。\r\n\r\n总之，在 React 中，当状态更新时出现卡顿，可以使用性能分析工具来定位性能瓶颈，并采取相应的优化措施来提高性能。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "yumo-mt",
            "url": "https://github.com/yumo-mt"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NjI1MjMzODE=",
    "number": 512,
    "title": "【Q502】当多次重复点击按钮时，以下三个 Heading 是如何渲染的",
    "body": "``` js\r\nimport React, { memo, useMemo, useState } from \"react\";\r\n\r\nconst Heading = memo(({ style, title }) => {\r\n  console.log(\"Rendered:\", title);\r\n\r\n  return <h1 style={style}>{title}</h1>;\r\n});\r\n\r\nexport default function App() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const normalStyle = {\r\n    backgroundColor: \"teal\",\r\n    color: \"white\",\r\n  };\r\n\r\n  const memoizedStyle = useMemo(() => {\r\n    return {\r\n      backgroundColor: \"red\",\r\n      color: \"white\",\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <button\r\n        onClick={() => {\r\n          setCount(count + 1);\r\n        }}\r\n      >\r\n        Increment {count}\r\n      </button>\r\n      <Heading style={memoizedStyle} title=\"Memoized\" />\r\n      <Heading style={normalStyle} title=\"Normal\" />\r\n      <Heading title=\"React.memo Normal\" />\r\n    </>\r\n  );\r\n}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDgyNzUzNjM0OQ==",
          "body": "\"Memoized\"只在第一次渲染时打印一次，后续点击不刷新。\r\n\"Normal\"会在每次渲染时打印。\r\n\"React.memo Normal”只会在第一次渲染时打印一次。\r\n\r\n使用`useMemo`时，依赖数组为null，这意味着只会在首次渲染时，对memoizedStyle进行一次计算，后续不再计算。\r\n在渲染`<Heading />组件时，React.memo会先判断前后状态\r\n``` js\r\nmemoizedStyle === memoizedStyle  //true\r\n```\r\n由于状态始终是一个对象，自身始终是与自身相等的，所以不会导致重新渲染。\r\n\r\n没有使用`useMemo`时，每次点击，对`<Heading />`组件传入属性，React.memo判断\r\n``` js\r\n {\r\n    backgroundColor: \"teal\",\r\n    color: \"white\",\r\n  } ===  {\r\n    backgroundColor: \"teal\",\r\n    color: \"white\",\r\n  }  // false\r\n```\r\n每次都会传入一个新的对象，由于React.memo对prop进行浅比较，两个对象总是不相等的。\r\n如果需要进行深比较，可以对React.memo传入一个深比较函数作为第二个参数。\r\n\r\n\"React.memo Normal”的参数是字符串，相比对象的比较简单了很多，所以不会导致重新渲染。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NzM1Njk2NTE=",
    "number": 513,
    "title": "【Q503】Core Web Vitals 是什么，它有哪些指标",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4Mjk0NQ==",
          "body": "> 见文档 [Web Vitals](https://web.dev/vitals/)\r\n\r\n+ LCP: Largest Content Paint\r\n+ FID: Firtst Input Delay\r\n+ CLS: Cumulative Layout Shift\r\n\r\n|     | Good    | Needs improvement | Poor   |\r\n|-----|---------|-------------------|--------|\r\n| LCP | <=2.5s  | <=4s              | >4s    |\r\n| FID | <=100ms | <=300ms           | >300ms |\r\n| CLS | <=0.1   | <=0.25            | >0.25  |\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NzU5NDA0OTQ=",
    "number": 514,
    "title": "【Q504】画一个 100x100 的方框，其中文字可以正常换行，文字过多超过方框显示滚动条",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44NIwG",
          "body": "主要使用 word-wrap: break-word 或 break-all 和 overflow: scroll 实现\r\n\r\n[code pen 链接](https://codepen.io/hwb2017/pen/gOxabQG)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4NzcxMzQ5MzI=",
    "number": 515,
    "title": "【Q505】JS 中基础数据类型有哪些",
    "body": "追问：\r\n\r\n1. 如何判断某个值为基础数据类型，写一函数",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MjI2OQ==",
          "body": "七种，文档见 [基本数据类型 - MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\r\n\r\n+ number\r\n+ bigint: **这个常常会忽略，最新加入的**\r\n+ string\r\n+ undefined\r\n+ null\r\n+ symbol\r\n+ bool\r\n\r\n关于如何判断基础数据类型，可以使用函数实现：\r\n\r\n``` js\r\nfunction isPrimitive(value) {\r\n  const type = typeof value;\r\n  return (\r\n    type === 'string'\r\n    || type === 'number'\r\n    || type === 'symbol'\r\n    || type === 'boolean'\r\n    || value == null\r\n  );\r\n}\r\n```\r\n\r\n或者使用排除法\r\n\r\n``` js\r\nfunction isPrimitive(value) {\r\n  return value == null || (typeof value !== 'function' && typeof value !== 'object');\r\n}\r\n```\r\n\r\n或者使用一点小技巧\r\n\r\n``` js\r\nfunction isPrimitive(value) {\r\n  return value !== Object(value)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4ODM3MjIwODM=",
    "number": 518,
    "title": "【Q506】Grid 布局如何实现类似 flex: row-reverse",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4-0rQl",
          "body": "通过 grid-auto-flow属性 和 direction属性 来实现grid布局类似 flex: row-reverse的样式\r\n\r\ngrid-auto-flow: [row | column] || dense      该属性指定采用grid布局的容器内部的元素如何排序\r\ndirection: rtl | ltr  指定文本, 表列的水平方向\r\n\r\n[Code](https://codepen.io/csongl/pen/RwjegQL)\r\n\r\n## Reference\r\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction)\r\n[Article](https://blog.csdn.net/qq_42740797/article/details/113737171)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CsongL",
            "url": "https://github.com/CsongL"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4ODY3MjcxMzI=",
    "number": 520,
    "title": "【Q507】如何创建一个数组大小为100，每个值都为0的数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MDYzOTY4Mg==",
          "body": "` \r\n const arr = new Array(100); \r\n arr.fill(0)\r\n `",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "janyin",
            "url": "https://github.com/janyin"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MTA0MTk1Mg==",
          "body": "列举三种方法:\r\n\r\n``` js\r\n// 方法一:\r\nArray(100).fill(0)\r\n\r\n// 方法二: \r\n// 注: 如果直接使用 map，会出现稀疏数组\r\nArray.from(Array(100), x => 0)\r\n\r\n// 方法二变体:\r\nArray.from({ length: 100 }, x => 0)\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MTA0MjI4Nw==",
          "body": "> ` const arr = new Array(100); arr.fill(0)`\r\n\r\n可以省略 `new` 操作符，较为简洁",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNDY0NzQ=",
    "number": 521,
    "title": "【Q508】dependencies 与 devDependencies 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0MzIxMTA2OA==",
          "body": "**对于业务代码而讲，它俩区别不大**\r\n\r\n当进行业务开发时，严格区分 `dependencies` 与 `devDependencies` 并无必要，实际上，大部分业务对二者也并无严格区别。\r\n\r\n当打包时，依靠的是 `Webpack/Rollup` 对代码进行模块依赖分析，与该模块是否在 `dep/devDep` 并无关系，只要在 `node_modules` 上能够找到该 Package 即可。\r\n\r\n以至于在 CI 中 `npm i --production` 可加快包安装速度也无必要，因为在 CI 中仍需要 lint、test、build 等。\r\n\r\n**对于库 (Package) 开发而言，是有严格区分的**\r\n\r\n+ dependencies: 在生产环境中使用\r\n+ devDependencies: 在开发环境中使用，如 webpack/babel/eslint 等\r\n\r\n**当在项目中安装一个依赖的 Package 时，该依赖的 `dependencies` 也会安装到项目中，即被下载到 `node_modules` 目录中。但是 `devDependencies` 不会**\r\n\r\n因此当我们开发 Package 时，需要注意到我们所引用的 `dependencies` 会被我们的使用者一并下载，而 `devDependencies` 不会。\r\n\r\n一些 Package 宣称自己是 `zero dependencies`，一般就是指不依赖任何 `dependencies`，如 [highlight](https://github.com/highlightjs/highlight.js)\r\n\r\n> JavaScript syntax highlighter with language auto-detection and zero dependencies.",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40sapt",
          "body": "生产依赖会随着包一起下载，开发依赖不会，npm i --production可以只下载生产依赖",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs400p7O",
          "body": "**dependencies、devDependencies**\r\n\r\n`dependencies`字段指定了项目运行所依赖的模块，`devDependencies`指定项目开发所需要的模块。\r\n\r\n当你在软件包目录下执行`npm install`命令时，`dependencies`、`devDependencies`指定的三方软件包均会在`node_modules`目录下安装，若执行`npm install --production`命令，则不会安装`devDependecies`指定的三方软件包。但当软件包作为三方软件包被安装时（`npm install $package`）,则`dependencies`指定的软件包会被安装，`devDependencies`指定指定的软件包不会被安装。\r\n\r\n了解`dependencies`和`devDependencies`的作用后，我们在开发软件包时，哪些依赖应该放入`dependencies`，哪些依赖应该放入`devDependencies`中。\r\n\r\n首先我们要明确放入`dependencies`中的依赖软件包，是我们的项目在生产环境下运行时必须依赖的软件包，其的部分功能或全部功能通常会被打包到我们工程发布的`bundles`中。而放入`devDependencies`中软件包是我们的工程在开发时依赖的软件包，通常情况下以下的依赖会被放入`devDenpencies`中：\r\n\r\n- 格式化代码或错误检查类软件包：`esLint`、`prettier`\r\n\r\n- 打包工具及其插件：`webpack`, `gulp`, `parceljs`\r\n\r\n- `babel`及其的插件\r\n\r\n- 单元测试类：`enzyme`, `jest`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400p9-",
          "body": "`peerDependencies`的目的是提示宿主环境去安装满足插件`peerDependencies`所指定依赖的包，然后在插件`import`或者`require`所依赖的包的时候，永远都是引用宿主环境统一安装的`npm`包，最终解决插件与所依赖包不一致的问题。\r\n\r\n知道`peerDependencies`的作用后，什么样的软件包依赖需要放入？\r\n\r\n当我们开发的工程将作为第三方软件包发布的时候，我们就会用到`peerDependencies`。当我们发布软件包作为三方依赖运行时，并且我们确认或猜测到依赖我们的软件包的工程也会安装和我们软件包相同的三方依赖，我们就可以将这些依赖放入`peerDependencies`中。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNTA5Mzc=",
    "number": 522,
    "title": "【Q509】如何确认你们项目是否依赖某一个依赖项",
    "body": "例: 你们项目中是否引用了 npm 库 [semver](https://npm.devtool.tech/semver)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MTU2OQ==",
          "body": "``` bash\r\nyarn list | grep xxx\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNTIzMTY=",
    "number": 523,
    "title": "【Q510】当你引入某一个依赖项时，你引入的是该依赖下的哪一个文件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40saaF",
          "body": "package.json中的main对应的文件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs40s-Qi",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44Qa2X",
          "body": "- 如果 npm 包导出的是 ESM 规范的包，使用 module\r\n- 如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser\r\n- 如果 npm 包只在 server 端使用，使用 main\r\n- 如果 npm 包在 web 端和 server 端都允许使用，使用 browser 和 main\r\n\r\n参考 https://www.cnblogs.com/h2zZhou/p/12929472.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs44UohY",
          "body": "@hwb2017 目前 main、module、exports 是用的最多的几项字段，browser 目前用的越来越少了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTMzNTQyMzM=",
    "number": 524,
    "title": "【Q511】npm workspaces 解决了什么问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MjU2Ng==",
          "body": "多个包难以互相链接",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400pMe",
          "body": "[https://docs.npmjs.com/cli/v7/using-npm/workspaces](https://docs.npmjs.com/cli/v7/using-npm/workspaces)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTM0MTY2NTI=",
    "number": 525,
    "title": "【Q512】如何检测并避免循环依赖",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400o68",
          "body": "```js\r\nfunction isCircularReference(value) {\r\n  const isObject = value => Object.prototype.toString.call(value) === '[object Object]';\r\n  const isPrimitive = value => /Number|Boolean|String|Undefined|Null|Symbol/.test(Object.prototype.toString.call(value));\r\n  const memory = new WeakMap();\r\n  let isCycled = false;\r\n  const traverse = function(value) {\r\n    if (!isPrimitive(value)) {\r\n      if (memory.has(value)) {\r\n        isCycled = true;\r\n        return; \r\n      }\r\n      memory.set(value, true);\r\n      const keys = Object.keys(value);\r\n      for (const key of keys) {\r\n        traverse(value[key]);\r\n      }\r\n    }\r\n  }\r\n  traverse(value);\r\n  return isCycled;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTQ5MzIzMDY=",
    "number": 526,
    "title": "【Q513】有没有使用过 async/await，他们的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MTA0Mw==",
          "body": "原理: 一个 Generator 与一个自动执行器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400ox2",
          "body": "只支持`yield`表达式后面跟着`thunk`函数\r\n```js\r\nfunction runGenPromise(gen) {\r\n  let _resolve = null;\r\n  let _reject = null;\r\n  let isReturnPromise = arguments.length === 1;\r\n  let callback = !isReturnPromise\r\n    ? arguments[1]\r\n    : new Promise((resolve, reject) => {\r\n      _resolve = resolve;\r\n      _reject = reject;\r\n    });\r\n\r\n  let g = gen();\r\n  const next = function (err, ...args) {\r\n    if (err) {\r\n      isReturnPromise ? _reject(err) : callback(err);\r\n    }\r\n    let result = g.next(...args);\r\n    if (!result.done) {\r\n      result.value(next);\r\n    } else {\r\n      isReturnPromise ? _resolve(result.value) : callback(null, result.value);\r\n    }\r\n  }\r\n  next();\r\n  return callback;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTQ5NTY3MjE=",
    "number": 527,
    "title": "【Q514】什么是闭包，闭包的应用有哪些地方",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjM3NDA1Mw==",
          "body": "闭包是一个函数, 其可以记住并访问外部变量.\r\n\r\n在函数被创建时, 函数的隐藏属性 [[Environment]] 会记住函数被创建时的位置, 即当时的词法环境 Lexical Environment\r\n\r\n这样, 无论在哪里调用函数, 都会去到 [[Environment]] 所引用的词法环境\r\n\r\n当查找变量时, 先在词法环境内部查找, 当没有找到局部变量时, 前往当前词法环境所记录的外部词法环境查找\r\n\r\n我知道的闭包的应用: 封装私有变量和处理回调函数\r\n\r\n前端新人, 理解浅薄, 如果有错希望您指出\r\n\r\n学习来源为 [JavaScript.info/Closure](https://javascript.info/closure)",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjQ5Nzc1MA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjQ5Nzc1OQ==",
          "body": "> 闭包是一个函数, 其可以记住并访问外部变量.\r\n> \r\n> 在函数被创建时, 函数的隐藏属性 [[Environment]] 会记住函数被创建时的位置, 即当时的词法环境 Lexical Environment\r\n> \r\n> 这样, 无论在哪里调用函数, 都会去到 [[Environment]] 所引用的词法环境\r\n> \r\n> 当查找变量时, 先在词法环境内部查找, 当没有找到局部变量时, 前往当前词法环境所记录的外部词法环境查找\r\n> \r\n> 我知道的闭包的应用: 封装私有变量和处理回调函数\r\n> \r\n> 前端新人, 理解浅薄, 如果有错希望您指出\r\n> \r\n> 学习来源为 [JavaScript.info/Closure](https://javascript.info/closure)\r\n\r\n很专业了，像 once 这种记忆缓存数据的是否也算是一种应用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjU1MzQxNA==",
          "body": "请问 once 指的是什么?",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjU1ODg2Mg==",
          "body": "@liweinandever \r\n\r\n[onetime](https://npm.devtool.tech/onetime) 或者 [_.once](https://lodash.com/docs/4.17.15#once)，再加上 throttle/debounce 这种应该都是利用了闭包",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDc4OTk2Mg==",
          "body": "> > 闭包是一个函数, 其可以记住并访问外部变量.\r\n> > 在函数被创建时, 函数的隐藏属性 [[Environment]] 会记住函数被创建时的位置, 即当时的词法环境 Lexical Environment\r\n> > 这样, 无论在哪里调用函数, 都会去到 [[Environment]] 所引用的词法环境\r\n> > 当查找变量时, 先在词法环境内部查找, 当没有找到局部变量时, 前往当前词法环境所记录的外部词法环境查找\r\n> > 我知道的闭包的应用: 封装私有变量和处理回调函数\r\n> > 前端新人, 理解浅薄, 如果有错希望您指出\r\n> > 学习来源为 [JavaScript.info/Closure](https://javascript.info/closure)\r\n> \r\n> 封装私有变量\r\n> \r\n> ```js\r\n> function Ninja() {\r\n>   // 私有变量\r\n>   let feints = 0;\r\n> \r\n>   this.getFeints = () => {\r\n>     return feints;\r\n>   };\r\n>   this.feint = () => {\r\n>     feints++;\r\n>   };\r\n> }\r\n> const ninja1 = new Ninja();\r\n> const ninja2 = new Ninja(); // ninja1 和 ninja2 有自己的词法环境\r\n> \r\n> console.log(\"Ninja\", Ninja);\r\n> \r\n> console.log(\"ninja1 not access feints\", ninja1.feints === undefined); // true\r\n> console.log(\"get feints\", ninja1.getFeints()); // 0\r\n> ninja1.feint(); // +1\r\n> console.log(\"get feints\", ninja1.getFeints()); // 1\r\n> ```\r\n\r\n处理回调函数\r\n```js\r\nfunction fn() {\r\n  // tick 在这里被修改\r\n  // Interval 的回调函数, 通过闭包找到这里\r\n  let tick = 0;\r\n  console.log(\"tick init\", tick);\r\n\r\n  const timer = setInterval(() => {\r\n    if (tick < 100) {\r\n      tick += 1;\r\n      console.log(\"tick change\", tick);\r\n    } else {\r\n      clearInterval(timer);\r\n      console.log(\"tick equal 100\", tick === 100);\r\n      console.log(\"access timer by closure\", timer);\r\n    }\r\n  }, 10);\r\n}\r\nfn();\r\n```\r\n\r\n来源: [JavaScript 忍者秘籍](https://book.douban.com/subject/30143702/)\r\n可以直接编辑的, 我忘记了, 引用了三次.",
          "star": {
            "totalCount": 0
          },
          "author": null
        },
        {
          "id": "IC_kwDODQzyOs44u3_9",
          "body": "从作用域的角度理解，每创建一个函数会创建一个作用域，闭包里面的函数没有要释放，但是在外层却返回了本函数，导致变量不能被释放而留存下来，应用就是对于有存储变量的需求可以用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs5X6DtP",
          "body": "通俗的说就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。JS中,每当创建一个函数，闭包就会在函数创建的同时被创建出来。能够在函数定义的作用域外，使用函数定义作用域内的局部变量，并且不会污染全局。\r\n用处：它的最大用处有两个，一个是它可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yangzi0210",
            "url": "https://github.com/yangzi0210"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTUwMzQ2NjU=",
    "number": 528,
    "title": "【Q515】关于事件循环，一道异步代码执行输出顺序问题",
    "body": "``` js\r\nsetTimeout(() => {\r\n  console.log('A')\r\n  Promise.resolve().then(() => {\r\n    console.log('B')\r\n  })\r\n}, 1000)\r\n\r\nPromise.resolve().then(() => {\r\n  console.log('C')\r\n})\r\n\r\nnew Promise((resolve) => {\r\n  console.log('D')\r\n  resolve('')\r\n}).then(() => {\r\n  console.log('E')\r\n})\r\n\r\nasync function sum (a, b) {\r\n  console.log('F')\r\n}\r\n\r\nasync function asyncSum(a, b) {\r\n  await Promise.resolve()\r\n  console.log('G')\r\n  return Promise.resolve(a + b)\r\n}\r\n\r\nsum(3, 4)\r\nasyncSum(3, 4)\r\nconsole.log('H')\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1NDI5NjA5NA==",
          "body": "`D F H C E G A B`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTgyMDUzMjk=",
    "number": 529,
    "title": "【Q516】HTML 标签有哪些行内元素",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjA3MjEyOA==",
          "body": "常见的标签有以下几种，可参考 [inline element](https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements)\r\n\r\n+ a\r\n+ img\r\n+ picture\r\n+ span\r\n+ input\r\n+ textarea\r\n+ select\r\n+ label",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTgyMjU1NDU=",
    "number": 530,
    "title": "【Q517】CSS如何设置一行超出显示省略号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzY4ODY5OQ==",
          "body": "``` css\r\noverflow: hidden;\r\ntext-overflow: ellipsis;\r\nwhite-space: nowrap;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTgyMjYxNjk=",
    "number": 531,
    "title": "【Q518】CSS如何设置多行超出显示省略号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzY4NzQ3Ng==",
          "body": "使用 `-webkit-line-clamp` 来设置多行超出显示省略号\r\n\r\n``` css\r\noverflow: hidden;\r\ndisplay: -webkit-box;\r\n-webkit-box-orient: vertical;\r\n-webkit-line-clamp: 2;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Vsv8f",
          "body": "```css\r\n.box {\r\n  width:200px;\r\n  word-wrap: break-word;\r\n  overflow: hidden;\r\ndisplay: -webkit-box;\r\n-webkit-box-orient: vertical;\r\n-webkit-line-clamp: 3;\r\n}\r\n```\r\n先设置宽度 加上word-wrap属性达到换行的目的  \r\n利用-webkit-line-clamp限制行数\r\n 利用overflow属性隐藏所省略",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "VaCameos",
            "url": "https://github.com/VaCameos"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MDgyMzQ=",
    "number": 532,
    "title": "【Q519】如何发布一个全局可执行命令的 npm package",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40saQx",
          "body": "在package.json中增加bin，对应脚本，脚本文件头部\r\n#! usr/local/bin node\r\n\r\n\bemm，头部大概是这个，可能有拼写错误",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs40s-IY",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MDk3NjM=",
    "number": 533,
    "title": "【Q520】如何为一个项目指定 node 版本号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM3MTMwMw==",
          "body": "> + 我: 老大，我这个项目本地白屏了，今天调了一天都没找到问题，快来看看\r\n> + leader: (瞄了一眼) 你的 node 版本号有问题\r\n> + 我: 老大，不能怪我跑挂了，我一个新入职的小前端怎么能够知道这个项目所需的 Node 版本号是多少呢\r\n> + leader: 怎么不能知道，这说明你水平不到家\r\n\r\n指定一个项目所需的 node 最小版本，这属于一个项目的质量工程。\r\n\r\n如果对于版本不匹配将会报错(yarn)或警告(npm)，那我们需要在 `package.json` 中的 `engines` 字段中指定 Node 版本号\r\n\r\n> 更多质量工程问题，见 [如何保障项目质量](https://github.com/shfshanyue/Daily-Question/issues/552)\r\n\r\n``` json\r\n{\r\n  \"engines\": {\r\n    \"node\": \">=14.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n一个示例：\r\n\r\n**我在本地把项目所需要的 node 版本号改成 `>=16.0.0`，而本地的 node 版本号为 `v10.24.1`**\r\n\r\n此时，npm 将会发生警告，提示你本地的 node 版本与此项目不符。\r\n\r\n``` bash\r\nnpm WARN EBADENGINE Unsupported engine { package: 'next-app@1.0.0',\r\nnpm WARN EBADENGINE   required: { node: '>=16.0.0' },\r\nnpm WARN EBADENGINE   current: { node: 'v10.24.1', npm: '7.14.0' } }\r\n```\r\n\r\n而 yarn 将会直接报错，提示。\r\n\r\n``` bash\r\nerror next-app@1.0.0: The engine \"node\" is incompatible with this module. Expected version \">=16.0.0\". Got \"10.24.1\"\r\n```\r\n\r\n**最为重要的是，项目中某些依赖所需要的 Node 版本号与项目运行时的 Node 版本号不匹配，也会报错(在yarn中)**，此时无法正常运行项目，可避免意外发生。\r\n\r\n可看一个示例，[engines 示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/engines)，其中 `ansi-regex` 该依赖所需的 node 版本号为 `12+`，而此时本地的 node 版本号为 10，使用 yarn 安装报错！\r\n\r\n``` js\r\n// 在 package.json 中，所需 node 版本号需要 >=10\r\n{\r\n  \"engines\": {\r\n    \"node\": \">=10.0.0\"\r\n  }\r\n}\r\n\r\n// 在 package-lock.json 中，所需 node 版本号需要 >=12\r\n{\r\n  \"node_modules/ansi-regex\": {\r\n    \"version\": \"6.0.1\",\r\n    \"engines\": {\r\n      \"node\": \">=12\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-25/clipboard-2084.d06897.webp)\r\n\r\n> PS: 如果项目的 package.json 中没有 `engines` 字段，可查看 Dockerfile 中 node 镜像确定项目所需的 node 版本号。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODgyNjg4Mw==",
          "body": "Great!",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiutian00",
            "url": "https://github.com/qiutian00"
          }
        },
        {
          "id": "IC_kwDODQzyOs41cZg3",
          "body": "nice job~ !!",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "946629031",
            "url": "https://github.com/946629031"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MTExMTc=",
    "number": 534,
    "title": "【Q521】什么是 semver，~1.2.3 与 ^1.2.3 的版本号范围是多少",
    "body": "当你 `npm install` 时，你安装的是哪一种形式",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjU5MjA3MA==",
          "body": "`semver`，`Semantic Versioning` 语义化版本的缩写，文档可见 <https://semver.org/>，它由 `[major, minor, patch]` 三部分组成，其中\r\n\r\n+ `major`: 当你发了一个含有 Breaking Change 的 API\r\n+ `minor`:  当你新增了一个向后兼容的功能时\r\n+ `patch`: 当你修复了一个向后兼容的 Bug 时\r\n\r\n\r\n假设你的版本库中含有一个函数\r\n\r\n``` js\r\n// 假设原函数\r\nexport const sum = (x: number, y: number): number => x + y\r\n\r\n// Patch Version，修复小 Bug\r\nexport const sum = (x: number, y: number): number => x + y\r\n\r\n// Minor Version，向后兼容\r\nexport const sum = (...rest: number[]): number => rest.reduce((s, x) => s + x, 0)\r\n\r\n// Marjor Version，出现 Breaking Change\r\nexport const sub = () => {}\r\n```\r\n\r\n对于 `~1.2.3` 而言，它的版本号范围是 `>=1.2.3  <1.3.0`\r\n\r\n对于 `^1.2.3` 而言，它的版本号范围是 `>=1.2.3  <2.0.0`\r\n\r\n当我们 `npm i` 时，默认的版本号是 `^`，可最大限度地在向后兼容与新特性之间做取舍，但是有些库有可能不遵循该规则，我们在项目时应当使用 `yarn.lock`/`package-lock.json` 锁定版本号。\r\n\r\n我们看看 `package-lock` 的工作流程。\r\n\r\n1. `npm i webpack`，此时下载最新 webpack 版本 `5.58.2`，在 `package.json` 中显示为 `webpack: ^5.58.2`，版本号范围是 `>=5.58.2 < 6.0.0`\r\n2. 在 `package-lock.json` 中全局搜索 `webpack`，发现 webpack 的版本是被锁定的，也是说它是确定的 `webpack: 5.58.2`\r\n3. 经过一个月后，webpack 最新版本为 `5.100.0`，但由于 `webpack` 版本在 `package-lock.json` 中锁死，每次上线时仍然下载 `5.58.2` 版本号\r\n4. 经过一年后，webpack 最新版本为 `6.0.0`，但由于 `webpack` 版本在 `package-lock.json` 中锁死，且 package.json 中 `webpack` 版本号为 `^5.58.2`，与 `package-lock.json` 中为一致的版本范围。每次上线时仍然下载 `5.58.2` 版本号\r\n5. 支线剧情：经过一年后，webpack 最新版本为 `6.0.0`，需要进行升级，此时手动改写 `package.json` 中 `webpack` 版本号为 `^6.0.0`，与 `package-lock.json` 中不是一致的版本范围。此时 `npm i` 将下载 `6.0.0` 最新版本号，并重写 `package-lock.json` 中锁定的版本号为 `6.0.0`\r\n\r\n## 一个问题总结:\r\n\r\nnpm i 某个 package 时会修改 `package-lock.json` 中的版本号吗？\r\n\r\n当 `package-lock.json` 该 package 锁死的版本号符合 `package.json` 中的版本号范围时，将以 `package-lock.json` 锁死版本号为主。\r\n\r\n当 `package-lock.json` 该 package 锁死的版本号不符合 `package.json` 中的版本号范围时，将会安装该 package 符合 `package.json` 版本号范围的最新版本号，并重写 `package-lock.json`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MTQ1Nzc=",
    "number": 535,
    "title": "【Q522】package.json 中 main/module/browser/exports 字段有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44sGUJ",
          "body": "## main\r\n\r\n`main` 指 npm package 的入口文件，当我们对某个 package 进行导入时，实际上导入的是 `main` 字段所指向的文件。\r\n\r\n`main` 是 CommonJS 时代的产物，也是最古老且最常用的入口文件。\r\n\r\n``` js\r\n// package.json 内容\r\n{\r\n  name: 'midash',\r\n  main: './dist/index.js'\r\n}\r\n\r\n// 关于如何引用 package\r\nconst midash = require('midash')\r\n\r\n// 实际上是通过 main 字段来找到入口文件，等同于该引用\r\nconst midash = require('midash/dist/index.js')\r\n```\r\n\r\n## module\r\n\r\n随着 ESM 且打包工具的发展，许多 package 会打包 N 份模块化格式进行分发，如 `antd` 既支持 `ES`，也支持 `umd`，将会打包两份。\r\n\r\n![antd 分发了两种格式](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/antd.50lzknb7r000.png)\r\n\r\n如果使用 `import` 对该库进行导入，则首次寻找 `module` 字段引入，否则引入 `main` 字段。\r\n\r\n基于此，许多前端友好的库，都进行了以下分发操作:\r\n\r\n1. 对代码进行两份格式打包: `commonjs` 与 `es module`\r\n1. `module` 字段作为 `es module` 入口\r\n1. `main` 字段作为 `commonjs` 入口\r\n\r\n``` js\r\n{\r\n  name: 'midash',\r\n  main: './dist/index.js',\r\n  module: './dist/index.mjs'\r\n}\r\n\r\n// 以下两者等同\r\nimport midash from 'midash'\r\nimport midash from 'midash/dist/index.mjs'\r\n```\r\n\r\n如果你的代码只分发一份 `es module` 模块化方案，则直接置于 `main` 字段之中。\r\n\r\n## exports\r\n\r\n如果说以上两个是刀剑，那 `exports` 至少得是瑞士军刀。\r\n\r\n`exports` 可以更容易地控制子目录的访问路径，也被称为 `export map`。\r\n\r\n假设我们 Package 的目录如下所示:\r\n\r\n``` bash\r\n├── package.json\r\n├── index.js\r\n└── src\r\n    └── get.js\r\n```\r\n\r\n**不在 `exports` 字段中的模块，即使直接访问路径，也无法引用！**\r\n\r\n``` js\r\n// package.json\r\n{\r\n  name: 'midash',\r\n  main: './index.js',\r\n  exports: {\r\n    '.': './dist/index.js',\r\n    'get': './dist/get.js'\r\n  }\r\n}\r\n\r\n// 正常工作\r\nimport get from 'midash/get'\r\n\r\n// 无法正常工作，无法引入\r\nimport get from 'midash/dist/get'\r\n```\r\n\r\n`exports` 不仅可根据模块化方案不同选择不同的入口文件，还可以根据环境变量(`NODE_ENV`)、运行环境(`nodejs`/`browser`/`electron`) 导入不同的入口文件。\r\n\r\n``` js\r\n{\r\n  \"type\": \"module\",\r\n  \"exports\": {\r\n    \"electron\": {\r\n      \"node\": {\r\n        \"development\": {\r\n          \"module\": \"./index-electron-node-with-devtools.js\",\r\n          \"import\": \"./wrapper-electron-node-with-devtools.js\",\r\n          \"require\": \"./index-electron-node-with-devtools.cjs\"\r\n        },\r\n        \"production\": {\r\n          \"module\": \"./index-electron-node-optimized.js\",\r\n          \"import\": \"./wrapper-electron-node-optimized.js\",\r\n          \"require\": \"./index-electron-node-optimized.cjs\"\r\n        },\r\n        \"default\": \"./wrapper-electron-node-process-env.cjs\"\r\n      },\r\n      \"development\": \"./index-electron-with-devtools.js\",\r\n      \"production\": \"./index-electron-optimized.js\",\r\n      \"default\": \"./index-electron-optimized.js\"\r\n    },\r\n    \"node\": {\r\n      \"development\": {\r\n        \"module\": \"./index-node-with-devtools.js\",\r\n        \"import\": \"./wrapper-node-with-devtools.js\",\r\n        \"require\": \"./index-node-with-devtools.cjs\"\r\n      },\r\n      \"production\": {\r\n        \"module\": \"./index-node-optimized.js\",\r\n        \"import\": \"./wrapper-node-optimized.js\",\r\n        \"require\": \"./index-node-optimized.cjs\"\r\n      },\r\n      \"default\": \"./wrapper-node-process-env.cjs\"\r\n    },\r\n    \"development\": \"./index-with-devtools.js\",\r\n    \"production\": \"./index-optimized.js\",\r\n    \"default\": \"./index-optimized.js\"\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5QfMM8",
          "body": "想知道 `main/module/browser/exports` 直接的优先级，在 `package.json` 中同时指定这些，会优先以 `exports` 为准吗?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "GiveMe-A-Name",
            "url": "https://github.com/GiveMe-A-Name"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MjExMzQ=",
    "number": 536,
    "title": "【Q523】npm publish 时 npm script 的生命周期",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM4MDcwNA==",
          "body": "+ prepublishOnly\r\n+ prepack\r\n+ prepare\r\n+ postpack\r\n+ publish\r\n+ postpublish",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTg3MjIzMzQ=",
    "number": 537,
    "title": "【Q524】前端项目每次 npm install 之后需要执行一些处理工作，应该怎么办",
    "body": "例如: husky",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM2NTYzNg==",
          "body": "使用 npm script 生命周期中的 `npm prepare`，他将会在发包 (publish) 之前以及装包 (install) 之后自动执行。\r\n\r\n如果只想在装包之后自动执行，可使用 `npm postinstall`\r\n\r\n例如:\r\n\r\n[husky](https://github.com/typicode/husky)\r\n\r\n``` json\r\n{\r\n  \"prepare\": \"npm run build & node packages/husky/lib/bin.js install\" \r\n}\r\n```\r\n\r\n[vue-cli](https://github.com/vuejs/vue-cli/blob/dev/package.json) 一些著名的仓库会使用 [patch-package](https://github.com/ds300/patch-package) 自动修复 node_modules 中依赖的问题\r\n\r\n``` json\r\n{\r\n  \"postinstall\": \"patch-package\"\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwMTQ2MjA=",
    "number": 538,
    "title": "【Q525】flex 布局中 order 有何作用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzY3NzM5MQ==",
          "body": "`order` 属性定义Flex布局中子元素的排列顺序，数值越小，排列越靠前，默认为0。\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwMTc4MzM=",
    "number": 539,
    "title": "【Q526】flex 布局中 align-content 与 align-items 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzY3NjM0MA==",
          "body": "> 示例代码见: [align-content 与 align-items](https://codepen.io/shanyue/pen/abJwoRp?editors=1100)\r\n\r\n+ `align-content` 作用于纵轴多行元素，一行元素不起作用\r\n+ `align-items` 作用于纵轴单行元素\r\n\r\n下图，上部分为 `align-content`，下部分为 `align-items`\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/119467452-1ae6f180-bd78-11eb-9645-19ea9ee0a1e5.png)\r\n\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwNjI1NzU=",
    "number": 540,
    "title": "【Q527】解构赋值一个数组，a 取第一项默认值为 3，c取剩下的值组成数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM2NDU1Ng==",
          "body": "``` js\r\nconst list = [1, 2, 3, 4, 5]\r\nconst [a, ...c] = list\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4_Kczv",
          "body": "```javascript\r\nfunction getTargetAndRest(target, originList) {\r\n  let targetArr = []\r\n  for(let i = 0; i<originList.length; i++) {\r\n    if (originList[i] === target) {\r\n      targetArr = originList.splice(i, 1)\r\n      break\r\n    }\r\n  }\r\n  return targetArr.concat(originList)\r\n}\r\n\r\nconst list = [1, 2, 3, 4, 5]\r\nlet [a, ...c] = getTargetAndRest(3, list)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JoeWrights",
            "url": "https://github.com/JoeWrights"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JR9-Z",
          "body": "一楼兄弟的答案少了个默认值，小改一下\r\n\r\n```javascript\r\nconst list = [1, 2, 3, 4, 5]\r\nconst [a = 3, ...c] = list; // a: 1 c: [2,3,4,5]\r\n\r\nconst list2 = [];\r\nconst [a = 3, ...c] = list2; // a: 3 c: []\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwNjQ5Njk=",
    "number": 541,
    "title": "【Q528】解构赋值以下对象，他们的值是多少",
    "body": "---\r\n\r\n``` js\r\nconst {a: aa, b } = {a: 3, b: 4} \r\n```\r\n\r\n分别打印 `a`、`aa`、`b`，他们的值是多少\r\n\r\n---\r\n\r\n\r\n``` js\r\nfunction move({x = 0, y = 0} = {}) {\r\n  return [x, y];\r\n}\r\n\r\nfunction move({x, y} = { x: 0, y: 0 }) {\r\n  return [x, y];\r\n}\r\n```\r\n\r\n以下几个表达式返回的结果是什么\r\n\r\n``` js\r\nmove({x: 3, y: 8});\r\nmove({x: 3})\r\nmove({}); \r\nmove(); \r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM3MDgwMw==",
          "body": "``` js\r\nconst {a: aa, b } = {a: 3, b: 4} \r\n\r\n// 其中 a 报错、aa 为3, b 为 4\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5GqbcI",
          "body": "```\r\n//这种写法x,y有默认值\r\nfunction move({x = 0, y = 0} = {}) {\r\n  return [x, y];\r\n}\r\n//这种写法x,y没有默认值\r\nfunction move({x, y} = { x: 0, y: 0 }) {\r\n  return [x, y];\r\n}\r\nmove({x: 3, y: 8});\r\n[3,8] [3,8]\r\nmove({x: 3})\r\n[3,0] [3,undefined]\r\nmove({}); \r\n[0,0] [undefined,undefined]\r\nmove(); \r\n没传参，解构赋值\r\n[0,0] [0,0]\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Magicgigi",
            "url": "https://github.com/Magicgigi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTkwNjcyNTc=",
    "number": 542,
    "title": "【Q529】Map 与 WeakMap 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM1NzQ4OA==",
          "body": "+ `Map`: 可使用任何数据类型作为 key，但因其在内部实现原理中需要维护两个数组，存储 key/value，因此垃圾回收机制无法回收\r\n+ `WeakMap`: 只能使用引用数据类型作为 key。弱引用，不在内部维护两个数组，可被垃圾回收，但因此无法被遍历！即没有与枚举相关的 API，如 `keys`、`values`、`entries` 等",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400cfJ",
          "body": "`WeakMap `与 `Map `在 API 上的区别主要是两个，一是没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持`clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU4OTk4NDQ0ODY=",
    "number": 543,
    "title": "【Q530】HTML 中有哪些语义化标签",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM0ODkxNg==",
          "body": "> 见文档 [HTML Elements - MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element)\r\n\r\n+ header\r\n+ footer\r\n+ main\r\n+ aside\r\n+ article\r\n+ section\r\n+ address\r\n+ summary/details\r\n+ menu\r\n+ h1/h2/h3/h4/h5/h6\r\n+ img\r\n+ p\r\n+ strong/italic",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDAzMTQ2Nzg=",
    "number": 544,
    "title": "【Q531】子元素垂直居中，并且该子元素的长度/宽度为父容器宽度(width)一半的正方形",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzU2Mzk1Ng==",
          "body": "> [垂直居中长度为父容器一半的子元素 - Codepen](https://codepen.io/shanyue/pen/GRWmaVw?editors=1100)\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\"></div>\r\n</div>\r\n```\r\n\r\n以前采用百分比撑高 `padding`，那这种方案已经过时，会挤压 Content 内容，无法在其中填充内容(需要绝对定位)。\r\n\r\n可使用最新的属性 `aspect-ratio`，即长宽比\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  place-items: center;\r\n}\r\n\r\n.item {\r\n  width: 50%;\r\n  aspect-ratio: 1/1;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1MjA4MTU=",
    "number": 545,
    "title": "【Q532】简述 css 中 position 的值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzY5OTE3Ng==",
          "body": "+ `static`: 默认值，无定位，`top`、`right`、`bottom`、`left` 不起任何作用\r\n+ `relative`: 相对定位\r\n+ `absolute`: 绝对定位，脱离文档流，上下左右以最近的定位父元素为参照系\r\n+ `fixed`: 脱离文档流，上下左右以浏览器视口为参照系\r\n+ `sticky`: `relative` 与 `fixed` 的结合体",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1MzY3NjE=",
    "number": 546,
    "title": "【Q533】什么是 BFC",
    "body": "+ 它是如何生成的\r\n+ 它有什么作用及应用",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM1MDYyOA==",
          "body": "块级格式化上下文，`Block Formatting Context`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44US0J",
          "body": "参考思否上的这篇 [前端面试题-BFC(块格式化上下文) ](https://segmentfault.com/a/1190000013647777#:~:text=%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Block%20Formatting,Context%EF%BC%8CBFC%EF%BC%89%E6%98%AFWeb%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96CSS%E6%B8%B2%E6%9F%93%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E6%98%AF%E5%B8%83%E5%B1%80%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%94%9F%E6%88%90%E5%9D%97%E7%BA%A7%E7%9B%92%E5%AD%90%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E4%B9%9F%E6%98%AF%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0%E4%B8%8E%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0%E7%9A%84%E4%BA%A4%E4%BA%92%E9%99%90%E5%AE%9A%E5%8C%BA%E5%9F%9F%E3%80%82%202.%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1Mzk5NTA=",
    "number": 547,
    "title": "【Q534】CSS 如何实现固定长宽比的元素",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM0NTk2NQ==",
          "body": "过去的解决方案是使用 `padding`。一个元素的 `padding` 如若设置为百分比，则代表的是以父元素宽度为基准，根据这个原理，可设置长宽比。但实际上意义有限，毕竟你把 padding 给占了，content 无任何区域。\r\n\r\n现代化的解决方案是使用长宽比的 CSS 属性: `aspect-ratio`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44UVGn",
          "body": "[codepen demo](https://codepen.io/hwb2017/pen/qBXbmpq)\r\n\r\n另外 aspect-ratio 也可以用于媒体查询中，参考 [mdn](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/aspect-ratio)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1NDYwMzQ=",
    "number": 548,
    "title": "【Q535】rem、em、vw、vh 的值各是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODMzNjI2Nw==",
          "body": "他们同属于 CSS Data Type 中的 `[length]`，见文档 [length - MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/length)\r\n\r\n+ `rem`: 根据根元素(即 `html`)的 `font-size`\r\n+ `em`: 根据**自身元素**的 `font-size`\r\n+ `vw`: viewport width\r\n+ `vh`: viewport height",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VUhUR",
          "body": "- `em`: \"在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width\"[来自MDN](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Values_and_units#%E9%95%BF%E5%BA%A6)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "gxr404",
            "url": "https://github.com/gxr404"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1NDgwNzg=",
    "number": 549,
    "title": "【Q536】normalize.css 与 reset.css 又何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0NzcxODM2Nw==",
          "body": "[What is the difference between Normalize.css and Reset CSS?](https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css)\r\n\r\n+ [normalize.css](https://github.com/necolas/normalize.css/blob/master/normalize.css): 会保留有用的样式，比如 h1 的字体大小\r\n+ [reset.css](https://github.com/jgthms/minireset.css/blob/master/minireset.css): 把所有样式都重置，比如 h1、h2、h3 的字体大小都进行了重置，保持了无样式",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44ooy1",
          "body": "那普通项目是哪一个更好使？\r\n我倾向 reset.css。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JtToE",
          "body": "可以看看这篇文章 https://jerryzou.com/posts/aboutNormalizeCss/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDA1NjE5NjY=",
    "number": 550,
    "title": "【Q537】line-height 的值分别取 [2, 2em, 200%] 有什么区别?",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODMzNDI4MQ==",
          "body": "> 代码见: [lineHeight - codepen](https://codepen.io/shanyue/pen/bGqRLxQ?editors=1100)\r\n\r\n`line-height` 是相对于元素自身的字体大小来取值，但同时会被继承。在实际工作中，取值 `2em` 或者 `200%` 有可能遇到未预测的内容。\r\n\r\n比如:\r\n\r\n+ 父元素: `fontSize: 18px; lineHeight: 1.5em(27px，150% 同理);` ，它的 lineHeight 计算下来为 27px，会被子元素继承\r\n+ 子元素: `fontSize: 30px`，子元素的 lineHeight 被继承为 27px，出现问题\r\n\r\n以下为演示代码，见: [lineHeight - codepen](https://codepen.io/shanyue/pen/bGqRLxQ?editors=1100)\r\n\r\n``` html\r\n<div class=\"box green\">\r\n  <h1>lineHeight: 1.5; 这是没有问题的框框</h1>\r\n  lineHeight: 1.5; 这是没有问题的框框\r\n  lineHeight: 1.5; 这是没有问题的框框\r\n</div>\r\n\r\n<div class=\"box red\">\r\n <h1>lineHeight: 1.5em; 这是有问题的框框</h1>\r\n  lineHeight: 1.5em; 这是有问题的框框\r\n  lineHeight: 1.5em; 这是有问题的框框\r\n</div>\r\n\r\n<div class=\"box orange\">\r\n <h1>lineHeight: 150%; 这是有问题的框框</h1>\r\n  lineHeight: 150%; 这是有问题的框框\r\n  lineHeight: 150%; 这是有问题的框框\r\n</div>\r\n```\r\n\r\n``` css\r\n.green {\r\n  line-height: 1.5;\r\n  border: solid limegreen;\r\n}\r\n\r\n.red {\r\n  line-height: 1.5em;\r\n  border: solid red;\r\n}\r\n\r\n.orange {\r\n  line-height: 150%;\r\n  border: solid orange;\r\n}\r\n\r\nh1 {\r\n  font-size: 30px;\r\n}\r\n\r\n.box {\r\n  width: 18em;\r\n  display: inline-block;\r\n  vertical-align: top;\r\n  font-size: 16px;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE1Nzc0MzA=",
    "number": 552,
    "title": "【Q538】你是如何保障你们项目质量的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0ODM3OTY2MQ==",
          "body": "+ lint\r\n+ type\r\n+ test\r\n+ code review\r\n+ git hooks\r\n+ CI\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5h7NrW",
          "body": "> * lint\r\n> * type\r\n> * test\r\n> * code review\r\n> * git hooks\r\n> * CI\r\n\r\n这里的type只的是类似typescript吗",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ChenKun1997",
            "url": "https://github.com/ChenKun1997"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE2OTcxODk=",
    "number": 553,
    "title": "【Q539】Javascript 数组中有那些方法可以改变自身，那些不可以",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTQ5MTM5Nw==",
          "body": "不可改变自身的 Array API\r\n\r\n+ Array.prototype.map",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MzMzNjEyNg==",
          "body": "不改变原数组的方法：concat/join/reduce/map/forEach/filter/slice/findIndex\r\n\r\n改变原数组的方法：push/unshift/pop/shift/sort/splice/reverse",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE3MjU4NTY=",
    "number": 554,
    "title": "【Q540】如何判断一个数组是否包含某个值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTQ5MDk2NA==",
          "body": "``` js\r\nArray.prototype.includes()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDE3MjYzNDU=",
    "number": 555,
    "title": "【Q541】如何判断字符串包含某个子串",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTQ5MDc4Nw==",
          "body": "``` js\r\nString.prototype.includes()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400cNj",
          "body": "```js\r\nString.prototype.IndexOf = function(searchValue, fromIndex) {\r\n  const string = this;\r\n  const len = string.length;\r\n\r\n  // 默认值为 0\r\n  let n = fromIndex | 0;\r\n  // 如果 fromIndex 的值小于 0，或者大于 str.length ，那么查找分别从 0 和str.length 开始\r\n  let k = n <= 0 ? 0 : n >= len ? len : n;\r\n  while (k < len) {\r\n    const subStr = string.substring(k, k + searchValue.length);\r\n    if (subStr === searchValue) {\r\n      return k;\r\n    }\r\n    k++;\r\n  }\r\n  return -1;\r\n}\r\n\r\nconsole.log('hello world'.IndexOf('ll') + '/' + 'hello world'.indexOf('ll'))\r\nconsole.log('hello world'.IndexOf('ll', -1) + '/' + 'hello world'.indexOf('ll', -1));\r\nconsole.log('hello world'.IndexOf('or', -6) + '/' + 'hello world'.indexOf('or', -6));\r\nconsole.log('hello world'.IndexOf('wo', 12) + '/' + 'hello world'.indexOf('wo', 12));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5L4_Vy",
          "body": "`function checkStr(string, child) {\r\n    let res = string.split(child)\r\n    if (res.length > 1) return true\r\n    return false\r\n}`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xieyusai",
            "url": "https://github.com/xieyusai"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMwODE4Nzc=",
    "number": 556,
    "title": "【Q542】DOM 中如何阻止事件默认行为，如何判断事件否可阻止？",
    "body": "追问：\r\n\r\n1. 有哪些事件可阻止，哪些事件不可阻止?",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTc0MDYwNQ==",
          "body": "+ `e.preventDefault()`: 取消事件\r\n+ `e.cancelable`: 事件是否可取消\r\n\r\n如果 `addEventListener` 第三个参数 `{ passive: true}`，`preventDefault` 将会会无效",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40y2XP",
          "body": "[补充] 如果passive设置为true 那其实preventDefault 就会无效 因为 passive 为true 会导致初始化的时候cancelable为false\r\n\r\nevent.preventDefault 不能取消的没有固定哪一个类 主要是在规范中有没有定义Default Action 还有即使是定义了Default Action \r\n那在实际中可能也会在不同的触发时间存在或不存在默认行为 所以可以依赖event.cancelable 来处理Default Action \r\n\r\n如果只是简单列举下 具体可以去 https://w3c.github.io/uievents/#events-wheelevents 自己看看 当然不是全部event这里都有我就不都粘这里了\r\n\r\nUI Event\r\n\r\n    load\r\n    unload\r\n    abort\r\n    error\r\n    select\r\nFocus Event\r\n\r\n    blur\r\n    focus\r\n    focusin\r\n    focusout\r\nMouse Event\r\n\r\n    dbclick\r\n    mousedown   部分情况\r\n    mouseenter\r\n    moouseleave\r\n    moousemove\r\n    mouseout\r\n    mouseleave\r\n    mouseup     鼠标左右\r\nInput Event\r\n\r\n    input\r\nKeyboard\r\n\r\n    keydown 部分情况\r\n    keyup\r\nComposition Event\r\n\r\n    compositionupdate\r\n    compositionend\r\n\r\nTouch Event\r\n    \r\n    touchstart\r\n    touchend    部分情况\r\n    touchmove\r\n    touchcancel\t\r\n\r\n\r\n\r\nscroll 规范中没有定义他的Event归属 其实算是wheel的后续操作\r\n\r\n\r\n检查能不能取消默认事件可以使用 cancelable\r\n\r\n是否被取消了默认事件defaultPrevented\r\n\r\n取消默认 preventDefault 或者 e.returnValue = false\r\n\r\n正常一个event是带有7个tag\r\n\r\nstop propagation flag   =>  stopPropagation | cancelBubble | stopImmediatePropagation\r\n\r\nstop immediate propagation flag     =>      stopImmediatePropagation\r\n\r\ncanceled flag   =>  returnValue设置false 会导致这里是false | preventDefault\r\n\r\nin passive listener flag    =>  passive是在addEventListener的第三个config里面可以设置\r\n\r\ncomposed flag   =>  用来指示该事件是否可以从 Shadow DOM 传递到一般的 DOM\r\n\r\ninitialized flag    没有理解\r\n\r\ndispatch flag",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMwODg2MTc=",
    "number": 557,
    "title": "【Q543】什么是事件冒泡和事件捕获",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_ks_S",
          "body": "个人记录\r\n[事件冒泡与事件捕获](https://github.com/CsongL/javaScript-learning/blob/main/interviewJs/BrowserDom/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.md)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CsongL",
            "url": "https://github.com/CsongL"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMwODkwNjg=",
    "number": 558,
    "title": "【Q544】什么是事件委托，e.currentTarget 与 e.target 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTEzMTMyNA==",
          "body": "![](https://static.shanyue.tech/images/23-02-11/clipboard-0095.c66057.webp)\r\n\r\n事件委托指当有大量子元素触发事件时，将事件监听器绑定在父元素进行监听，此时数百个事件监听器变为了一个监听器，提升了网页性能。\r\n\r\n另外，React 把所有事件委托在 Root Element，用以提升性能。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1NTY5NDk5Ng==",
          "body": "666",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiutian00",
            "url": "https://github.com/qiutian00"
          }
        },
        {
          "id": "IC_kwDODQzyOs46epaG",
          "body": "[event.currentTarget](https://developer.mozilla.org/zh-CN/docs/Web/API/Event/currentTarget)\r\n\r\n> Event 接口的只读属性 currentTarget 表示的，标识是当事件沿着 DOM 触发时事件的当前目标。它总是指向事件绑定的元素，而 Event.target 则是事件触发的元素。\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nmsn",
            "url": "https://github.com/nmsn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMxMDQ2MDc=",
    "number": 559,
    "title": "【Q545】关于事件捕获和冒泡，以下代码输出多少",
    "body": "> 代码见: [事件捕获和冒泡 - Codepen](https://codepen.io/shanyue/pen/gOmxmqw?editors=1011)\r\n\r\n以下代码输出多少:\r\n\r\n``` html\r\n<div class=\"container\" id=\"container\">\r\n  <div class=\"item\" id=\"item\">\r\n    <div class=\"btn\" id=\"btn\">\r\n      Click me\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n``` js\r\ndocument.addEventListener('click', (e) => {\r\n  console.log('Document click')\r\n}, {\r\n  capture: true\r\n})\r\n\r\ncontainer.addEventListener('click', (e) => {\r\n  console.log('Container click')\r\n  // e.stopPropagation()\r\n}, {\r\n  capture: true\r\n})\r\n\r\nitem.addEventListener('click', () => {\r\n  console.log('Item click')\r\n})\r\n\r\nbtn.addEventListener('click', () => {\r\n  console.log('Btn click')\r\n})\r\n\r\nbtn.addEventListener('click', () => {\r\n  console.log('Btn click When Capture')\r\n}, {\r\n  capture: true\r\n})\r\n\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTczOTIwMw==",
          "body": "``` js\r\nDocument click\r\nContainer click\r\nBtn click When Capture\r\nBtn click\r\nItem click\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JyYZh",
          "body": "html\r\n```html\r\n<div id=\"s1\">s1\r\n  <div id=\"s2\">s2</div>\r\n</div>\r\n```\r\ncss\r\n```css\r\n#s1 {\r\n  width: 200px;\r\n  height: 200px;\r\n  background-color: burlywood;\r\n  overflow: hidden;\r\n}\r\n#s2 {\r\n  width: 100px;\r\n  height: 100px;\r\n  background-color: aquamarine;\r\n  margin: 50px;\r\n}\r\n```\r\njs\r\n```js\r\nlet s1 = document.getElementById('s1');\r\nlet s2 = document.getElementById('s2');\r\n\r\ns2.onclick = function () {\r\n  console.log('s2 click1')\r\n}\r\ns1.addEventListener(\"click\", function (e) {\r\n  console.log(\"s1 冒泡事件\");\r\n}, false);\r\ns2.addEventListener(\"click\", function (e) {\r\n  console.log(\"s2 冒泡事件2\");\r\n}, false);\r\ns2.addEventListener(\"click\", function (e) {\r\n  console.log(\"s2 冒泡事件1\");\r\n}, false);\r\ns1.addEventListener(\"click\", function (e) {\r\n  console.log(\"s1 捕获事件\");\r\n}, true);\r\ns2.addEventListener(\"click\", function (e) {\r\n  console.log(\"s2 捕获事件\");\r\n}, true);\r\ns2.onclick = function () {\r\n  console.log('s2 click2')\r\n}\r\n```\r\n结果输出\r\n```\r\ns1 捕获事件\r\ns2 捕获事件\r\ns2 click2\r\ns2 冒泡事件2\r\ns2 冒泡事件1\r\ns1 冒泡事件\r\n```\r\n小结：\r\n总顺序：捕获事件 ==> 冒泡事件(addEventListener) 或 on事件\r\n冒泡事件addEventListener 和 on事件的执行顺序：按照定义时的顺序执行(书写代码的先后)\r\n并且，冒泡事件addEventListener不会覆盖，有多少个事件就执行多少个，按顺序执行\r\n而，相同的on事件会覆盖，后面的覆盖前面的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMxMTUxODU=",
    "number": 560,
    "title": "【Q546】浏览器中 cookie 有哪些字段",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDc3MDYyMA==",
          "body": "+ Domain\r\n+ Path\r\n+ Expire/MaxAge\r\n+ HttpOnly\r\n+ Secure\r\n+ SameSite",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDMxODM5Mjg=",
    "number": 561,
    "title": "【Q547】某元素的 fontSize: 2rem; lineHeight: 1.5em; 此时 lineHeight 为多少像素",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs493bJQ",
          "body": "font-size: 2rem. ---->  则该元素默认情况下，font-size: 32px\r\nline-height: 1.5em, em相对于自身元素的font-size， 则 \r\nline-height: 1.5 * 32 === 48px",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HunterXing",
            "url": "https://github.com/HunterXing"
          }
        },
        {
          "id": "IC_kwDODQzyOs5UC4TM",
          "body": "rem是相对长度单位，相对于根元素。\r\nem也是相对长度单位，相对于父元素。\r\n浏览器默认 1rem = 16px\r\n所以font-size : 2rem = 2 * 16px = 32px\r\nline-height: 1.5em ，em相对于父元素的font-size (32px)  ==> line-height: 1.5em = 1.5 * 32 = 48px",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liuerhost",
            "url": "https://github.com/liuerhost"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDM1MDgzNjI=",
    "number": 562,
    "title": "【Q548】DOM 中 Element 与 Node 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40sZJ3",
          "body": "Element是dom元素，Node是节点，包含Element，还有其他节点",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs40s-MF",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400a7M",
          "body": "> Element是dom元素，Node是节点，包含Element，还有其他节点\r\n\r\nElement 继承于 Node，具有Node的方法，同时又拓展了很多自己的特有方法",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400a_E",
          "body": "[浅析Node与Element的区别\r\n](https://zhuanlan.zhihu.com/p/165422508)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ0MzU2MTQ=",
    "number": 563,
    "title": "【Q549】如何判断某一个值是数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTcyODYwMg==",
          "body": "完美实现一个月下载量超过一个亿的包: [isarray](https://npm.devtool.tech/isarray)\r\n\r\n``` js\r\nconst isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs442A-C",
          "body": "a instanceof Array",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs442BEe",
          "body": "const a = [];\r\nconsole.log(a.constructor == Array);//true",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DwDso",
          "body": "arr.__proto__ === Array.prototype",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lkzwc",
            "url": "https://github.com/lkzwc"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JR-j5",
          "body": "```javascript\r\n// 理论上这个足够用了，又简洁又有效\r\nArray.isArray()\r\n// 补充个评论里没有的\r\nObject.prototype.toString.call([]).slice(8, -1) === 'Array'\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VljzM",
          "body": "> const a = []; console.log(a.constructor == Array);//true\r\n\r\nconstructor的值可以被修改 所以这种判断方式不太妥",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "sisipyhus",
            "url": "https://github.com/sisipyhus"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VlkK8",
          "body": "> 完美实现一个月下载量超过一个亿的包: [isarray](https://npm.devtool.tech/isarray)\r\n> \r\n> ```js\r\n> const isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'\r\n> ```\r\n运算符|| 后面需要加上 （）将函数包裹 不然会报错\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "sisipyhus",
            "url": "https://github.com/sisipyhus"
          }
        },
        {
          "id": "IC_kwDODQzyOs5fXQxO",
          "body": "const isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DyCoder2015",
            "url": "https://github.com/DyCoder2015"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ0NDg1MDI=",
    "number": 564,
    "title": "【Q550】简述 Object.defineProperty ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDA3MDI5Nw==",
          "body": "与直接为一个对象的属性赋值(`o.a = 3`)不同，`Object.defineProperty` 可更为精确，拥有更多选项地为对象属性赋值\r\n\r\n属性描述符拥有两种: 数据描述符与存取描述符\r\n\r\n## 数据描述符 (data descriptor)\r\n\r\n决定该属性值是否可写\r\n\r\n``` js\r\nconst o = {}\r\nObject.defineProperty(o, 'a', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  writable: true,\r\n  value: 3,\r\n})\r\n```\r\n\r\n+ `configurable`: 是否可被删除\r\n+ `enumerable`: 是否可被枚举，不可枚举属性无法通过 `Object.keys` 获取到\r\n+ `writable`: 是否可更改该属性值\r\n+ `value`: 该属性值的值\r\n\r\n当我们使用赋值运算符为对象添加属性时，实际上是添加了一个数据描述符\r\n\r\n``` js\r\n> o.c = 5\r\n> Object.getOwnPropertyDescriptor(o, 'c')\r\n< {value: 5, writable: true, enumerable: true, configurable: true}\r\n```\r\n\r\n## 存取描述符 (accessor descriptor)\r\n\r\n可对对象属性进行拦截，Vue2 的数据绑定原理便是基于此\r\n\r\n``` js\r\nconst o = {}\r\nObject.defineProperty(o, 'a', {\r\n  configurable: false,\r\n  enumerable: false,\r\n  get () {\r\n     return this._a\r\n  },\r\n  set (a) {\r\n    this._a = a * 10\r\n  }\r\n})\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ1NzE2Nzk=",
    "number": 565,
    "title": "【Q551】Object.keys 与 Object.getOwnPropertyNames() 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTcyNzE3NQ==",
          "body": "+ `Object.keys`: 列出可枚举的属性值\r\n+ `Object.getOwnPropertyNames`: 列出所有属性值(包括可枚举与不可枚举)\r\n\r\n同时 `Object.defineProperty` 中的选项  `enumerable` 可定义属性是否可枚举",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ1OTExODM=",
    "number": 566,
    "title": "【Q552】关于 setState 以下代码的输出",
    "body": "代码如下所示，每次切换 TODO 状态时，通过手动修改 `todo.status` 再 setTodo，此时是否会修改成功\r\n\r\n> 代码见 [setState - codesandbox](https://codesandbox.io/s/setstate-r7qof?file=/src/App.js)\r\n\r\n``` js\r\nimport { useState } from \"react\";\r\n\r\nexport default function App() {\r\n  const [todo, setTodo] = useState({ id: 1, status: \"TODO\" });\r\n  return (\r\n    <div className=\"App\">\r\n      <button\r\n        onClick={() => {\r\n          todo.status = !todo.status;\r\n          setTodo(todo);\r\n        }}\r\n      >\r\n        Toggle Status\r\n      </button>\r\n      <h1>{todo.status}</h1>\r\n    </div>\r\n  );\r\n}\r\n\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5BB9q7",
          "body": "state是只读的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hellolukeding",
            "url": "https://github.com/hellolukeding"
          }
        },
        {
          "id": "IC_kwDODQzyOs5HupK6",
          "body": "补充一点：与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "YuVincentxuan",
            "url": "https://github.com/YuVincentxuan"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ2NDMyOTI=",
    "number": 567,
    "title": "【Q553】Grid 布局的优势在哪里",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDk3NzU4MQ==",
          "body": "Flex 布局是轴线布局，只能指定\"项目\"针对轴线的位置，可以看作是一维布局。\r\nGrid 布局则是将容器划分成\"行\"和\"列\"，产生单元格，然后指定\"项目所在\"的单元格，可以看作是二维布局。\r\nGrid 布局远比 Flex 布局强大    \r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDk5NTcxNw==",
          "body": "响应式！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDQ5OTM5MTc=",
    "number": 569,
    "title": "【Q554】SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDkxODczNw==",
          "body": "> 见文档 [SameSite Cookie - MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)\r\n> 见文章 [Cookie 的 SameSite 属性](http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)\r\n\r\n+ None: 任何情况下都会向第三方网站请求发送 Cookie\r\n+ Lax: 只有导航到第三方网站的 Get 链接会发送 Cookie，跨域的图片、iframe、form表单都不会发送 Cookie\r\n+ Strict: 任何情况下都不会向第三方网站请求发送Cookie\r\n\r\n目前，主流浏览器 Same-Site 的默认值为 `Lax`，而在以前是 `None`，将会预防大部分 CSRF 攻击，如果需要手动指定 `Same-Site` 为 `None`，需要指定 Cookie 属性 `Secure`，即在 https 下发送",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDUwMzU1NjE=",
    "number": 570,
    "title": "【Q555】sessionStorage与localStorage有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46Wy2P",
          "body": "localStorage生命周期是永久除非自主清除\r\nsessionStorage生命周期为当前窗口或标签页，关闭窗口或标签页则会清除数据\r\n\r\n他们均只能存储字符串类型的对象\r\n\r\n不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。\r\n[https://www.php.cn/faq/463215.html](https://www.php.cn/faq/463215.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDUwMzY2MDA=",
    "number": 571,
    "title": "【Q556】如何封装一个支持过期时间的 localStorage",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4270sX",
          "body": "```javascript\r\n\r\nfunction initLocalStorage () {\r\n    localStorage.setItem = function (key, value, time = 1000) {\r\n        const expiresTime = Date.now() + time * 1000\r\n        const payload = {\r\n            __data: value,\r\n            __expiresTime: expiresTime,\r\n        }\r\n        Storage.prototype.setItem.call(localStorage, key, JSON.stringify(payload))\r\n    }\r\n    localStorage.getItem = function (key) {\r\n        const value = Storage.prototype.getItem.call(localStorage, key)\r\n        if (typeof value === 'string') {\r\n            const jsonVal = JSON.parse(value)\r\n            if (jsonVal.__expiresTime) {\r\n                if (jsonVal.__expiresTime >= Date.now()) {\r\n                    return JSON.stringify(jsonVal.__data)\r\n                } else {\r\n                    return null\r\n                }\r\n            }\r\n        }\r\n        return value\r\n    }\r\n\r\n}\r\ninitLocalStorage()\r\n\r\n```\r\n\r\n想了下 只能去改api 去封装一层 不过存在一个问题就是别人在使用的时候 也需要遵循这个规则  没想到别的办法",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VBxoQ",
          "body": "设置如下数据结构，当用户存储数据时，存储至 `__value` 字段。并将过期时间存储至 `__expires` 字段。\r\n\r\n``` js\r\n{  __value, __expires }\r\n```\r\n\r\n而当每次获取数据时，判断当前时间是否已超过 `__expires` 过期时间，如果超过，则返回 `undefined`，并删除该数据。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Zx3vk",
          "body": "@heretic-G 简单改了下，支持 `localStorage` 默认的用法，只有传入时间过期才生效：\r\n```js\r\n;(function () {\r\n    localStorage.setItem = function (key, value, time = Infinity) {\r\n        const payload = Number.isFinite(time)\r\n            ? {\r\n                __data: value,\r\n                __expiresTime: Date.now() + time\r\n            }\r\n            : value\r\n        Storage.prototype.setItem.call(\r\n            localStorage,\r\n            key,\r\n            JSON.stringify(payload)\r\n        )\r\n    }\r\n    localStorage.getItem = function (key) {\r\n        const value = Storage.prototype.getItem.call(localStorage, key)\r\n        try {\r\n            const jsonVal = JSON.parse(value)\r\n            if (jsonVal.__expiresTime) {\r\n               return jsonVal.__expiresTime >= Date.now()\r\n                   ? JSON.stringify(jsonVal.__data)\r\n                   : void(0)\r\n            }\r\n            return value\r\n        } catch (error) {\r\n            return value\r\n        }\r\n    }\r\n})()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDYyOTUzMTc=",
    "number": 572,
    "title": "【Q557】如何实现三列均分布局",
    "body": "布局代码如下所示，可见 [三列均分布局 - codepen](https://codepen.io/shanyue/pen/yLMzxqX)\r\n\r\n> 注: 在第一个元素中设置文字，子元素不能因文字过长而挤压。\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"item\">白日依山尽，黄河入海流。欲穷千里目，更上一层楼。</div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n</div>\r\n```\r\n\r\n``` css\r\n\r\n// 以下为样式代码，非核心功能代码\r\n* {\r\n  box-sizing: border-box;\r\n}\r\n\r\n.container {\r\n  background-color: #eee;\r\n  height: 10rem;\r\n  width: 40rem;\r\n  margin: 1rem;\r\n}\r\n\r\n.item {\r\n  border: 1px solid #888;\r\n}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDc1NDIyMA==",
          "body": "见代码 [三均分布局 - Codepen](https://codepen.io/shanyue/pen/yLMzxqX)\r\n\r\n## 使用 Flex\r\n\r\n注意使用 `calc(100% / 3)` 设置 `flex-basis`，同时它的缺陷是**不能够很好的为子元素设置左右间隙**\r\n\r\n``` scss\r\n.flex-container {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  // gap: 1rem;\r\n  \r\n  \r\n  .item {\r\n   flex: 0 0 calc(100% / 3);\r\n  }\r\n}\r\n```\r\n\r\n> 注意: 如果同时给子元素使用 `flex-grow: 1` 控制均分，当子元素拥有文字等内容时，会受到挤压，将无法实现均分布局。\r\n\r\n## 使用 Grid\r\n\r\n使用 Grid 直接操作容器即可，对于子元素之间的间隙也可以很好地控制，可看出 Grid 更为简单，更为高效，更为精确\r\n\r\n``` scss\r\n.grid-container {\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr 1fr;\r\n  gap: 1rem;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5UC6RV",
          "body": "      * {\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        .container {\r\n            background-color: #eee;\r\n            height: 10rem;\r\n            width: 40rem;\r\n            margin: 1rem;\r\n            display: flex;\r\n        }\r\n\r\n        .item {\r\n            flex: 1;\r\n            border: 1px solid #888;\r\n        }",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liuerhost",
            "url": "https://github.com/liuerhost"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY1OTcxMTM=",
    "number": 573,
    "title": "【Q558】如何统计当前页面出现的所有标签",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDkyMzU2OA==",
          "body": "+ `document.querySelectorAll('*')`\r\n+ `document.getElementsByTagName('*')`\r\n+ `$$('*')`，可在浏览器控制台使用\r\n+ `document.all`，已废弃，不建议使用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5q95Pz",
          "body": "`new Set($$('*').map(it => it.tagName.toLowerCase()))`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Si3ver",
            "url": "https://github.com/Si3ver"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2MDAwNjU=",
    "number": 574,
    "title": "【Q559】如何监听 localStorage 的变动",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400ajV",
          "body": "[StorageEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent)\r\n\r\n[https://caniuse.com/?search=StorageEvent](https://caniuse.com/?search=StorageEvent)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400amT",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs401G1O",
          "body": "window.onstorage\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2MTExNDA=",
    "number": 575,
    "title": "【Q560】Data URL 的应用场景及如何生成",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDkzMTIzMg==",
          "body": "Data URLs 由四个部分组成：\r\n\r\n1. 前缀(data:)\r\n2. 指示数据类型的MIME类型\r\n3. 如果二进制数据则为可选的base64标记，比如图片\r\n4. 数据\r\n\r\n\r\n```\r\ndata:[<mediatype>][;base64],<data>\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40sY11",
          "body": "1. base数据\r\n2. 生成设备指纹",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2Nzk3MTM=",
    "number": 576,
    "title": "【Q561】实现一个 inherits 函数进行继承",
    "body": "使用方法如 `inherits(Dog, Animal);`，`Dog` 对 `Animal` 进行了继承",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTg2Mzk2Ng==",
          "body": "``` js\r\nfunction inherits(SuperType, SubType) {\r\n  const pro = Object.create(SuperType.prototype);\r\n  pro.constructor = SubType;\r\n  SubType.prototype = pro;\r\n}\r\nfunction SuperType(friends) {\r\n  this.friends = friends;\r\n}\r\nSuperType.prototype.getFriends = function() {\r\n  console.log(this.friends);\r\n}\r\nfunction SubType(name, friends) {\r\n  this.name = name;\r\n  SuperType.call(this, friends);\r\n}\r\ninherits(SuperType, SubType);\r\nSubType.prototype.getName = function() {\r\n  console.log(this.name);\r\n}\r\n\r\nconst tom = new SubType('tom', ['jerry']);\r\ntom.getName();\r\n// 'tom'\r\ntom.getFriends();\r\n// ['jerry']\r\ntom.friends.push('jack');\r\ntom.getFriends();\r\n// ['jerry', 'jack']\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aaM",
          "body": "```js\r\nfunction objectCreate(prototype) {\r\n  const F = function() {};\r\n  F.prototype = prototype || Object.prototype;\r\n  return new F();\r\n}\r\nfunction inheritPrototype(child, parent) {\r\n  child.prototype = objectCreate(parent.prototype);\r\n  child.prototype.constructor = child;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400amr",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2ODA0ODY=",
    "number": 577,
    "title": "【Q562】WeakMap 与垃圾回收有何关系",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTcyNTU3NA==",
          "body": "`WeakMap` 与 `Map` 有亮点不同\r\n\r\n1. 键值只能为引用对象，无法使用基础数据类型\r\n2. 弱引用，无法枚举，因此无 `.entries()` 方法",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4412yx",
          "body": "WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDY2OTE2NjE=",
    "number": 578,
    "title": "【Q563】什么是媒体查询，JS 可以监听媒体查询吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400Z-K",
          "body": "[MediaQueryList](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aHe",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JtVdx",
          "body": "![image](https://user-images.githubusercontent.com/101323067/188387499-1c5b9091-f7f6-40c0-98ca-e176ab474389.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ethanlamm",
            "url": "https://github.com/ethanlamm"
          }
        },
        {
          "id": "IC_kwDODQzyOs5L4Mpo",
          "body": "js也支持媒体查询，window. matchMedia()方法，参考文章：https://cloud.tencent.com/developer/article/2061082",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "renjianliuwang",
            "url": "https://github.com/renjianliuwang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDc3NzM2MTc=",
    "number": 579,
    "title": "【Q564】z-index: 999 元素一定会置于 z-index: 0 元素之上吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTczMjUzNQ==",
          "body": "代码见 [zindex - codepen](https://codepen.io/shanyue/pen/XWMVpxJ)\r\n\r\n不一定，更复杂的示例见 [层叠上下文 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VzmYJ",
          "body": "不一定 需要考虑到是否在同一个元素层级中 不然z-index的值有限制",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "sisipyhus",
            "url": "https://github.com/sisipyhus"
          }
        },
        {
          "id": "IC_kwDODQzyOs5nSEE5",
          "body": "z-index高数值不一定在低数值前面，因为有层叠上下文的概念。当处于两个兄弟层叠上下文时，子元素的层级显示不决定于自身的z-index，而取决于父级的z-index",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Minf97",
            "url": "https://github.com/Minf97"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDc3OTQ0OTE=",
    "number": 580,
    "title": "【Q565】浏览器中事件有哪些属性与方法",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDc3OTkwOTQ=",
    "number": 581,
    "title": "【Q566】关于块级作用域，以下代码输出多少，在何时间输出",
    "body": "``` js\r\nfor (var i = 0; i < 5; i++) {\r\n  setTimeout(() => console.log(i), 1000)\r\n}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTc1MDM2OQ==",
          "body": "一秒之后连续输出五个5，以下可输出预期效果\r\n\r\n``` js\r\nfor (let i = 0; i < 5; i++) {\r\n  setTimeout(() => console.log(i), 1000 * i)\r\n}\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n  setTimeout(console.log, 1000 * i, i)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTg0ODIxOQ==",
          "body": "> 一秒之后连续输出五个5，以下可输出预期效果\r\n> \r\n> ```js\r\n> for (let i = 0; i < 5; i++) {\r\n>   setTimeout(() => console.log(i), 1000 * i)\r\n> }\r\n> \r\n> for (var i = 0; i < 5; i++) {\r\n>   setTimeout(console.log, 1000 * i, i)\r\n> }\r\n> ```\r\n\r\n为什么setTimeout格式不同,输出的结果也不同.例如:当for循环采用var声明变量,但setTimeout(console.log,1000*i,i)与setTimeout(()=>console.log(i),0)输出的结果不一样. \r\n\r\n是因为函数作用域?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "aotushi",
            "url": "https://github.com/aotushi"
          }
        },
        {
          "id": "IC_kwDODQzyOs44UYXq",
          "body": "第一种使用var的方式:\r\n```javascript\r\nfor (var i = 0; i < 5; i++) {\r\n  setTimeout(() => console.log(i), 1000)\r\n}\r\n```\r\n第二种使用var的方式:\r\n```javascript\r\nfor (var i = 0; i < 5; i++) {\r\n  setTimeout(console.log, 1000 * i, i)\r\n}\r\n```\r\n\r\nvar 声明的变量是在函数作用域或者全局作用域的，在第一种方式中，由于setTimeout是异步执行，且它是从闭包中获取 i 变量，由于 i 是在函数/全局作用域中声明的，所以5次循环中 i 不断被赋值，最后 i 的值为5，执行的结果为连续的5个5。\r\n\r\n在第二种方式中，通过给setTimeout的回调函数传参的方式，保存了每次循环中 i 的值，因此执行结果符合预期\r\n\r\nlet声明的变量是在块级作用域(花括号)中的，因此可以认为每次执行循环语句块中的 i 变量是互相独立的，所以执行结果也符合预期",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDkwMTg2NTU=",
    "number": 582,
    "title": "【Q567】如何逆序一个字符串",
    "body": "可以使用 `Array.prototype.reverse.call(s)` 逆序字符串吗",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MjY3MTQwOA==",
          "body": "可以直接调用 API 进行实现:\r\n\r\n``` js\r\nconst reverse = s => s.split('').reverse().join('')\r\n\r\nreverse('hello')\r\n//=> \"olleh\"\r\n```\r\n\r\n如果不调用 API 实现的话，参考以下代码:\r\n\r\n``` js\r\nfunction reverse (s) {\r\n  let r = ''\r\n  for (const c of s) {\r\n    r = c + r\r\n  }\r\n  return r\r\n}\r\n\r\nreverse('hello')\r\n//=> \"olleh\"\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDkwMjU3NjU=",
    "number": 583,
    "title": "【Q568】为何 0.1+0.2 不等于 0.3，应如何做相等比较",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MjY3NTEwMA==",
          "body": "0.1，0.2 表示为二进制会有精度的损失，比较时可引入一个很小的数值 `Number.EPSILON` 容忍误差，其值为 2^-52。\r\n\r\n``` js\r\nfunction equal (a, b) {\r\n  return Math.abs(a - b) < Number.EPSILON\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44ynBt",
          "body": "https://zhuanlan.zhihu.com/p/87672024",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs44ynGM",
          "body": "十进制转二进制计算后再转十进制输出导致的误差",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JR-zZ",
          "body": "```javascript\r\nfunction add(n1 , n2){\r\n    // ...省略参数类型判断及容错代码\r\n    const nums1Digits = n1.toString().split('.')[1].length\r\n    const nums2Digits = n2.toString().split('.')[1].length\r\n    const baseNum = Math.pow(10, Math.max(nums1Digits , nums2Digits))\r\n    // 或者用10 ** Math.max(nums1Digits , nums2Digits)\r\n    return (n1 * baseNum + n2 * baseNum) / baseNum\r\n}\r\n\r\nconsole.log(0.1 + 0.2) // 0.30000000000000004\r\nconsole.log(add(0.1, 0.2)) // 0.3\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDkwMjg5ODk=",
    "number": 584,
    "title": "【Q569】关于 this 与包装对象，以下输出多少",
    "body": "``` js\r\nfunction foo() {\r\n  console.log(this)\r\n}\r\n\r\nfoo.call(3);\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTg4MjM3Mw==",
          "body": "如果处于非严格模式下，要绑定的`this`指定为`null`或`undefined`时会自动替换为全局对象，原始值则会被包装\r\n\r\n严格模式：\r\n``` js\r\n'use strict';\r\n\r\nfunction test() {\r\n    console.log(this)\r\n}\r\n\r\ntest.call(2)\r\n// 2\r\n```\r\n\r\n非严格模式\r\n``` js\r\nfunction test() {\r\n    console.log(this)\r\n}\r\ntest.call(2)\r\n// Number {2}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MDk0NDM2NTY=",
    "number": 585,
    "title": "【Q570】浏览器中如何读取二进制信息",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400ZKl",
          "body": "[二进制数据，文件](https://zh.javascript.info/binary)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aHG",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMDg0MzM=",
    "number": 586,
    "title": "【Q571】关于类型转化，判断以下代码输出",
    "body": "``` js\r\nBoolean(new Boolean(false));\r\nBoolean(document.all);\r\n\r\n[] == '';\r\n[3] == 3;\r\n[] == false;\r\n42 == true;\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjMwMDA5Mg==",
          "body": "在`==`时，会强制类型转换并比较转换后的结果\r\n\r\n比较过程如下：\r\n\r\n- 如果两个变量都是对象，则当都引用同一对象时才返回`true`\r\n- `null == undefined` ? 返回`true`\r\n- 当两个变量类型不一致时会进行类型转换：\r\n    - `string == number` ? `string`转换为`number`后再进行比较\r\n    - `boolean == any` ? `boolean`转换为`number`后再进行比较\r\n    - `object == string/number/symbol` ? 尝试调用`object`的`valueOf`或`toString`将其转换为原始类型后再进行比较\r\n- 当两个变量类型一致时：\r\n    - `number == number` ? 其中有一个为`NaN`时返回`false`; `+0 == -0`时返回`true`\r\n \r\n![非原创，原作者未知](https://user-images.githubusercontent.com/38256126/124141063-a5c7b400-dabb-11eb-8a8c-2f9503f9f06e.png)\r\n\r\n所以`[] == 0`时：\r\n\r\n1. `[]`先调用`Array.prototype.toString`转为原始值\r\n\r\n``` js\r\nArray.prototype.toString.call([])\r\n// \"\"\r\n```\r\n\r\n2. `\"\" == 0`，`\"\"`转为`number`即0\r\n\r\n3. `0 == 0`，返回`true`\r\n\r\n其他几行代码同理\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mrrs878",
            "url": "https://github.com/mrrs878"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JR_of",
          "body": "```javascript\r\n[] == \"\";\r\n// 1. [].toString() => \"\"\r\n// 2. \"\" == \"\"\r\n// 3. Number(\"\") => 0\r\n// 4. 0 == 0 => true\r\n\r\n[3] == 3;\r\n// 1. [3].toString() => \"3\"\r\n// 2. \"3\" == 3\r\n// 3. Number(\"3\") => 3\r\n// 4. 3 == 3 => true\r\n\r\n[] == false;\r\n// 1. [].toString() => \"\"\r\n// 2. \"\" == false\r\n// 3. Number(\"\") => 0   Number(false) => 0\r\n// 4. 0 == 0 => true\r\n\r\n42 == true;\r\n// 1. Number(true) => 1\r\n// 2. 42 == 1 => false\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        },
        {
          "id": "IC_kwDODQzyOs5yrtUb",
          "body": "当 Boolean() 作为构造函数调用时，将创建 [Boolean] 对象，它不是一个原始值。\r\n\r\n当 Boolean() 作为普通函数调用时（不使用 new），它将参数强制转换为布尔原始值。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yaochiqkl",
            "url": "https://github.com/yaochiqkl"
          }
        },
        {
          "id": "IC_kwDODQzyOs5yrtlI",
          "body": "这是来自QQ邮箱的假期自动回复邮件。你好，我最近正在休假中，无法亲自回复你的邮件。我将在假期结束后，尽快给你回复。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "loveminxo",
            "url": "https://github.com/loveminxo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMjM2OTI=",
    "number": 587,
    "title": "【Q572】关于暂时性死域，判断以下代码输出",
    "body": "**第一段代码如下**\r\n\r\n``` js\r\nvar a = 3;\r\nlet a;\r\n```\r\n\r\n**第二段代码如下**\r\n\r\n``` js\r\nvar x = 3;\r\n\r\nfunction foo (x=x) {\r\n    // ..\r\n}\r\n\r\nfoo()\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41F7m1",
          "body": "暂时性死域的问题，对于 `let`/`const` 声明变量之前被使用的话会报错",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMzYxOTY=",
    "number": 588,
    "title": "【Q573】关于词法作用域，判断以下代码输出",
    "body": "``` js\r\nvar scope = 'global scope';\r\nfunction checkScope () {\r\n  var scope = 'local scope';\r\n  function f() {\r\n    return scope; \r\n  }\r\n  return f;\r\n}\r\n\r\ncheckScope()();\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzUxNTQ2Ng==",
          "body": "`local scope`\r\n\r\n由于 js 为词法作用域(Lexical Scope)，访问某个变量时，先在当前作用域中查找，如果查找不到则在嵌套作用域中查找，直到找到。如果找不到，则报 ReferenceError。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwMzY5Mjk=",
    "number": 589,
    "title": "【Q574】关于 this，判断以下代码输出",
    "body": "``` js\r\nfunction foo() {\r\n  console.log( this.a );\r\n}\r\n\r\nvar a = 2;\r\n\r\n(function(){\r\n  \"use strict\";\r\n\r\n  foo();\r\n})();\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzUxOTcwMQ==",
          "body": "输出: 2\r\n\r\n**只有在存在 this 的函数中设置严格模式**，this 为 undefined。因此此时会正常输出。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5GiHxl",
          "body": "山月老师，应该是“**只有在存在 this 的函数前设置严格模式**，this为undefined。”才对。\r\n```\r\n\"use strict\";\r\nfunction foo() {\r\n  console.log( this.a );\r\n}\r\n\r\nvar a = 2;\r\n\r\n(function(){\r\n  foo();\r\n})();\r\n```\r\n按以上代码执行，函数`foo`中的`this`就不能指向`window`了。\r\n不应该只是在函数中，在函数前设置*严格模式*，`this`为`undefined`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ridershoot",
            "url": "https://github.com/ridershoot"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTAwNjQwMjQ=",
    "number": 590,
    "title": "【Q575】关于 new，判断以下代码输出",
    "body": "``` js\r\nfunction F () {\r\n  this.a = 3;\r\n  return {\r\n    a: 4;\r\n  }\r\n}\r\n\r\nconst f = new F();\r\nconsole.log(f.a);\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzYyNDUzOA==",
          "body": "输出 4\r\nnew 操作符，默认返回this对象。如果手动指定返回对象，则new出来的实例指向的是return的对象，而不是this",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hsk863hh",
            "url": "https://github.com/hsk863hh"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1MzY5NTUyMA==",
          "body": "`4`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Yod-W",
          "body": "> ```js\r\n> function F () {\r\n>   this.a = 3;\r\n>   return {\r\n>     a: 4;\r\n>   }\r\n> }\r\n> \r\n> const f = new F();\r\n> console.log(f.a);\r\n> ```\r\n\r\n返回多了一个分号，报错。去掉分号就是输出4，因为构造函数返回了对象\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yxw007",
            "url": "https://github.com/yxw007"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTA5ODU2NDQ=",
    "number": 591,
    "title": "【Q576】如何正确得知某张图片的 MIME 格式",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTA5ODY4MzE=",
    "number": 592,
    "title": "【Q577】关于简单的事件循环，判断以下代码输出",
    "body": "判断以下代码输出次序\r\n\r\n``` js\r\nsetTimeout(() => console.log('A'))\r\n\r\nPromise.resolve().then(() => console.log('B'))\r\n\r\nconsole.log('C')\r\n```\r\n\r\n[复杂题在此](https://github.com/shfshanyue/Daily-Question/issues/528)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1NDI5MzA5Mw==",
          "body": "`C B A`\r\n\r\nC 在主线程执行栈\r\nB 在microtask\r\nA 在 macrotask",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTMwNTQ0NzA=",
    "number": 594,
    "title": "【Q578】HTTP 响应头 cache-control: s-maxage=0 是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4--qiR",
          "body": "缓存立即失效",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTMwNTgwMzc=",
    "number": 595,
    "title": "【Q579】http 缓存控制中 Cach-Control 为 public 与 private 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODQyOTQ3Nw==",
          "body": "cache-control:默认值是private,\r\nprivite    响应只能为私有缓存，不能在用户间共享\r\npublic    公有缓存，可以在多用户间共享",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OpdNA",
          "body": "具体是什么场景下使用?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "leohxj",
            "url": "https://github.com/leohxj"
          }
        },
        {
          "id": "IC_kwDODQzyOs5rnOpg",
          "body": "HTTP的服务端缓存主要由代理服务器来实现，代理服务器收到源服务器的响应之后将报文转发给客户端的同时也存入自己的cache里，下次再有相同的请求就可以直接发送304或者缓存数据，节省源服务器的成本。\r\n因为代理服务器既是服务端，又是客户端的特性，有一些特殊的cache-control属性：\r\n其中就有 private 跟 public\r\n\r\nprivate：只允许在客户端缓存，不允许在代理服务器上缓存\r\npublic：完全公开，客户端跟代理服务器都可以缓存\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zxw94FE",
            "url": "https://github.com/zxw94FE"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTMwNjE4ODk=",
    "number": 596,
    "title": "【Q580】http 方法 get 与 post 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400Xfm",
          "body": "- GET在浏览器回退时是无害的，而POST会再次提交请求。\r\n\r\n- GET产生的URL地址可以被Bookmark，而POST不可以。\r\n\r\n- GET请求会被浏览器主动cache，而POST不会，除非手动设置。\r\n\r\n- GET请求只能进行url编码，而POST支持多种编码方式。\r\n\r\n- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n\r\n- GET请求在URL中传送的参数是有长度限制的，而POST么有。\r\n\r\n- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\r\n\r\n- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\r\n\r\n- GET参数通过URL传递，POST放在Request body中。\r\n\r\n- **GET产生一个TCP数据包；POST产生两个TCP数据包**。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aCp",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aDb",
          "body": "@haotie1990 GET产生一个TCP数据包；POST产生两个TCP数据包。这句话不准确吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400rqx",
          "body": "> @haotie1990 GET产生一个TCP数据包；POST产生两个TCP数据包。这句话不准确吧\r\n\r\nPOST请求，header和body时分两次发送的\r\n\r\n[https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/](https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTM0ODIxMDM=",
    "number": 597,
    "title": "【Q581】箭头函数和普通函数的区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NDA0MDU5MQ==",
          "body": "箭头函数无 this，无 prototype",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400XFn",
          "body": "箭头函数有几个使用注意点。\r\n\r\n- 箭头函数没有自己的`this`对象。\r\n\r\n- 不可以当作构造函数，也就是说，不可以对箭头函数使用`new`命令，否则会抛出一个错误。\r\n\r\n- 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 `rest `参数代替。\r\n\r\n- 不可以使用`yield`命令，因此箭头函数不能用作 `Generator `函数",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTUxMDI0NzM=",
    "number": 598,
    "title": "【Q582】什么是 URL 编码 (URL Encode)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400W_n",
          "body": "encodeURI用来编码**URI**，其不会编码保留字符：;,/?:@&=+$\r\n\r\nencodeURIComponent用来编码URI**参数**，除了字符：A-Z a-z 0-9 - _ . ! ~ * ' ( )，都将会转义",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aH5",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3MjQ4NDg=",
    "number": 599,
    "title": "【Q583】http 状态码  204 使用在什么场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1NzMzNTYzNQ==",
          "body": "1. `Head Method`\r\n2. `Options Method`\r\n3. 打点",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5qPm2D",
          "body": "> * `Head Method`\r\n> * `Options Method`\r\n> * 打点\r\n\r\n对于HEAD方法和OPTIONS方法，可以使用204状态码作为响应。以下是对每种情况的解释：\r\n\r\nHEAD方法：HEAD方法与GET方法类似，但服务器只返回响应头部信息，而不返回实际的响应主体内容。如果使用HEAD方法进行请求，服务器可以使用204状态码来表示请求已成功处理，但没有响应主体内容。\r\n\r\nOPTIONS方法：OPTIONS方法用于获取服务器支持的HTTP方法列表或特定资源的请求方法选项。当服务器收到OPTIONS请求时，它可以使用204状态码表示请求已成功处理，但没有响应主体内容。服务器可以在响应头部中包含其他相关信息，例如支持的HTTP方法列表或允许的请求头部字段。\r\n\r\n打点请求：打点请求通常需要服务器返回一些数据以进行分析。因此，使用204状态码不适合表示打点请求的结果。为了表示成功处理了打点请求，并且可能还需要返回一些数据，可以考虑使用其他合适的HTTP状态码，如200或201。\r\n\r\n总结而言，对于HEAD和OPTIONS方法，可以使用204状态码表示请求已成功处理且没有响应主体内容。然而，对于打点请求，建议选择其他适合的状态码来表示请求结果，并根据需要返回相关数据。\r\n\r\n-- from chatgpt\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yekezz",
            "url": "https://github.com/yekezz"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3MzAzOTU=",
    "number": 600,
    "title": "【Q584】现代前端应用应如何配置 HTTP 缓存机制",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41KKwb",
          "body": "> 参考: [前端项目中的缓存配置](https://shanyue.tech/frontend-engineering/http-cache.html)\r\n\r\n关于 http 缓存配置的最佳实践为以下两条：\r\n\r\n1. 文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 `Cache-Control: public,max-age=31536000,immutable`\r\n1. 文件路径中不带有 hash 值：协商缓存。大部分为 `public` 下文件。配置响应头 `Cache-Control: no-cache` 与 `etag/last-modified`\r\n\r\n但是当处理永久缓存时，切记不可打包为一个大的 `bundle.js`，此时一行业务代码的改变，将导致整个项目的永久缓存失效，此时需要按代码更新频率分为多个 chunk 进行打包，可细粒度控制缓存。\r\n\r\n![细粒度缓存控制](https://shanyue.tech/assets/img/http-cache-2.182dbd90.png)\r\n\r\n\r\n1. `webpack-runtime`: 应用中的 `webpack` 的版本比较稳定，分离出来，保证长久的永久缓存\r\n1. `react/react-dom`: `react` 的版本更新频次也较低\r\n1. `vendor`: 常用的第三方模块打包在一起，如 `lodash`，`classnames` 基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来\r\n1. `pageA`: A 页面，当 A 页面的组件发生变更后，它的缓存将会失效\r\n1. `pageB`: B 页面\r\n1. `echarts`: 不常用且过大的第三方模块单独打包\r\n1. `mathjax`: 不常用且过大的第三方模块单独打包\r\n1. `jspdf`: 不常用且过大的第三方模块单独打包\r\n\r\n在 `webpack5` 中可以使用以下配置:\r\n\r\n``` js\r\n{\r\n  // Automatically split vendor and commons\r\n  // https://twitter.com/wSokra/status/969633336732905474\r\n  // https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\r\n  splitChunks: {\r\n    chunks: 'all',\r\n  },\r\n  // Keep the runtime chunk separated to enable long term caching\r\n  // https://twitter.com/wSokra/status/969679223278505985\r\n  // https://github.com/facebook/create-react-app/issues/5358\r\n  runtimeChunk: {\r\n    name: entrypoint => `runtime-${entrypoint.name}`,\r\n  },\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5NlM2v",
          "body": "具体在代码里哪里配置呢？都在webpack配置里？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        },
        {
          "id": "IC_kwDODQzyOs5NlOy3",
          "body": "@maya1900 都在 nginx 配置里，见 https://q.shanyue.tech/deploy/cra-route.html#nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\r\n\r\n``` nginx\r\nserver {\r\n    listen       80;\r\n    server_name  localhost;\r\n\r\n    root   /usr/share/nginx/html;\r\n    index  index.html index.htm;\r\n\r\n    location / {\r\n        # 解决单页应用服务端路由的问题\r\n        try_files  $uri $uri/ /index.html;  \r\n\r\n        # 非带 hash 的资源，需要配置 Cache-Control: no-cache，避免浏览器默认为强缓存\r\n        expires -1;\r\n    }\r\n\r\n    location /static {\r\n        # 带 hash 的资源，需要配置长期缓存\r\n        expires 1y;\r\n    }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5NlebS",
          "body": "> @maya1900 都在 nginx 配置里，见 https://q.shanyue.tech/deploy/cra-route.html#nginx-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\r\n> \r\n> ```nginx\r\n> server {\r\n>     listen       80;\r\n>     server_name  localhost;\r\n> \r\n>     root   /usr/share/nginx/html;\r\n>     index  index.html index.htm;\r\n> \r\n>     location / {\r\n>         # 解决单页应用服务端路由的问题\r\n>         try_files  $uri $uri/ /index.html;  \r\n> \r\n>         # 非带 hash 的资源，需要配置 Cache-Control: no-cache，避免浏览器默认为强缓存\r\n>         expires -1;\r\n>     }\r\n> \r\n>     location /static {\r\n>         # 带 hash 的资源，需要配置长期缓存\r\n>         expires 1y;\r\n>     }\r\n> }\r\n> ```\r\n\r\n谢谢月哥！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "maya1900",
            "url": "https://github.com/maya1900"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3NDEyODM=",
    "number": 601,
    "title": "【Q585】如何确保你们的项目开启了 gzip",
    "body": "当你们的项目上线后，如何查看它是否开启了 gzip",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MzU1NzgwNw==",
          "body": "在响应头中查看是否有以下值：\r\n\r\n```  bash\r\ncontent-encoding: gzip\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTU3NDE3Njk=",
    "number": 602,
    "title": "【Q586】HTTP 有哪些常见的请求头和响应头",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTY4MDYwNjM=",
    "number": 603,
    "title": "【Q587】使用 webpack 如何分包",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5CxLJH",
          "body": "webpack中提供了方案4.0之前是：CommonsChunkPlugin 4.0后是optimization.splitChunks",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "MMmaXingXing",
            "url": "https://github.com/MMmaXingXing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTY4MDk0OTA=",
    "number": 604,
    "title": "【Q588】什么是 HSTS ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400WMJ",
          "body": "HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书\r\n\r\n[https://zhuanlan.zhihu.com/p/130946490](https://zhuanlan.zhihu.com/p/130946490)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400anG",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzI4ODg=",
    "number": 605,
    "title": "【Q589】http 中 referer 请求头是做什么的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDUyMzQyNw==",
          "body": "判断该网页的来源地址\r\n\r\n1. 打点\r\n2. 防盗链",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzU1OTA=",
    "number": 606,
    "title": "【Q590】React 中什么是合成事件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1OTYyODg3Nw==",
          "body": "1. 提供统一的 API，抹平各大浏览器差异\r\n2. 所有事件绑定在 React Root Element 进行事件委托",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OdQ_f",
          "body": "react 将所有事件统一映射托管到 FiberRoot，这样做有如下优势：\r\n1. 用户不用再考虑浏览器兼容性问题，可以专心于功能实现\r\n2. 便于对事件的管理，比如新增、删除、修改事件均可在此处做处理",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kizuner-bonely",
            "url": "https://github.com/kizuner-bonely"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzYwODQ=",
    "number": 607,
    "title": "【Q591】什么是纯函数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MTQ3NDQ3OQ==",
          "body": "1. 输出仅由输入决定，每一个固定的输入总是返回相同的输出\r\n2. 不产生副作用\r\n\r\n``` js\r\nfunction push(list, x)  {\r\n  list.push(x);\r\n  return list\r\n}\r\n\r\nconst l = []\r\npush(l, 3)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40sYFf",
          "body": "引用透明",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs4275uT",
          "body": "他只使用或者操作输入的参数 \r\n相同参数输出相同结果\r\n不能存在语义化的副作用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DKt-V",
          "body": "> 1. 输出仅由输入决定，每一个固定的输入总是返回相同的输出\r\n> 2. 不产生副作用\r\n> \r\n> ```js\r\n> function push(list, x)  {\r\n>   list.push(x);\r\n>   return list\r\n> }\r\n> \r\n> const l = []\r\n> push(l, 3)\r\n> ```\r\n\r\n这应该是一个错误的例子吧 这个函数改变了list本身  纯函数应该是不改变外部数据的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxNzcwNzM=",
    "number": 608,
    "title": "【Q592】前端项目中有哪些副作用",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTgxODE1MzU=",
    "number": 609,
    "title": "【Q593】React/Vue 中受控组件与不受控组件的区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTg3MzQ5NDY=",
    "number": 610,
    "title": "【Q594】给数字添加千位符",
    "body": "``` js\r\n//=> '123'\r\nnumberThousands(123)\r\n\r\n//=> '1,234,567'\r\nnumberThousands(1234567)\r\n```\r\n\r\n问题追问：\r\n\r\n+ 如果考虑正负数应该如何处理\r\n+ 如果考虑小数应该如何处理?\r\n\r\n``` js\r\n//=> '123'\r\nnumberThousands(123)\r\n\r\n//=> '1,234,567'\r\nnumberThousands(1234567)\r\n\r\n// 可以处理正负数\r\n// => '-123,456'\r\nnumberThousands(123456)\r\n\r\n// 可以处理小数\r\n// => '-123,456.123456789'\r\nnumberThousands(123456.123456789)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg1OTU3OTMyOA==",
          "body": "千位符替换可由正则 `/(\\d)(?=(\\d\\d\\d)+(?!\\d))/` 进行匹配\r\n\r\n``` js\r\nfunction numberThousands (number, thousandsSeperator = ',') {\r\n  return String(number).replace(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/g, '$1' + thousandsSeperator)\r\n}\r\n```\r\n\r\n删除的正则或许有点复杂，如果对字符串反转，可以来一个简单的正则\r\n\r\n``` js\r\nfunction numberThousands (number, thousandsSeperator = ',') {\r\n  const reverse = str => str.split('').reverse().join('')\r\n  const str = reverse(String(number)).replace(/(\\d\\d\\d)(?=\\d)/g, '$1' + thousandsSeperator)\r\n  return reverse(str)\r\n}\r\n```\r\n\r\n如果你写不出来正则，也可由一段简单的代码实现\r\n\r\n``` js\r\nfunction numberThousands (number, thousandsSeperator = ',') {\r\n  const s = String(number)\r\n  let r = ''\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const seperator = (s.length - i - 1) % 3 ? '' : thousandsSeperator\r\n    r = `${s[i]}${seperator}${r}`\r\n  }\r\n  return r.slice(0, -1)\r\n}\r\n```\r\n\r\n同时，再提供一个取巧的办法：\r\n\r\n``` js\r\nIntl.NumberFormat(undefined, { style: 'decimal', maximumFractionDigits: 20 }).format(number)\r\n\r\nnumber.toLocaleString(undefined, { maximumFractionDigits: 20 })\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40sWFY",
          "body": "\r\n> 如果你写不出来正则，也可由一段简单的代码实现\r\n> \r\n> ```js\r\n> function toString (number, thousandsSeperator = ',') {\r\n>   const s = String(number)\r\n>   let r = ''\r\n>   for (let i = s.length - 1; i >= 0; i--) {\r\n>     const seperator = (s.length - i - 1) % 3 ? '' : thousandsSeperator\r\n>     r = `${s[i]}${seperator}${r}`\r\n>   }\r\n>   return r.slice(0, -1)\r\n> }\r\n> ```\r\n\r\n这个有点问题，如果是带有小数的数字，会有转换异常\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs40sWok",
          "body": "```javascript\r\nfunction toString(number) {\r\n    return number.toLocaleString()\r\n}\r\n```\r\n哈哈哈哈，取个巧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs400WD7",
          "body": "```js\r\nfunction numberThousands(number) {\r\n  const numberStr = String(number);\r\n  let result = '';\r\n  let [interger, decimal] = numberStr.split('.');\r\n  while (interger.length > 3) {\r\n    // 倒数三位数字\r\n    let subStr = interger.substring(interger.length - 3);\r\n    interger = interger.replace(subStr, '');\r\n    result = `,${subStr}${result}`;\r\n  }\r\n  if (interger.length) {\r\n    result = `${interger}${result}`;\r\n  }\r\n  return result + (decimal ? `.${decimal}` : '');\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Cfy7Z",
          "body": "```javascript\r\nfunction numberThousands(num) {\r\n  let result = \"\";\r\n  let str = String(num);\r\n  let length = str.length;\r\n  for (let index = length - 1; index >= 0; index--) {\r\n    const element = str[index];\r\n    result = element + result;\r\n    if (index && (length - index) % 3 == 0) {\r\n      result = \",\" + result;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "VirgoHxy",
            "url": "https://github.com/VirgoHxy"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JbOZe",
          "body": "```js\r\nconst numberThousands = number => {\r\n    const strNum = Number.parseFloat(number).toString();\r\n    const [interSection, restSection] = strNum.split('.');\r\n    const reverseInter = interSection.split('').reverse().join('');\r\n\r\n    const finalInter = reverseInter\r\n        .match((/(\\d{0,3})+?/g))\r\n        .filter(x=>x)\r\n        .map(item => item.split('').reverse().join(''))\r\n        .reverse().join(',');\r\n\r\n    return `${finalInter}${restSection ? `.${restSection}` : ''}`\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bigbigDreamer",
            "url": "https://github.com/bigbigDreamer"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MmQQY",
          "body": "> 删除的正则或许有点复杂，如果对字符串反转，可以来一个简单的正则\r\n> ```js\r\n>  function numberThousands (number, thousandsSeperator = ',') {\r\n>   const reverse = str => str.split('').reverse().join('')\r\n>   const str = reverse(String(number)).replace(/\\d\\d\\d(?!\\d)/g, '$1' + thousandsSeperator)\r\n>   return reverse(str)\r\n> }\r\n```\r\n错了，应该是 ?= 而不是 ?!\r\n```js\r\nfunction numberThousands(number, thousandsSeperator = \",\") {\r\n  const reverse = (str) => str.split(\"\").reverse().join(\"\");\r\n  const str = reverse(String(number)).replace(\r\n    /(\\d\\d\\d)(?=\\d)/g,\r\n    \"$1\" + thousandsSeperator\r\n  );\r\n  return reverse(str);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "okkjoo",
            "url": "https://github.com/okkjoo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTg4ODEyMDI=",
    "number": 611,
    "title": "【Q595】React 中监听 input 的 onChange 事件的原生事件是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MjAxMTI1Mw==",
          "body": "[React 中 onChange 的原生事件是什么？](https://codesandbox.io/s/input-onchange-1ybhw?file=/src/App.js)\r\n\r\n``` js\r\nimport \"./styles.css\";\r\n\r\nexport default function App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <input\r\n        onChange={(e) => {\r\n          console.log(\"Event: \", e);\r\n          console.log(\"NativeEvent: \", e.nativeEvent);\r\n          console.log(\"CurrentTarget: \", e.nativeEvent.currentTarget);\r\n          console.log(\"NativeEvent Type: \", e.nativeEvent.type);\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk1NTIxNDM=",
    "number": 612,
    "title": "【Q596】在浏览器中点击 a 标签保存为文件如何做",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDA1MDI4NA==",
          "body": "有两种方式:\r\n\r\n1. `a.download` 当指定 a 标签的 `download` 属性时，点击该链接会直接保存为文件，文件名为 `download` 属性\r\n1.  通过对 a 标签指定的 URL 在服务器设置响应头 `Content-Disposition: attachment; filename=\"filename.jpg\"` 可直接下载\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk2ODk0NjM=",
    "number": 613,
    "title": "【Q597】引入 BFF 层的优势在哪里",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDEzMzIwOQ==",
          "body": "BFF 全称 `Backend For Frontend`，一般指在前端与服务器端搭建一层由前端维护的 Node Server服务，具有以下好处\r\n\r\n1. 数据处理。对数据进行校验、清洗及格式化。使得数据更与前端契合\r\n2. 数据聚合。后端无需处理大量的表连接工作，第三方接口聚合工作，业务逻辑简化为各个资源的增删改查，由 BFF 层聚合各个资源的数据，后端可集中处理性能问题、监控问题、消息队列等\r\n3. 权限前移。在 BFF 层统一认证鉴权，后端无需做权限校验，后端可直接部署在集群内网，无需向外网暴露服务，减少了后端复杂度。\r\n\r\n但其中也有一些坏处，如以下\r\n\r\n1. 引入复杂度，新的 BFF 服务需要一套基础设施的支持，如日志、异常、部署、监控等",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk3MDUzMzU=",
    "number": 614,
    "title": "【Q598】如何实现一个深比较的函数 deepEqual",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400Vtn",
          "body": "```js\r\nfunction isEqual(x, y) {\r\n  if (x === y) {\r\n    return true;\r\n  } else if ((typeof x === 'object' && x !== null) && (typeof y === 'object' && y !== null)) {\r\n    const keysX = Object.keys(x);\r\n    const keysY = Object.keys(y);\r\n    if (keysX.length !== keysY.length) {\r\n      return false;\r\n    }\r\n    for (const key of keysX) {\r\n      if(!isEqual(x[key], y[key])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400anb",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5qIskE",
          "body": "```js\r\nconst typeOf = (val) => Object.prototype.toString.call(val).slice(8, -1)\r\nconst isFunction = (val) => typeOf(val) === 'Function'\r\n\r\nfunction eq(a, b, aStack, bStack) {\r\n    // === 结果为 true 的区别出 +0 和 -0\r\n    if (a === b) return a !== 0 || 1 / a === 1 / b\r\n\r\n    // typeof null 的结果为 object，这里做判断，是为了让有 null 的情况尽早退出函数\r\n    if (a == null || b == null) return false\r\n\r\n    // 判断 NaN\r\n    if (a !== a) return b !== b\r\n\r\n    // 判断参数 a 类型，如果是基本类型，在这里可以直接返回 false\r\n    const type = typeof a\r\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') {\r\n        return false\r\n    }\r\n\r\n    // 更复杂的对象使用 deepEq 函数进行深度比较\r\n    return deepEq(a, b, aStack, bStack)\r\n}\r\n\r\nfunction deepEq(a, b, aStack, bStack) {\r\n    // a 和 b 的内部属性 [[class]] 相同时 返回 true\r\n    const className = typeOf(a)\r\n    if (className !== typeOf(b)) return false\r\n\r\n    switch (className) {\r\n        case 'RegExp':\r\n        case 'String':\r\n            return '' + a === '' + b\r\n        case 'Number':\r\n            if (+a !== +a) return +b !== +b\r\n            return +a === 0 ? 1 / +a === 1 / +b : +a === +b\r\n        case 'Date':\r\n        case 'Boolean':\r\n            return +a === +b\r\n    }\r\n\r\n    const areArrays = className === 'Array'\r\n    // 不是数组\r\n    if (!areArrays) {\r\n        // 过滤掉两个函数的情况\r\n        if (typeof a != 'object' || typeof b != 'object') return false\r\n\r\n        const aCtor = a.constructor,\r\n            bCtor = b.constructor\r\n        // aCtor 和 bCtor 必须都存在并且都不是 Object 构造函数的情况下，\r\n        // aCtor 不等于 bCtor， 那这两个对象就真的不相等啦\r\n        if (\r\n            aCtor !== bCtor &&\r\n            !(\r\n                isFunction(aCtor) &&\r\n                aCtor instanceof aCtor &&\r\n                isFunction(bCtor) &&\r\n                bCtor instanceof bCtor\r\n            ) &&\r\n            'constructor' in a &&\r\n            'constructor' in b\r\n        ) {\r\n            return false\r\n        }\r\n    }\r\n\r\n    aStack = aStack || []\r\n    bStack = bStack || []\r\n    let length = aStack.length\r\n\r\n    // 检查是否有循环引用的部分\r\n    while (length--) {\r\n        if (aStack[length] === a) {\r\n            return bStack[length] === b\r\n        }\r\n    }\r\n\r\n    aStack.push(a)\r\n    bStack.push(b)\r\n\r\n    // 数组判断\r\n    if (areArrays) {\r\n        length = a.length\r\n        if (length !== b.length) return false\r\n\r\n        while (length--) {\r\n            if (!eq(a[length], b[length], aStack, bStack)) return false\r\n        }\r\n    }\r\n    // 对象判断\r\n    else {\r\n        let keys = Object.keys(a),\r\n            key = -1,\r\n            length = keys.length\r\n\r\n        if (Object.keys(b).length !== length) return false\r\n        while (length--) {\r\n            key = keys[length]\r\n            if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))\r\n                return false\r\n        }\r\n    }\r\n\r\n    aStack.pop()\r\n    bStack.pop()\r\n    return true\r\n}\r\n```\r\n代码来源：[JavaScript专题之如何判断两个对象相等](https://github.com/mqyqingfeng/Blog/issues/41)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk3NzA2ODk=",
    "number": 615,
    "title": "【Q599】Object.is 与全等运算符(===)有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDE5MDYxOQ==",
          "body": "> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n\r\n1. +0/-0\r\n2. NaN/NaN\r\n\r\n``` js\r\nif (!Object.is) {\r\n  Object.is = function(x, y) {\r\n    // SameValue algorithm\r\n    if (x === y) { // Steps 1-5, 7-10\r\n      // Steps 6.b-6.e: +0 != -0\r\n      return x !== 0 || 1 / x === 1 / y;\r\n    } else {\r\n      // Step 6.a: NaN == NaN\r\n      return x !== x && y !== y;\r\n    }\r\n  };\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5JTm8U",
          "body": "```javascript\r\nObject.is()在===基础上特别处理了NaN,-0,+0，保证-0与+0不相等，但NaN与NaN相等\r\n\r\nNaN === NaN // false\r\n+0 === -0 // true\r\n\r\nObject.is(+0 ,-0) // false\r\nObject.is(NaN, NaN) // true\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wuzqZZZ",
            "url": "https://github.com/wuzqZZZ"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MTk4MjAwMDk=",
    "number": 616,
    "title": "【Q600】在 React hooks 中如何模拟 forceUpdate",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDIyNzA1Nw==",
          "body": "``` js\r\n  const [ignored, forceUpdate] = useReducer(x => x + 1, 0);\r\n\r\n  function handleClick() {\r\n    forceUpdate();\r\n  }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5hmROH",
          "body": "```\r\nimport {useState,useCallback} from 'react';\r\n\r\nconst [state,setState] = useState({})\r\n\r\nconst handleForceUpdate = useCallback(() => {\r\n    setState({})\r\n},[])\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wongchisum",
            "url": "https://github.com/wongchisum"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MjAyMTc3Mjg=",
    "number": 617,
    "title": "【Q601】什么是认证与授权",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5hmtxL",
          "body": "\r\n认证（Authentication）和授权（Authorization）是信息安全领域中的两个重要概念，用于确保用户的身份验证和访问权限控制。\r\n认证就像是您去银行取钱时需要出示身份证明，以证明您是账户持有人。在计算机系统中，认证是确认用户是谁的过程，通过提供用户名和密码等凭据来验证身份的有效性。\r\n\r\n授权就像是银行根据您的身份和账户类型决定您可以进行哪些操作，比如取款或转账。在计算机系统中，授权是确定用户可以访问哪些资源或执行哪些操作的过程。系统会根据您的身份和权限规则来控制您的访问权限，确保您只能访问您被授权的资源或执行您被授权的操作。\r\n\r\n通过认证和授权机制，计算机系统可以确保只有经过身份验证并被授权的用户才能访问受保护的信息和功能。这就像是银行确保只有账户持有人才能操作自己的账户一样，保护用户的隐私和系统的安全",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Fightingllc",
            "url": "https://github.com/Fightingllc"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MjM5MTI3Njk=",
    "number": 619,
    "title": "【Q602】如何把对象转化为 key/value 的二维数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg2MzIyOTI5OA==",
          "body": "``` js\r\nObject.entries({ a: 3 })\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MjUwMDUzMjY=",
    "number": 620,
    "title": "【Q603】在 JS 中如何监听 Object 某个属性值的变化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NjI3MTI5OA==",
          "body": "```\r\nlet obj = {\r\n    a:'元素a',\r\n    b:'元素b'\r\n}\r\nconst handle = {\r\n    get:(obj,prop)=>{\r\n        console.log(`正在获取：${prop}`);\r\n        return obj[prop];\r\n    },\r\n    set:(obj,prop,value)=>{\r\n        console.log(`正在修改元素：将${prop}属性设置为${value}`);\r\n        obj[prop] = value;\r\n    }\r\n}\r\n\r\nconst proxy = new Proxy(obj,handle);\r\n\r\nconsole.log(proxy.a)\r\n//正在获取：a\r\n// 元素a\r\n\r\nproxy.a='123'\r\n// 正在修改元素：将a属性设置为123\r\n\r\nconsole.log(proxy);\r\n//Proxy {a: \"123\", b: \"元素b\"}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "txd688",
            "url": "https://github.com/txd688"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NzU2MzMyNw==",
          "body": "在 JS 中可以使用两种方式监听属性值变化\r\n\r\n## Proxy\r\n\r\n## Object.defineProperty",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MjU1MTMzMTc=",
    "number": 621,
    "title": "【Q604】判断以下路由，将会响应哪一个路由",
    "body": "代码见: [多匹配路由 - codesandbox](https://codesandbox.io/s/node-server-duopipeiluyou-lr2l4)\r\n\r\n``` js\r\nconst app = new Koa()\r\nconst router = new Router()\r\n\r\nrouter.get('/', (ctx, next) => {\r\n  ctx.body = 'hello, world'\r\n})\r\n\r\nrouter.get('/api/users/10086', (ctx, next) => {\r\n  console.log(ctx.router)\r\n  ctx.body = {\r\n    userId: 10086,\r\n    direct: true\r\n  }\r\n})\r\n\r\nrouter.get('/api/users/:userId', (ctx, next) => {\r\n  console.log(ctx.router)\r\n  ctx.body = {\r\n    userId: ctx.params.userId\r\n  }\r\n})\r\n\r\napp.use(router.routes())\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41EfQ9",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzEzMjEwOTE=",
    "number": 622,
    "title": "【Q605】js 中什么是 AsyncIterable",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40p9QH",
          "body": "``` js\r\nfor await (const x of data) {}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzMyNDkyNTE=",
    "number": 624,
    "title": "【Q606】关于事件循环，仅有 Promise，判断以下代码输出",
    "body": "> 代码见 [Promise 事件循环代码输出顺序题目 - CodePen](https://codepen.io/shanyue/pen/XWRJjwz)\r\n\r\n``` js\r\nPromise.resolve(console.log(0))\r\n  .then(() => {\r\n    console.log(1);\r\n    Promise.resolve(console.log(5))\r\n      .then(() => console.log(3))\r\n      .then(() => console.log(4))\r\n      .then(() => console.log(6))\r\n  })\r\n  .then(() => console.log(2))\r\n  .then(() => console.log(7))\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTA1NTQ0Ng==",
          "body": "按照我的理解应该是0,1,2,7,5,3,4,6",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xiaoxiaohuayu",
            "url": "https://github.com/xiaoxiaohuayu"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTA1NTcwNA==",
          "body": "`0 1 5 3 2 4 7 6`\r\n\r\n以上代码可以看做以下代码的简写，此时思路就会清晰很多\r\n\r\n``` js\r\nPromise.resolve(console.log(0))\r\n  .then(() => {\r\n    console.log(1);\r\n    const r = console.log(5)\r\n    Promise.resolve(r)\r\n      .then(() => {\r\n        const r = console.log(3)\r\n        return r\r\n      })\r\n      .then(() => {\r\n        const r = console.log(4)\r\n        return r\r\n      })\r\n      .then(() => {\r\n        const r = console.log(6)\r\n        return r\r\n      });\r\n    return r\r\n  })\r\n  .then(() => {\r\n    const r = console.log(2)\r\n    return r\r\n  })\r\n  .then(() => {\r\n    const r = console.log(7)\r\n    return r\r\n  });\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTA2ODM4NQ==",
          "body": "为了方便说明执行思路，把箭头函数换成了普通函数，起了名字，然后加上默认返回值 return  undefined\r\n```js\r\nPromise.resolve(console.log(0))\r\n    .then(function F1() {\r\n      console.log(1);\r\n      Promise.resolve(console.log(5))\r\n        .then(function F3() {\r\n          console.log(3)\r\n          return undefined\r\n        })\r\n        .then(function F4() {\r\n          console.log(4)\r\n          return undefined\r\n        })\r\n        .then(function F6() {\r\n          console.log(6)\r\n          return undefined\r\n        })\r\n\r\n      return undefined\r\n    })\r\n    .then(function F2() {\r\n      console.log(2)\r\n      return undefined\r\n    })\r\n    .then(function F7() {\r\n      console.log(7)\r\n      return undefined\r\n    })\r\n```\r\n\r\n执行过程：\r\n打印 0, **F1 放入 microtask**\r\n调用栈空了, 从 microtask 拿 F1 执行 \r\n打印 1, 遇到 Promise.resolve\r\n打印 5, 遇到 then, **F3 放入 microtask**\r\n继续执行同步的代码 也就是 return undefined, 然后看到 then\r\n**然后把 F2 放入 microtask**\r\n调用栈空了, 从 microtask 按顺序拿 F3 执行\r\n打印 3, 再遇到 return undefined, 然后看到 then, **再把 F4 放入 microtask**\r\n从 microtask 按顺序拿 F2 执行\r\n打印 2, 再遇到 return undefined, 然后看到 then, **再把 F7 放入 microtask**\r\n从 microtask 按顺序拿 F4 执行\r\n打印 4, 再遇到 return undefined, 然后看到 then, **再把 F6 放入 microtask**\r\n从 microtask 按顺序拿 F7 执行\r\n 打印 7 再遇到 return undefined, 没有 then 了\r\n从 microtask 按顺序拿 F6 执行\r\n打印 6\r\n\r\n\r\n画个图大概是这样：\r\n![image](https://user-images.githubusercontent.com/50768544/123897414-ecbb8980-d995-11eb-8293-01e274dd876f.png)\r\n",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "xjxujing",
            "url": "https://github.com/xjxujing"
          }
        },
        {
          "id": "IC_kwDODQzyOs44ya4S",
          "body": "多个promise then 的执行顺序是\r\n1. 按同步的运行顺序，执行 Promise 的构造函数\r\n\r\n2. 将所有 Promise 构造函数后的第一个 then() 函数放入异步队列中（如果存在的话）\r\n\r\n3. 将所有 Promise 构造函数后的第二个 then() 函数放入异步队列中（如果存在的话）\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs46ZqDC",
          "body": "> 为了方便说明执行思路，把箭头函数换成了普通函数，起了名字，然后加上默认返回值 return undefined\r\n> \r\n> ```js\r\n> Promise.resolve(console.log(0))\r\n>     .then(function F1() {\r\n>       console.log(1);\r\n>       Promise.resolve(console.log(5))\r\n>         .then(function F3() {\r\n>           console.log(3)\r\n>           return undefined\r\n>         })\r\n>         .then(function F4() {\r\n>           console.log(4)\r\n>           return undefined\r\n>         })\r\n>         .then(function F6() {\r\n>           console.log(6)\r\n>           return undefined\r\n>         })\r\n> \r\n>       return undefined\r\n>     })\r\n>     .then(function F2() {\r\n>       console.log(2)\r\n>       return undefined\r\n>     })\r\n>     .then(function F7() {\r\n>       console.log(7)\r\n>       return undefined\r\n>     })\r\n> ```\r\n> \r\n> 执行过程： 打印 0, **F1 放入 microtask** 调用栈空了, 从 microtask 拿 F1 执行 打印 1, 遇到 Promise.resolve 打印 5, 遇到 then, **F3 放入 microtask** 继续执行同步的代码 也就是 return undefined, 然后看到 then **然后把 F2 放入 microtask** 调用栈空了, 从 microtask 按顺序拿 F3 执行 打印 3, 再遇到 return undefined, 然后看到 then, **再把 F4 放入 microtask** 从 microtask 按顺序拿 F2 执行 打印 2, 再遇到 return undefined, 然后看到 then, **再把 F7 放入 microtask** 从 microtask 按顺序拿 F4 执行 打印 4, 再遇到 return undefined, 然后看到 then, **再把 F6 放入 microtask** 从 microtask 按顺序拿 F7 执行 打印 7 再遇到 return undefined, 没有 then 了 从 microtask 按顺序拿 F6 执行 打印 6\r\n> \r\n> 画个图大概是这样： ![image](https://user-images.githubusercontent.com/50768544/123897414-ecbb8980-d995-11eb-8293-01e274dd876f.png)\r\n\r\nvery nice",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liweinanone",
            "url": "https://github.com/liweinanone"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzMyNjY1NDE=",
    "number": 625,
    "title": "【Q607】关于字符串编码解码进阶",
    "body": "一道有意思的面试题\r\n例子如下，实现`countOfLetters`\r\n```js\r\ncountOfLetters('A2B3') // { A: 2, B: 3 }\r\ncountOfLetters('A(A3B)2') // { A: 7, B: 2}\r\ncountOfLetters('C4(A(A3B)2)2') // { A: 14, B: 4, C: 4 }\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MTA2NTMzNw==",
          "body": "答案：\r\n```ts\r\ntype LetterCounter = {\r\n  // A-Z\r\n  [i: string]: number\r\n}\r\n\r\nfunction letterAddCount(target: LetterCounter, source: LetterCounter) {\r\n  for (let k in source) {\r\n    target[k] ??= 0\r\n    target[k] += source[k]\r\n  }\r\n  return target\r\n}\r\nfunction letterMultipleCount(target: LetterCounter, multiples: number) {\r\n  for (let i in target) {\r\n    target[i] *= multiples\r\n  }\r\n  return target\r\n}\r\nfunction countOfLetters(str: string) {\r\n  const regex = /[1-9]/\r\n  const stack: LetterCounter[] = [{}]\r\n  for (let i = 0; i < str.length; i++) {\r\n    const ch = str[i]\r\n    let count = 1\r\n    if (regex.test(str[i + 1])) count = +str[++i]\r\n    // case ( | )\r\n    switch (ch) {\r\n      case '(':\r\n        stack.push({})\r\n        continue\r\n      case ')':\r\n        const pop = stack.pop()!\r\n        const last = stack[stack.length - 1]\r\n        letterAddCount(last, letterMultipleCount(pop, count))\r\n        continue\r\n    }\r\n    // case A-Z\r\n    const last = stack[stack.length - 1]\r\n    last[ch] ??= 0\r\n    last[ch] += count\r\n  }\r\n  return stack.pop()\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Nctdt",
            "url": "https://github.com/Nctdt"
          }
        },
        {
          "id": "IC_kwDODQzyOs400Ihu",
          "body": "```js\r\nfunction countOfLetters(str) {\r\n  let stack = [];\r\n  const len = str.length;\r\n  const pick = () => stack[stack.length - 1];\r\n  const isNumber = v => !Number.isNaN(parseInt(v))\r\n  for (let i = 0; i < len; i++) {\r\n    const s = str[i];\r\n    if (pick() === ')' && isNumber(s)) {\r\n      let subStr = '';\r\n      while(pick() !== '(') {\r\n        let letter = stack.pop();\r\n        if (letter !== ')') {\r\n          if (isNumber(letter)) {\r\n            subStr = ((+letter) * parseInt(s)) + subStr;\r\n          } else if (isNumber(subStr.charAt(0))) { // 字母后跟着数字则直接拼接\r\n            subStr = letter + subStr;\r\n          } else {\r\n            subStr = letter + s + subStr; // 字母后没有跟数字，需要将外层数字累加\r\n          }\r\n        }\r\n      }\r\n      // 弹出'('\r\n      stack.pop();\r\n      // 重新入栈\r\n      stack = stack.concat(subStr.split(''));\r\n      continue;\r\n    }\r\n    stack.push(s);\r\n  }\r\n\r\n  let result = {};\r\n  let count = '';\r\n  while(stack.length) {\r\n    const s = stack.pop();\r\n    if (isNumber(s)) {\r\n      count = s + count;\r\n    } else {\r\n      result[s] = (result[s] || 0) + (parseInt(count || '1'));\r\n      count = '';\r\n    }\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs44UiQ1",
          "body": "不用栈，全部用正则实现\r\n```javascript\r\nconst countOfLetters = (str) => {\r\n  let frequencyMap = {}\r\n  let regArray = [\r\n    /([a-zA-Z])([a-zA-Z])/g, //AA\r\n    /([a-zA-Z])(\\))/g, //A)\r\n    /([a-zA-Z])(\\()/g, //A(\r\n    /(\\))([a-zA-Z])/g, //)A\r\n    /(\\))(\\))/g, //))\r\n    /(\\))(\\()/g, //)(\r\n  ]\r\n  let targetStr = str\r\n  for (const reg of regArray) {\r\n    targetStr = targetStr.replace(reg,\"$11$2\")\r\n  }\r\n  // let targetStr = str.replace(/([a-zA-Z]|\\))(\\(|[a-zA-Z]|\\))/g,\"$11$2\") // 这种写法最后一个测试用例会通过不了  \r\n  let unfoldable = /(\\([0-9a-zA-Z]*\\))([0-9]+)/\r\n  while (unfoldable.test(targetStr)) {\r\n    targetStr = targetStr.replace(unfoldable, (match, p1, p2) => p1.slice(1,-1).replace(/[0-9]+/g, (count) => +count*p2))\r\n  }\r\n  let matchResult\r\n  let unit = /[a-zA-Z][0-9]+/g\r\n  while ((matchResult = unit.exec(targetStr)) !== null) {\r\n    let letter = matchResult[0][0]\r\n    let frequency = matchResult[0].slice(1)\r\n    frequencyMap[letter] = frequencyMap[letter] ? frequencyMap[letter] + Number(frequency) : +frequency\r\n  }\r\n  return frequencyMap\r\n}\r\n\r\nconsole.log(countOfLetters('A2B3'))\r\nconsole.log(countOfLetters('A(A3B)2'))\r\nconsole.log(countOfLetters('C4(A(A3B)2)2'))\r\nconsole.log(countOfLetters('C4(A()2)2'))\r\nconsole.log(countOfLetters('(A2B3)'))\r\nconsole.log(countOfLetters('(A11B9)11'))\r\nconsole.log(countOfLetters('(A2B3)(A5B6)'))\r\nconsole.log(countOfLetters('(A2B3)C(A5B6)'))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzM2NTk2Njk=",
    "number": 626,
    "title": "【Q608】请简介 CSS 的盒模型",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44oowH",
          "body": "- 标准盒模型 \r\nwidth = content-width\r\nheight = content-height \r\n- 怪异盒模型\r\nwidth = content-width + padding + border\r\nheight = content-height + padding + border\r\n\r\n> 但是我感觉怪异盒模型更好用 😂",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "linlai163",
            "url": "https://github.com/linlai163"
          }
        },
        {
          "id": "IC_kwDODQzyOs5T5bW6",
          "body": "CSS 的盒模型主要包括以下两种，可通过 [box-sizing](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing) 属性进行配置：\r\n\r\n+ `content-box`：默认属性。width 只包含 content\r\n+ `border-box`：width 包含 (content、padding、border)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQzMjE3MDY=",
    "number": 627,
    "title": "【Q609】请简述重新登录 refresh token 的原理",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400GYj",
          "body": " Refresh Token，将会话管理流程改进如下。\r\n\r\n- 客户端使用用户名密码进行认证\r\n\r\n- 服务端生成有效时间较短的 Access Token（例如 10 分钟），和有效时间较长的 Refresh Token（例如 7 天）\r\n\r\n- 客户端访问需要认证的接口时，携带 Access Token\r\n\r\n- 如果 Access Token 没有过期，服务端鉴权后返回给客户端需要的数据\r\n\r\n- 如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token\r\n\r\n- 如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token\r\n\r\n- 客户端使用新的 Access Token 访问需要认证的接口\r\n\r\nRefresh Token提供了服务端禁用用户 Token 的方式，当用户需要登出或禁用用户时，只需要将服务端的 Refresh Token 禁用或删除，用户就会在 Access Token 过期后，由于无法获取到新的 Access Token 而再也无法访问需要认证的接口。这样的方式虽然会有一定的窗口期（取决于 Access Token 的失效时间），但是结合用户登出时客户端删除 Access Token 的操作，基本上可以适应常规情况下对用户认证鉴权的精度要求。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aIQ",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQ0NjIwMTE=",
    "number": 628,
    "title": "【Q610】了解什么是 JSBridge 吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400Fno",
          "body": "JSBridge就是JavaScript和Native(IOS/Android)之间的桥梁，提供两者相互调用的能力",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400an9",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs401Tsn",
          "body": "url schema\r\nintent\r\nuniversal link",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQ1NjM1MjM=",
    "number": 629,
    "title": "【Q611】React/Vue 中兄弟组件如何进行通信",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjMyODA3Mw==",
          "body": "> [见代码：React 中兄弟组件如何通信 - CodeSandbox](https://codesandbox.io/s/react-xiongdizujiantongxin-f2jf6)\r\n\r\n兄弟组件可通过 prop 与回调函数式的 prop 进行通信\r\n\r\n``` js\r\nimport { useState } from \"react\";\r\nimport \"./styles.css\";\r\n\r\nfunction One({ count, setCount }) {\r\n  return (\r\n    <div style={{ border: \"1px solid red\" }}>\r\n      <h2>Conponent One</h2>\r\n      <button onClick={() => setCount(count + 1)}>Click</button>\r\n      <div>{count}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Two({ count, setCount }) {\r\n  return (\r\n    <div style={{ border: \"1px solid red\" }}>\r\n      <h2>Conponent Two</h2>\r\n      <button onClick={() => setCount(count + 1)}>Click</button>\r\n      <div>{count}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default function App() {\r\n  const [count, setCount] = useState(0);\r\n  return (\r\n    <div className=\"App\">\r\n      <One count={count} setCount={(c) => setCount(c)} />\r\n      <Two count={count} setCount={(c) => setCount(c)} />\r\n    </div>\r\n  );\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5NyM7K",
          "body": "vue\r\n1. 通过组件的实例用ref的方式去拿到组件的实例，然后再去拿到组件的数；\r\n  a. 如果vue3使用setup语法糖的话，需要用defineExpose暴露出去数据；\r\n2. 使用vuex/pinia之类的库；\r\n3. 通过一个公有的父组件，然这个父组件当中间层去转发，通过props/emit之类的形式拿到下面子组件的数据，再去派发到另一个子组件；\r\n4. eventbus事件总线",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "feefeefee",
            "url": "https://github.com/feefeefee"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzQ4NDc5MjE=",
    "number": 630,
    "title": "【Q612】React.memo 中是如何实现性能优化的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MzMzNjMxNw==",
          "body": "当 React 中一个组件进行更新时，它的所有子组件都会进行重新渲染，即便子组件的 props 并未发生任何改变。\r\n\r\n`React.memo` 对子组件默认使用浅比较对比前后两次 props 的变更，若未发生变更则不会重新渲染，因此提高了性能。\r\n\r\n可参考以下两个示例，加深理解:\r\n\r\n1. [React.memo 和性能优化](https://codesandbox.io/s/zujianxiasuoyouzizujianhuifashengchongxinxuanran-bv70e)。当某个组件状态更新时，它的所有子组件树将会重新渲染。\r\n1. [React.memo 和 React.useMemo 是如何优化性能的](https://codesandbox.io/s/reactmemo-and-reactusememo-79txp)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzU0MjA0MjY=",
    "number": 631,
    "title": "【Q613】如何使用 JS 实现一个发布订阅模式",
    "body": "使用 JS 实现一个发布订阅器，`Event`，示例如下:\r\n\r\n``` js\r\nconst e = new Event()\r\n\r\ne.on('click', x => console.log(x.id))\r\n\r\ne.once('click', x => console.log(id))\r\n\r\n//=> 3\r\ne.emit('click', { id: 3 })\r\n\r\n//=> 4\r\ne.emit('click', { id: 4 })\r\n\r\n```\r\n\r\nAPI 如下：\r\n\r\n``` js\r\nclass Event {\r\n  emit (type, ...args) {\r\n  }\r\n\r\n  on (type, listener) {\r\n  }\r\n\r\n  once (type, listener) {\r\n  }\r\n\r\n  off (type, listener) {\r\n  }\r\n}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjcyNjQ0OA==",
          "body": "一个简单的订阅发布模式实现如下，主要有两个核心 API\r\n\r\n+ `emit`: 发布一个事件\r\n+ `on`: 监听一个事件\r\n+ `off`: 取消一个事件监听\r\n\r\n实现该模式，使用一个 events 维护发布的事件：\r\n\r\n``` js\r\nconst events = {\r\n  click: [{\r\n    once: true,\r\n    listener: callback,\r\n  }, {\r\n    listener: callback\r\n  }]\r\n}\r\n```\r\n\r\n具体实现代码如下所示\r\n\r\n``` js\r\nclass Event {\r\n  events = {}\r\n \r\n  emit (type, ...args) {\r\n    const listeners = this.events[type]\r\n    for (const listener of listeners) {\r\n      listener.listener(...args)\r\n      if (listener.once) {\r\n        this.off(type, listener.listener)\r\n      }\r\n    }\r\n  }\r\n\r\n  on (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type].push({ listener })\r\n  }\r\n\r\n  once (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type].push({ listener, once: true })\r\n  }\r\n\r\n  off (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type] = this.events[type].filter(listener => listener.listener !== listener)\r\n  }\r\n}\r\n```\r\n\r\n以上代码不够优雅，且有点小瑕疵，再次实现如下，代码可见 [如何实现发布订阅器  - codepen](https://codepen.io/shanyue/pen/WNjprpe?editors=0012)\r\n\r\n``` js\r\nclass Event {\r\n  events = {}\r\n \r\n  emit (type, ...args) {\r\n    const listeners = this.events[type]\r\n    for (const listener of listeners) {\r\n      listener(...args)\r\n    }\r\n  }\r\n\r\n  on (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type].push(listener)\r\n  }\r\n\r\n  once (type, listener) {\r\n    const callback = (...args) => {\r\n      this.off(type, callback)\r\n      listener(...args)\r\n    }\r\n    this.on(type, callback)\r\n  }\r\n\r\n  off (type, listener) {\r\n    this.events[type] = this.events[type] || []\r\n    this.events[type] = this.events[type].filter(callback => callback !== listener)\r\n  }\r\n}\r\n\r\nconst e = new Event()\r\n\r\nconst callback = x => { console.log('Click', x.id) }\r\ne.on('click', callback)\r\ne.on('click', callback)\r\n\r\n// 只打印一次\r\nconst onceCallback = x => console.log('Once Click', x.id)\r\ne.once('click', onceCallback)\r\ne.once('click', onceCallback)\r\n\r\n//=> 3\r\ne.emit('click', { id: 3 })\r\n\r\n//=> 4\r\ne.emit('click', { id: 4 })\r\n```",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDM0ODI0Nw==",
          "body": "```javascript\r\n\r\n\r\nclass Center {\r\n    eventMap = {}\r\n    on (event, fun) {\r\n        this.#add(event, fun, 'on')\r\n    }\r\n\r\n    once (event, fun) {\r\n        this.#add(event, fun, 'once')\r\n    }\r\n    \r\n    #add (event, fun, type) {\r\n        if (typeof fun !== 'function') throw new TypeError(`${fun} is not a function`)\r\n        if (!event) throw new Error(`need type`)\r\n        if (!this.eventMap[event]) {\r\n            this.eventMap[event] = []\r\n        }\r\n        this.eventMap[event].push({\r\n            event: fun,\r\n            type: type\r\n        })\r\n    }\r\n\r\n    emit (event, ...args) {\r\n        if (this.eventMap[event]) {\r\n            this.eventMap[event] = this.eventMap[event].filter(curr => {\r\n                curr.data(...args)\r\n                return curr.type !== 'once'\r\n            })\r\n        }\r\n    }\r\n\r\n    remove (event, fun) {\r\n        if (this.eventMap[event]) {\r\n            this.eventMap[event] = this.eventMap[event].filter(curr => {\r\n                return curr.event !== fun\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs41aZU4",
          "body": "之前去B站面试，还追问了循环订阅如何处理。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "infjer",
            "url": "https://github.com/infjer"
          }
        },
        {
          "id": "IC_kwDODQzyOs41b2vZ",
          "body": "@infjer 何为循环订阅",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs42scjU",
          "body": "```\r\nclass Emitter {\r\n  constructor() {\r\n    this.events = {};\r\n  }\r\n\r\n  emit(type, ...args) {\r\n    if (this.events[type] && this.events[type].length > 0) {\r\n      this.events[type].forEach(cb => {\r\n        cb.apply(this, args);\r\n      });\r\n    }\r\n  }\r\n\r\n  on(type, cb) {\r\n    if (!this.events[type]) {\r\n      this.events[type] = [];\r\n    }\r\n    this.events[type].push(cb);\r\n  }\r\n\r\n  once(type, cb) {\r\n    const func = (...args) => {\r\n      this.off(type, func);\r\n      cb.apply(this, args);\r\n    };\r\n\r\n    this.on(type, func);\r\n  }\r\n\r\n  off(type, cb) {\r\n    if (!cb) {\r\n      this.events[type] = null;\r\n    } else {\r\n      this.events[type].filter(exec => exec !== cb);\r\n    }\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "leblancy",
            "url": "https://github.com/leblancy"
          }
        },
        {
          "id": "IC_kwDODQzyOs5gutuI",
          "body": "```js\r\n// 实现发布订阅模式\r\n// on 订阅\r\n// emit 发布\r\n// off 取消订阅\r\n\r\nclass EventEmitter{\r\n  constructor(){\r\n    this.events = {}\r\n  }\r\n  // 订阅\r\n  on(type, callback){\r\n    this.events[type] = this.events[type] || [];\r\n    this.events[type].push(callback);\r\n  }\r\n  // 取消订阅\r\n  off(type, callback){\r\n    if(!this.events[type]) return;\r\n    this.events[type] = this.events[type].filter(event => event !== callback)\r\n  }\r\n  // 发布\r\n  emit(type, ...args){\r\n   if(!this.events[type]) return\r\n    // 遍历事件\r\n    this.events[type].forEach(event => {\r\n      event(...args)\r\n    })\r\n  }\r\n}\r\n\r\nconst e = new EventEmitter()\r\nconst callback2 = (data) => console.log(`${data.name}`);\r\n\r\ne.on('click',callback2)\r\n\r\ne.emit('click',{name:'xiaoming'})\r\n\r\ne.off('click', callback2)\r\n\r\ne.emit('click',{name:'lili'})\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzU5MzgwNjU=",
    "number": 632,
    "title": "【Q614】immer 的原理是什么，为什么它的性能更高",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NjU3NzIzNw==",
          "body": "``` js\r\nconst state = {\r\n  user: { id: 3 },\r\n  role: { name: 'admin' }\r\n}\r\n\r\nconst proxyState = new Proxy(state, {\r\n  get (target, prop) {\r\n    return target[prop]\r\n  },\r\n})\r\n```\r\n\r\n```js\r\n//=> True\r\nstate !== proxyState\r\n\r\n//=> True\r\nstate.user === proxyState.user\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzYxNjE5NzQ=",
    "number": 633,
    "title": "【Q615】React.useMemo 与 React.useCallback 是如何进行性能优化的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45-HxK",
          "body": "通过传入的依赖（浅比较）来确定是否返回新的值还是以前的值",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Muralitob",
            "url": "https://github.com/Muralitob"
          }
        },
        {
          "id": "IC_kwDODQzyOs5FlZq9",
          "body": "`useMemo` 和 `useCallback` 是 React 性能优化的一个手段之一。\r\n\r\n`useMemo` 会记住回调函数返回的值，只有当它的依赖项改变的时候，才会重新计算。`useMemo` 应该用在一些计算量比较大的场景下，或者是使用它来缓存一些 JSX 对象来避免重渲染。\r\n\r\n`useCallback` 其实是 `useMemo` 的语法糖，只不过它是用来缓存函数的，比如一个事件的回调函数。常见的使用场景是，一个较复杂的组件接收一个事件的回调函数，使用 `useCallback` 包装来避免函数的重新创建，从而导致函数的引用发生改变，引起复杂组件的重渲染（前提是该组件使用了 `React.memo` 或者是 `shouldComponentUpdate` API 来优化过）。\r\n\r\n但是其实 `useCallback` 有一个非常大的问题，比如在回调函数中，依赖了一个 state，你就不得不在依赖项中添加这个 state，而恰巧这个 state 是频繁变化的值，就会导致回调函数每次都会重新创建，失去了缓存的意义。所以最近 React 团队创建了一个 [RFC](https://github.com/reactjs/rfcs/pull/220) 专门来讨论这个问题。后面 React 会新增一个命名为 `useEvent` 的新 hooks 来解决这个问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nnmax",
            "url": "https://github.com/nnmax"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY0MTUwNTI=",
    "number": 634,
    "title": "【Q616】在 nginx 中如何配置 HTTP 协商缓存",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NTIyNjM4MA==",
          "body": "Nginx 中在 1.3.3 后已默认开启了协商缓存，手动配置如下：\r\n\r\n``` nginx\r\nlocation /public {\r\n    add_header Cache-Control no-cache; \r\n    etag on;\r\n    if_modified_since exact;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY0MjAzMjM=",
    "number": 635,
    "title": "【Q617】什么是 base64 与 URL Safe base64",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NTIyMjc4Nw==",
          "body": "`base64` 由 `0-9`、`A-Z`、`a-z` 及 `+`、`/` 组成，但是在 URL 中使用 `base64` 时，`/` 容易与路径符号发生冲突。\r\n\r\n因此，URL Safe Base64 将 `+` 替换为 `_`，`/` 替换为 `-`。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY0MzQyNjU=",
    "number": 636,
    "title": "【Q618】列举 Number、String、Array、Object、Promise 有哪些 API",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NDAzODczOQ==",
          "body": "## Number\r\n\r\n+ Number.isNaN()\r\n+ Number.isInteger()\r\n+ Number.isInfinite()\r\n+ Number.isSafeInteger()\r\n+ Number.prototype.toFixed()\r\n\r\n## String\r\n\r\n+ String.fromCharCode()\r\n+ String.raw()\r\n+ String.prototype.charAt()\r\n+ String.prototype.charCodeAt()\r\n+ String.prototype.concat()\r\n+ String.prototype.startsWith()\r\n+ String.prototype.endsWith()\r\n+ String.prototype.includes()\r\n+ String.prototype.indexOf()\r\n+ String.prototype.lastIndexOf()\r\n+ String.prototype.charAt()\r\n+ String.prototype.charCodeAt()\r\n+ String.prototype.trim()\r\n  + 如何手写实现 trim\r\n+ String.prototype.trimStart()\r\n+ String.prototype.trimEnd()\r\n+ String.prototype.repeat()\r\n+ String.prototype.replace()\r\n+ String.prototype.slice()\r\n+ String.prototype.split()\r\n+ String.prototype.substring()\r\n+ String.prototype.padStart()\r\n+ String.prototype.padEnd()\r\n+ String.prototype.search()\r\n+ String.prototype.match()\r\n+ String.prototype.toLowerCase()\r\n+ String.prototype.toUpperCase()\r\n\r\n## Array\r\n\r\n+ Array.isArray()\r\n+ Array.from()\r\n  + 如何生成 `[0, 1, 2, ..., 99]` 的数组\r\n+ Array.of()\r\n+ Array.prototype.slice()\r\n+ Array.prototype.splice()\r\n+ Array.prototype.sort()\r\n+ Array.prototype.reverse()\r\n+ Array.prototype.indexOf\r\n+ Array.prototype.lastIndexOf()\r\n+ Array.prototype.includes()\r\n+ Array.prototype.push()\r\n+ Array.prototype.pop()\r\n+ Array.prototype.shift()\r\n+ Array.prototype.unshift()\r\n  + 如何给数组首项添加元素\r\n+ Array.prototype.map()\r\n+ Array.prototype.reduce()\r\n+ Array.prototype.forEach()\r\n+ Array.prototype.filter()\r\n+ Array.prototype.every()\r\n+ Array.prototype.some()\r\n+ Array.prototype.flat()\r\n+ Array.prototype.flatMap()\r\n+ Array.prototype.toString()\r\n\r\n## Object\r\n\r\n+ Object.create()\r\n+ Object.assign()\r\n+ Object.defineProperties()\r\n+ Object.defineProperty()\r\n+ Object.keys()\r\n+ Object.values()\r\n+ Object.entries()\r\n+ Object.fromEntries()\r\n+ Object.is()\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzY4NTIyNTc=",
    "number": 637,
    "title": "【Q619】使用 JS 如何生成一个随机字符串",
    "body": "`random` 接收一个整数作为随机数的个数，最多生成8个随机数\r\n\r\n``` js\r\n// 'a839ac'\r\nrandom(6)\r\n\r\n// '8abc'\r\nrandom(4)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3Mzk0ODQ1Mg==",
          "body": "``` js\r\nconst random = (n) => Math.random().toString(36).slice(2, 2 + n)\r\n\r\nrandom()\r\n// => \"c1gdm2\"\r\nrandom()\r\n// => \"oir5pp\"\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Euq78",
          "body": "山月老师给出的答案：使用 `Math.random` 产生的随机数进行 36 进制转化，该随机数是由0-9，a-z 构成的。\r\n\r\n还有一种方案是对大写字母，小写字母以及数字的 ASCII 码进行转化。\r\n\r\n```javascript\r\nrandom_v1(4);\r\nrandom_v1(6);\r\n\r\n// ASCII：\r\n// 大写字母：65~90\r\n// 小写字母：97~122\r\n// 数字：48-57\r\nfunction random_v1(num: number) {\r\n  let b = new Array(num)\r\n    .fill(0)\r\n    .map(() => String.fromCharCode(generateAcsii()))\r\n    .join(\"\");\r\n  console.log(b);\r\n}\r\n\r\nfunction generateAcsii() {\r\n  // 生成 [65,90] && [97,122] && [48,51]\r\n  let a = Math.floor(Math.random() * 62); // [0,62]\r\n  if (a < 26) {\r\n    //  返回 大写字母 的 ASCII\r\n    return a + 65;\r\n  } else if (a >= 26 && a < 52) {\r\n    //  返回 小写字母 的 ASCII\r\n    return a - 26 + 97;\r\n  } else {\r\n    //  返回 数字 的 ASCII\r\n    return a - 52 + 48;\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangjs-jacky",
            "url": "https://github.com/wangjs-jacky"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzcwMDEwMDE=",
    "number": 638,
    "title": "【Q620】CSS 有哪些选择器",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NDA0Njc4Nw==",
          "body": "+ `:hover`\r\n+ `:active`\r\n+ `:first-child`\r\n+ `:last-child`\r\n+ `:nth-child`\r\n+ `:first-of-type`\r\n+ `:last-of-type`\r\n+ `:nth-of-type`\r\n+ `:empty`\r\n+ `:check`\r\n+ `:disable`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5GTjp_",
          "body": "1.id选择器\r\n2.类选择器\r\n3.元素选择器\r\n4.分组选择器（并集选择器）\r\n5.复合选择器（交集选择器）\r\n6.通配选择器\r\n7.后代元素选择器\r\n8.子元素选择器\r\n9.伪类选择器\r\n10.属性选择器\r\n11.兄弟元素选择器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "849327939",
            "url": "https://github.com/849327939"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5MzcwMTI2NDY=",
    "number": 639,
    "title": "【Q621】CSS 有哪些伪类与伪元素选择器",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NDA1MjY0NA==",
          "body": "[CSS 选择器 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors)\r\n\r\n## 伪元素\r\n\r\n+ `::before`\r\n+ `::after`\r\n+ `::selection`\r\n+ `::placeholder`\r\n+ `::marker`\r\n\r\n## 伪类\r\n\r\n+ `:hover`\r\n+ `:first-child`\r\n+ `:last-child`\r\n+ `:nth-child`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400FfM",
          "body": "选择器 | 例子 | 例子描述\r\n-- | -- | --\r\n:active | a:active | 选择活动的链接。\r\n:checked | input:checked | 选择每个被选中的 <input> 元素。\r\n:disabled | input:disabled | 选择每个被禁用的 <input> 元素。\r\n:empty | p:empty | 选择没有子元素的每个 <p> 元素。\r\n:enabled | input:enabled | 选择每个已启用的 <input> 元素。\r\n:first-child | p:first-child | 选择作为其父的首个子元素的每个 <p> 元素。\r\n:first-of-type | p:first-of-type | 选择作为其父的首个 <p> 元素的每个 <p> 元素。\r\n:focus | input:focus | 选择获得焦点的 <input> 元素。\r\n:hover | a:hover | 选择鼠标悬停其上的链接。\r\n:in-range | input:in-range | 选择具有指定范围内的值的 <input> 元素。\r\n:invalid | input:invalid | 选择所有具有无效值的 <input> 元素。\r\n:lang(language) | p:lang(it) | 选择每个 lang 属性值以 \"it\" 开头的 <p> 元素。\r\n:last-child | p:last-child | 选择作为其父的最后一个子元素的每个 <p> 元素。\r\n:last-of-type | p:last-of-type | 选择作为其父的最后一个 <p> 元素的每个 <p> 元素。\r\n:link | a:link | 选择所有未被访问的链接。\r\n:not(selector) | :not(p) | 选择每个非 <p> 元素的元素。\r\n:nth-child(n) | p:nth-child(2) | 选择作为其父的第二个子元素的每个 <p> 元素。\r\n:nth-last-child(n) | p:nth-last-child(2) | 选择作为父的第二个子元素的每个<p>元素，从最后一个子元素计数。\r\n:nth-last-of-type(n) | p:nth-last-of-type(2) | 选择作为父的第二个<p>元素的每个<p>元素，从最后一个子元素计数\r\n:nth-of-type(n) | p:nth-of-type(2) | 选择作为其父的第二个 <p> 元素的每个 <p> 元素。\r\n:only-of-type | p:only-of-type | 选择作为其父的唯一 <p> 元素的每个 <p> 元素。\r\n:only-child | p:only-child | 选择作为其父的唯一子元素的 <p> 元素。\r\n:optional | input:optional | 选择不带 \"required\" 属性的 <input> 元素。\r\n:out-of-range | input:out-of-range | 选择值在指定范围之外的 <input> 元素。\r\n:read-only | input:read-only | 选择指定了 \"readonly\" 属性的 <input> 元素。\r\n:read-write | input:read-write | 选择不带 \"readonly\" 属性的 <input> 元素。\r\n:required | input:required | 选择指定了 \"required\" 属性的 <input> 元素。\r\n:root | root | 选择元素的根元素。\r\n:target | #news:target | 选择当前活动的 #news 元素（单击包含该锚名称的 URL）。\r\n:valid | input:valid | 选择所有具有有效值的 <input> 元素。\r\n:visited | a:visited | 选择所有已访问的链接。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzg0Mzc0Nzk=",
    "number": 640,
    "title": "【Q622】Number.isNaN 与 globalThis.isNaN 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NTI1NzkzMQ==",
          "body": "``` js\r\nNumber.isNaN(NaN)\r\nisNaN(NaN)\r\n\r\nNumber.isNaN('NaN')\r\nisNaN('NaN')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs46oLCK",
          "body": "> ```js\r\n> Number.isNaN(NaN)\r\n> isNaN(NaN)\r\n> \r\n> Number.isNaN('NaN')\r\n> isNaN('NaN')\r\n> ```\r\n\r\n试了下 `Number.isNaN('NaN')` 是 `false`，其他都是 `true`\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nmsn",
            "url": "https://github.com/nmsn"
          }
        },
        {
          "id": "IC_kwDODQzyOs5PGhzy",
          "body": "还真没注意过，看了下 MDN，上面解释已经很明示了\r\n- `isNaN`:\r\n> Return Value: true if the given value is NaN after being converted to a number; otherwise, false.\r\n- `Number.isNaN`:\r\n> Return value: The boolean value true if the given value is a number with value NaN. Otherwise, false.\r\n\r\n`globalThis.isNaN` 会对参数进行强制转换后判断是不是 `NaN`，而 `Number.isNaN` 不会对输入的参数进行强制转换",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "HydratedPig",
            "url": "https://github.com/HydratedPig"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzg0NDE3Mjc=",
    "number": 641,
    "title": "【Q623】如何判断一个数值为整数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NTI0Mzk5MA==",
          "body": "``` js\r\n// ES6\r\nNumber.isInteger(num);\r\n\r\n// ES5\r\nif (!Number.isInteger) {\r\n  Number.isInteger = function(num) {\r\n    return typeof num == \"number\" && num % 1 == 0;\r\n  };\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzg2OTg4OTI=",
    "number": 642,
    "title": "【Q624】同一页面三个组件请求同一个 API 发送了三次请求，如何优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NTQ2Mzg0Mw==",
          "body": "``` js\r\nconst fetchUser = (id) => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => {\r\n      console.log('Fetch: ', id)\r\n      resolve(id)\r\n    }, 5000)\r\n  })\r\n}\r\n\r\nconst cache = {}\r\nconst cacheFetchUser = (id) => {\r\n  if (cache[id]) {\r\n    return cache[id]\r\n  }\r\n  cache[id] = fetchUser(id)\r\n  return cache[id]\r\n}\r\n```\r\n\r\n``` js\r\ncacheFetchUser(3).then((id) => console.log(id))\r\ncacheFetchUser(3).then((id) => console.log(id))\r\ncacheFetchUser(3).then((id) => console.log(id))\r\n\r\n// Fetch:  3\r\n​// 3\r\n​// 3\r\n​// 3 \r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs53J8jK",
          "body": "promise.all 或者 async await",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "juvenile-spec",
            "url": "https://github.com/juvenile-spec"
          }
        },
        {
          "id": "IC_kwDODQzyOs53J9MJ",
          "body": "const fetchUser = (id) => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => {\r\n      console.log('Fetch: ', id)\r\n      resolve(id)\r\n    }, 5000)\r\n  })\r\n}\r\n\r\nconst cache = new Map(); // 使用 Map 替代对象\r\n\r\nconst cacheFetchUser = (id) => {\r\n  if (cache.has(id)) {\r\n    const { data, timestamp } = cache.get(id);\r\n    const currentTime = new Date().getTime();\r\n    const expirationTime = 60000; // 过期时间为 1 分钟\r\n    if (currentTime - timestamp < expirationTime) {\r\n      return Promise.resolve(data); // 返回缓存的数据\r\n    } else {\r\n      cache.delete(id); // 清除过期的缓存数据\r\n    }\r\n  }\r\n\r\n  const fetchData = fetchUser(id)\r\n    .then(data => {\r\n      cache.set(id, { data, timestamp: new Date().getTime() }); // 将数据存入缓存\r\n      return data;\r\n    });\r\n\r\n  cache.set(id, { data: fetchData, timestamp: new Date().getTime() }); // 将 Promise 存入缓存\r\n  return fetchData;\r\n}\r\n\r\n// 示例使用\r\ncacheFetchUser(3).then((id) => console.log(id));\r\ncacheFetchUser(3).then((id) => console.log(id));\r\ncacheFetchUser(3).then((id) => console.log(id));\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "juvenile-spec",
            "url": "https://github.com/juvenile-spec"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzk0MTgyMTg=",
    "number": 643,
    "title": "【Q625】简述 koa 的中间件原理，手写 koa-compose 代码",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40k4fS",
          "body": "``` js\r\nfunction compose (middlewares) {\r\n  return ctx => {\r\n    const dispatch = (i) => {\r\n      const middleware = middlewares[i]\r\n      if (i === middlewares.length) {\r\n        return\r\n      }\r\n      return middleware(ctx, () => dispatch(i+1))\r\n    }\r\n    return dispatch(0)\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400FUt",
          "body": "```js\r\n\r\nconst middlewares = [];\r\n\r\nmiddlewares.push(async function(ctx, next) {\r\n  console.log('1');\r\n  await next();\r\n  console.log('6');\r\n});\r\n\r\nmiddlewares.push(async function(ctx, next) {\r\n  console.log('2');\r\n  await next();\r\n  console.log('5');\r\n});\r\n\r\nmiddlewares.push(async function(ctx, next) {\r\n  console.log('3');\r\n  await next();\r\n  console.log('4');\r\n});\r\n\r\nasync function run() {\r\n  const middleware = middlewares.shift();\r\n  await (middleware && middleware({}, run));\r\n}\r\n\r\nrun(); // expect output: 1 2 3 4 5 6\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs400aGv",
          "body": "@haotie1990 你这种实现，简洁多了！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs401GnZ",
          "body": "这个好棒",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzk0MjQzODE=",
    "number": 644,
    "title": "【Q626】如何压缩前端项目中 JS 的体积",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NjEwMzQ0MQ==",
          "body": "1. [terser](https://github.com/terser/terser) 或者 [uglify](https://github.com/mishoo/UglifyJS)，及流行的使用 Rust 编写的 `swc` 压缩混淆化 JS。\r\n2. `gzip` 或者 `brotli` 压缩，在网关处(nginx)开启\r\n3. 使用 `webpack-bundle-analyzer` 分析打包体积，替换占用较大体积的库，如 `moment` -> `dayjs`\r\n4. 使用支持 Tree-Shaking 的库，对无引用的库或函数进行删除，如 `lodash` -> `lodash/es`\r\n5. 对无法 Tree Shaking 的库，进行按需引入模块，如使用 `import Button from 'antd/lib/Button'`，此处可手写 `babel-plugin` 自动完成，但不推荐\r\n6. 使用 babel (css 为 postcss) 时采用 `browserlist`，越先进的浏览器所需要的 polyfill 越少，体积更小\r\n7. code spliting，路由懒加载，只加载当前路由的包，按需加载其余的 chunk，首页 JS 体积变小 (PS: 次条不减小总体积，但减小首页体积)\r\n8. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个 chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4--C8f",
          "body": "压缩的具体操作\r\n1. 去除多余字符，eg：空格，换行、注释\r\n2. 压缩变量名，函数名、属性名\r\n3. 使用更简单的表达，eg：合并声明、布尔值简化",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1689851268",
            "url": "https://github.com/1689851268"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        },
        {
          "id": "MDU6TGFiZWwzMDkwODMwMjI5",
          "name": "perf"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Mzk0NDU1ODg=",
    "number": 645,
    "title": "【Q627】如何优化 React 项目的性能",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NjExMjMyNg==",
          "body": "1. 避免不必要的渲染，shouldComponentUpdate、React.memo、React.useMemo、React.useCallback。\r\n2. 代码分割，React.lazy 动态加载组件\r\n3. 使用 `react-query`，对请求响应进行缓存、重发等，避免多次请求，减少网络 IO 消耗及优化渲染次数\r\n4. 使用 `useDebounce`，对值及事件处理函数进行防抖，避免状态频繁变动，优化渲染次数\r\n5. 使用 `useImmer`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwzMDkwODMwMjI5",
          "name": "perf"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDAzODA0MDY=",
    "number": 646,
    "title": "【Q628】实现一个函数 maxBy，根据给定条件找到最大的数组项",
    "body": "类似 `loadash` 如：\r\n\r\n``` js\r\nconst data = [{ value: 6 }, { value: 2 }, { value: 4 }]\r\n\r\n//=> { value: 6 }\r\nmaxBy(data, x => x.value)\r\n```\r\n\r\n面试追问:\r\n\r\n+ 如果最大的项有多个，则多个都返回，如下所示\r\n\r\n``` js\r\nconst data = [{ value: 6 }, { value: 2 }, { value: 4 }, { value: 6 }]\r\n\r\n//=> [{ value: 6 }, { value: 6 }]\r\nmaxBy(data, x => x.value)\r\n```\r\n\r\n相关问题：\r\n\r\n+ [【Q411】如何找到当前页面出现次数最多的HTML标签](https://github.com/shfshanyue/Daily-Question/issues/418)\r\n+ [【Q629】实现一个函数 max，找到数组中最大的一个值/两个值/N个值](https://github.com/shfshanyue/Daily-Question/issues/647)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3Njg4NzI2Ng==",
          "body": "``` js\r\nconst maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n```\r\n\r\n若需要返回多个项，则使用以下代码\r\n\r\n``` js\r\nconst maxBy = (list, keyBy) => {\r\n  return list.slice(1).reduce((acc, x) => {\r\n    if (keyBy(x) > keyBy(acc[0])) {\r\n      return [x]\r\n    }\r\n    if (keyBy(x) === keyBy(acc[0])) {\r\n      return [...acc, x]\r\n    }\r\n    return acc\r\n  }, [list[0]])\r\n}\r\n```",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400E2x",
          "body": "```js\r\nfunction maxBy(array, keyBy) {\r\n  if (!array || !array.length) {\r\n    return null;\r\n  }\r\n  const length = array.length;\r\n  let max = array[0];\r\n  let result = [max];\r\n  for (let i = 1; i < length; i++) {\r\n    const value = array[i];\r\n    if (keyBy(max) === keyBy(value)) {\r\n      result.push(value);\r\n    } else if (keyBy(max) < keyBy(value)) {\r\n      max = value;\r\n      result = [max];\r\n    }\r\n  }\r\n  if (result.length === 1) {\r\n    return result[0];\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDAzODU4Nzc=",
    "number": 647,
    "title": "【Q629】实现一个函数 max，找到数组中最大的一个值/两个值/N个值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NzA0OTg3Mg==",
          "body": "求最大的一个值：\r\n\r\n``` js\r\nfunction max (list) {\r\n  if (!list.length) { return 0 }\r\n  return list.reduce((x, y) => x > y ? x : y)\r\n}\r\n```\r\n\r\n求最大的两个值：\r\n\r\n> 代码见 [找出数组中最大的两个值 - codepen](https://codepen.io/shanyue/pen/vYmyYwQ?editors=1010)\r\n\r\n``` js\r\nfunction maxTwo (list) {\r\n  let max = -Infinity, secondMax = -Infinity\r\n  for (const x of list) {\r\n    if (x > max) {\r\n      secondMax = max\r\n      max = x\r\n    } else if (x > secondMax) {\r\n      secondMax = x\r\n    }\r\n  }\r\n  return [max, secondMax]\r\n}\r\n```\r\n\r\n如果求 TopN，可使用大顶堆、小顶堆实现，见另一个问题",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Fj9kv",
          "body": "```javascript\r\nconst maxTwo = (arr) => {\r\n    const max = Math.max(...arr)\r\n    const secondMax = Math.max(...arr.filter(a => a !== max))\r\n    return [max, secondMax]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yu-Lxy",
            "url": "https://github.com/Yu-Lxy"
          }
        },
        {
          "id": "IC_kwDODQzyOs5c6KQD",
          "body": "> \r\n\r\n若存在相同最大值，此法凉凉～",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yinsang",
            "url": "https://github.com/yinsang"
          }
        },
        {
          "id": "IC_kwDODQzyOs5g9YLN",
          "body": "```js\r\nconst arr = [1, 2, 3, 4, 20, 20]\r\nconst arr2 = [0, -1]\r\nconst arr3 = []\r\n\r\nfunction findLargestTwoNumbers(arr){\r\n  if(!arr.length) return\r\n\r\n  let max = -Infinity, second = -Infinity\r\n\r\n  for(let i of arr){\r\n    console.log(i)\r\n    if(i > max){\r\n      second = max\r\n      max = i \r\n    }else if(i > second){\r\n      second = i\r\n    }\r\n  }\r\n  return [max, second]\r\n}\r\nconsole.log(findLargestTwoNumbers(arr))\r\nconsole.log(findLargestTwoNumbers(arr2))\r\nconsole.log(findLargestTwoNumbers(arr3))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDA2OTQ3Mjk=",
    "number": 648,
    "title": "【Q630】什么是安全整数，如何判断一个整数是安全整数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40mIPX",
          "body": "根据 MDN 的文档描述：<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger>\r\n\r\n> 一个安全整数是一个符合下面条件的整数：\r\n> \r\n> 1. 可以准确地表示为一个IEEE-754双精度数字,\r\n> 1. 其IEEE-754表示不能是舍入任何其他整数以适应IEEE-754表示的结果。.\r\n\r\n`Number.MAX_SAFE_INTEGER` 是最大安全整数，`Number.isSafeInteger()` 用来判断一个数值是否为安全整数。\r\n\r\n而在安全整数之外，加减计算则会发生精度问题，如下：\r\n\r\n``` js\r\nNumber.MAX_SAFE_INTEGER\r\n//=> 9007199254740991\r\n\r\nNumber.MAX_SAFE_INTEGER + 1\r\n//=> 9007199254740992\r\n\r\n// 计算错误，结果应该是 9007199254740993\r\nNumber.MAX_SAFE_INTEGER + 2\r\n//=> 9007199254740992\r\n```\r\n\r\n而安全整数的问题，与 `0.1+0.2` 的问题类似。**在 Javascript 中，整数被存储为双精度浮点数**，而在整数大到一定程度后，就会导致精读失真。\r\n\r\n如下，最大安全整数可以精准表示。以下截图使用 <https://devtool.tech/double-type> 进行实时转换整数的 IEEE754 表示。\r\n\r\n> 在双精度浮点数中，尾数位有 52 位，而最大安全整数为 `2 ** 53 - 1`，通过以下截图，也可以看做是 `1.9999999999999998 * 2 ** (1075-1023)`\r\n\r\n![](https://static.shanyue.tech/images/22-11-04/clipboard-1213.2266e3.webp)\r\n\r\n但是最大安全整数加2，尾数位会溢出，导致该数值无法精准表示。\r\n\r\n![](https://static.shanyue.tech/images/22-11-04/clipboard-1372.3d3b4d.webp)\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5NrCJL",
          "body": "自2003年以后，电脑普遍采用x86-64架构，而架构的数据单元的固定为64位(8字节)\r\n64位双精度浮点数(double-precision 64-bit floating point format）\r\n其中双精度浮点数是用来表示带有小数部分的实数\r\n双精度浮点数最多有15或16位十进制有效数字,即53位二进制有效数字\r\nIEEE-754规定\r\n64位二进制存储单元由3部分组成 1+11+52 1是表示正负数 11是表示指数位置 52则是数据值位置\r\n所以因为单位存储空间限制，安全整数的范围是1位正数加52位数据位 即53位二进制，超过只能溢出到指数位置存储，无法安全表示，所以安全整数的位数是\r\n`Number.MAX_SAFE_INTEGER.toString(2).length;`\r\n\r\nhttps://github.com/anjia/blog/issues/87",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Feahter",
            "url": "https://github.com/Feahter"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzNjI2ODA=",
    "number": 649,
    "title": "【Q631】在 Node 中如何读写文件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3NzczNzIyNA==",
          "body": "1. open\r\n2. read\r\n3. close",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzNjc1NjM=",
    "number": 650,
    "title": "【Q632】在 Node 中如何发送请求",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40iyud",
          "body": "如果使用原生 API，可使用 `http/https` 核心模块\r\n\r\n``` js\r\nconst https = require('https');\r\n\r\nhttps.get('https://icanhazip.com', (res) => {\r\n  console.log('statusCode:', res.statusCode);\r\n  console.log('headers:', res.headers);\r\n  let data = ''\r\n\r\n  res.on('data', (chunk) => {\r\n    data += chunk\r\n  })\r\n\r\n  res.on('end', () => {\r\n    console.log(data)\r\n  })\r\n\r\n}).on('error', (e) => {\r\n  console.error(e);\r\n});\r\n\r\n```\r\n\r\n如果使用第三方库的话，可使用 `axios` 等。\r\n\r\n目前，Node 团队抛弃了核心模块 http/https 从头开发了一个新的 http client，名为 [undeci](https://github.com/nodejs/undici)，将有可能成为以后默认的 http client\r\n\r\n``` js\r\nimport { request } from 'undici'\r\n\r\nconst {\r\n  statusCode,\r\n  headers,\r\n  trailers,\r\n  body\r\n} = await request('http://localhost:3000/foo')\r\n\r\nconsole.log('response received', statusCode)\r\nconsole.log('headers', headers)\r\n\r\nfor await (const data of body) {\r\n  console.log('data', data)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzNjgyMjc=",
    "number": 651,
    "title": "【Q633】Node 中服务端框架如何解析 http 的请求体 body",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40p48F",
          "body": "在 Node 服务中，通过 `http.createServer` 接收到的 req 为可读流，对流进行读取数据\r\n\r\n``` js\r\nconst server = http.createServer((req, res) => {\r\n  let body = ''\r\n  req.on('data', chunk => body += chunk)\r\n  req.on('end', () => {\r\n    data = body\r\n    res.end(data)\r\n  })\r\n})\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40rdqe",
          "body": "body-parser?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzODM2OTk=",
    "number": 652,
    "title": "【Q644】统计字符串中出现次数最多的字符及次数",
    "body": "这是一道大厂面试出现频率超高的编程题\r\n\r\n``` js\r\n//=> ['a', 6]\r\ngetFrequentChar('aaabbaaacc')\r\n\r\n//=> ['a', 3]\r\ngetFrequentChar('aaa')\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3Nzc1MTg2MQ==",
          "body": "见代码实现: [统计字符串中出现次数最多的字符及次数- codepen](https://codepen.io/shanyue/pen/YzVGjrv?editors=0012)\r\n\r\n``` js\r\nfunction getFrequentChar (str) {\r\n  const dict = {}\r\n  for (const char of str) {\r\n    dict[char] = (dict[char] || 0) + 1\r\n  }\r\n  const maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n  return maxBy(Object.entries(dict), x => x[1])\r\n}\r\n```\r\n\r\n以下方案一边进行计数统计一遍进行大小比较，只需要 1 次 `O(n)` 的算法复杂度\r\n\r\n``` js\r\nfunction getFrequentChar2 (str) {\r\n  const dict = {}\r\n  let maxChar = ['', 0]\r\n  for (const char of str) {\r\n    dict[char] = (dict[char] || 0) + 1\r\n    if (dict[char] > maxChar[1]) {\r\n      maxChar = [char, dict[char]]\r\n    }\r\n  }\r\n  return maxChar\r\n}\r\n```",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3OTkyOTIxNQ==",
          "body": "```js\r\n  // entries + sort\r\n  function getFrequentChar (str) {\r\n    const dict = {}\r\n    for (const char of str) {\r\n      dict[char] = (dict[char] || 0) + 1\r\n    }\r\n    let list = Object.entries(dict)\r\n    list.sort((a, b) => b[1] - a[1])\r\n    return list[0]\r\n  }\r\n\r\n  \r\n  // test\r\n  let r = getFrequentChar('aaabccd')\r\n  console.log(r)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cyio",
            "url": "https://github.com/cyio"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3OTk0NDgwOA==",
          "body": "@cyio  使用 sort 复杂度立马就上去了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDMyMjgxMQ==",
          "body": "> @cyio 使用 sort 复杂度立马就上去了\r\n\r\n什么复杂度，时间？sort 更快",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cyio",
            "url": "https://github.com/cyio"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDM3NjI4MQ==",
          "body": "> > @cyio 使用 sort 复杂度立马就上去了\r\n> \r\n> 什么复杂度，时间？sort 更快\r\n\r\nsort 时间复杂度肯定就上去了，它内部的时间复杂度 O(nlogn)，肯定没有手写 maxBy，只需要 On 的复杂度",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDc3MDk3OA==",
          "body": "恩， 你说的是对的。不过，实际在 chrome/node 中执行，发现 sort 大部分情况下更快。 \r\n```js\r\nlet s = function() {\r\n\r\n  function getFrequentChar (str) {\r\n    const dict = {}\r\n    for (const char of str) {\r\n      dict[char] = (dict[char] || 0) + 1\r\n    }\r\n    const maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n    return maxBy(Object.entries(dict), x => x[1])\r\n  }\r\n  \r\n  function getFrequentCharSort (str) {\r\n    const dict = {}\r\n    for (const char of str) {\r\n      dict[char] = (dict[char] || 0) + 1\r\n    }\r\n    let list = Object.entries(dict)\r\n//     console.log(list)\r\n    list.sort((a, b) => b[1] - a[1])\r\n    return list[0]\r\n  }\r\n\r\n  function generateRamStr(len, charSet) {\r\n    const chars = charSet || \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n    let randomStr = \"\";\r\n    for (var i = 0; i < len; i++) {\r\n      randomStr += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return randomStr;\r\n  }\r\n\r\n  let str = generateRamStr(10 ** 5)\r\n  // console.log(str)\r\n\r\n  // test\r\n  console.time('reduce')\r\n  let r = getFrequentChar(str)\r\n  console.timeEnd('reduce')\r\n  //  console.log(r)\r\n\r\n  console.time('sort')\r\n  let r2 = getFrequentCharSort(str)\r\n  console.timeEnd('sort')\r\n  // console.log(r2)\r\n}\r\n\r\nfor (let i = 0; i < 10; i++) {\r\n  s()\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cyio",
            "url": "https://github.com/cyio"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDc3MTA5NQ==",
          "body": "恩， 你说的是对的。不过，实际在 chrome/node 中扫行，发现 sort 大部分情况下更快。 \r\n```js\r\nlet s = function() {\r\n\r\n  function getFrequentChar (str) {\r\n    const dict = {}\r\n    for (const char of str) {\r\n      dict[char] = (dict[char] || 0) + 1\r\n    }\r\n    const maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n    return maxBy(Object.entries(dict), x => x[1])\r\n  }\r\n  \r\n  function getFrequentCharSort (str) {\r\n    const dict = {}\r\n    for (const char of str) {\r\n      dict[char] = (dict[char] || 0) + 1\r\n    }\r\n    let list = Object.entries(dict)\r\n//     console.log(list)\r\n    list.sort((a, b) => b[1] - a[1])\r\n    return list[0]\r\n  }\r\n\r\n  function generateRamStr(len, charSet) {\r\n    const chars = charSet || \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n    let randomStr = \"\";\r\n    for (var i = 0; i < len; i++) {\r\n      randomStr += chars.charAt(Math.floor(Math.random() * chars.length));\r\n    }\r\n    return randomStr;\r\n  }\r\n\r\n  let str = generateRamStr(10 ** 5)\r\n  // console.log(str)\r\n\r\n  // test\r\n  console.time('reduce')\r\n  let r = getFrequentChar(str)\r\n  console.timeEnd('reduce')\r\n  //  console.log(r)\r\n\r\n  console.time('sort')\r\n  let r2 = getFrequentCharSort(str)\r\n  console.timeEnd('sort')\r\n  // console.log(r2)\r\n}\r\n\r\nfor (let i = 0; i < 10; i++) {\r\n  s()\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cyio",
            "url": "https://github.com/cyio"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDgwMzI3OQ==",
          "body": "@cyio 我试了下，把关于 r/r2 的代码调换下顺序，结果就相反了，明天我搞一个两方各执行一万次的 benchmark 试一试",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CM7nk",
          "body": "```js\r\nfunction longStr(str) {\r\n      let results = []\r\n      for(let key of str) {\r\n         const reg = new RegExp(key, 'g') \r\n         const arr = str.match(reg) || []\r\n         if(arr.length>results.length) {\r\n            results = arr \r\n         }\r\n      }\r\n      return [results[0], results.length]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shengrongchun",
            "url": "https://github.com/shengrongchun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YP0S9",
          "body": "> > @cyio 使用 sort 复杂度立马就上去了\r\n> \r\n> 什么复杂度，时间？sort 更快\r\n\r\n做题看时间复杂度就行了吧，实际环境v8有各种优化，就说不清了。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        },
        {
          "id": "IC_kwDODQzyOs5g-k1Q",
          "body": "```js\r\nconsole.log(getFrequentChar('aacc'))\r\nconsole.log(getFrequentChar('aaccccaaaa'))\r\nconsole.log(getFrequentChar('baaaabbcc'))\r\n\r\nfunction getFrequentChar(string) {\r\n  let obj = {}\r\n  let maxStr = ['', 0]\r\n  for (const char of string) {\r\n    obj[char] = (obj[char] || 0) + 1\r\n    // obj[char] ? obj[char]++ : (obj[char] = 1)\r\n    if (obj[char] > maxStr[1]) {\r\n      maxStr = [char, obj[char]]\r\n    } else if (obj[char] === maxStr[1]) {\r\n      maxStr = maxStr.concat([char, obj[char]])\r\n    }\r\n  }\r\n  return maxStr\r\n}\r\n```\r\n\r\n学到了，学到就是赚到 😄",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDEzOTM4MDE=",
    "number": 653,
    "title": "【Q635】请输出 100 以内的菲波那切数列",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3Nzk0MTE5OQ==",
          "body": "``` js\r\nfunction fib (n) {\r\n  let a = 0, b = 1;\r\n  let r = [0]\r\n  while (b < n) {\r\n    r.push(b);\r\n    [a, b] = [b, a + b];\r\n  }\r\n  return r\r\n}\r\n```",
          "star": {
            "totalCount": 6
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40pxiv",
          "body": "```javascript\r\nfunction Fibonacci (n, ac1 = 1, ac2 = 1, arr = [0]) {\r\n    if (n <= ac2) {\r\n        return arr\r\n    }\r\n    arr.push(ac2)\r\n    return Fibonacci(n, ac2, ac1 + ac2, arr)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs400Dxw",
          "body": "```js\r\nfunction fibonacciDp(n) {\r\n  const f = [];\r\n  f[0] = 0;\r\n  f[1] = 1;\r\n  for(let i = 2; i < n; i++) {\r\n    f[i] = f[i - 1] + f[i - 2];\r\n  }\r\n  return f;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5E-TIK",
          "body": "function fib(n, fib1 = 1, fib2 = 1, result = []) {\r\n    if(n <= fib1){ \r\n      return result\r\n    }\r\n    result.push(fib1)\r\n    return fib(n, fib2, fib1 + fib2, result)\r\n  }",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "Jie-echo",
            "url": "https://github.com/Jie-echo"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDE0NTQ0ODA=",
    "number": 654,
    "title": "【Q636】你们项目中使用了哪些依赖/第三方库",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs47ViZq",
          "body": "lodash axios  echarts file-saver patch-package qs sortablejs vue-clipboard2 xlsx watermark-dom",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Mikerui",
            "url": "https://github.com/Mikerui"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDIwODQ1ODE=",
    "number": 655,
    "title": "【Q637】如何使用正则匹配一个汉字",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400b1u",
          "body": "`/\\p{Unified_Ideograph}/u`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangjiayan",
            "url": "https://github.com/wangjiayan"
          }
        },
        {
          "id": "IC_kwDODQzyOs46gIgK",
          "body": "var pattern1 = /[\\u4e00-\\u9fa5]+/g;\r\nvar contents = \"[微笑][撇嘴][发呆][得意][流泪]\";\r\nvar content = contents.match(pattern1);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jkLennon",
            "url": "https://github.com/jkLennon"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        },
        {
          "id": "MDU6TGFiZWwzMjE2MjE2NDU2",
          "name": "regexp"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDIxMDQ4MzI=",
    "number": 656,
    "title": "【Q638】如何把字符串全部转化为小写格式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3OTUxNjIzNQ==",
          "body": "```js\r\nconst convert = str => str.replace(/[A-Z]/g, l => l.toLowerCase())\r\n\r\n// test\r\nconvert('aCd')\r\nconvert('aCd123')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cyio",
            "url": "https://github.com/cyio"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3OTgyNDY1Ng==",
          "body": "在 ES6+ 中，可直接使用原生 API `String.prototype.toLowerCase()` 实现\r\n\r\n如果手写实现，如下所示\r\n\r\n``` js\r\nconst lowerCase = str => {\r\n  let result = ''\r\n  for (let char of str) {\r\n    const charAt = char.charCodeAt()\r\n    if (charAt <= 'Z'.charCodeAt() && charAt >= 'A'.charCodeAt()) {\r\n      char = String.fromCharCode(charAt + 32)\r\n    }\r\n    result += char\r\n  }\r\n  return result \r\n}\r\n\r\n//=> 'hello'\r\nlowerCase('HELLO')\r\n\r\n//=> '山月'\r\nlowerCase('山月')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg3OTgyNDk3NQ==",
          "body": "> ```js\r\n> const convert = str => str.replace(/[A-Z]/g, l => l.toLowerCase())\r\n> \r\n> // test\r\n> convert('aCd')\r\n> convert('aCd123')\r\n> ```\r\n\r\n如果不使用 API 如何做",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDQzODcyNQ==",
          "body": "不使用API是指什么\r\n\r\n> > ```js\r\n> > const convert = str => str.replace(/[A-Z]/g, l => l.toLowerCase())\r\n> > \r\n> > // test\r\n> > convert('aCd')\r\n> > convert('aCd123')\r\n> > ```\r\n> \r\n> 如果不使用 API 如何做\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDYwNjE5Mw==",
          "body": "@Asarua 就是 `toLowerCase`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDY5NzY2Nw==",
          "body": "> @Asarua 就是 `toLowerCase`\n\n原来如此，那还好，我以为不让用字符串所有的api",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDUyNjk2ODM=",
    "number": 657,
    "title": "【Q639】HTTP 与 TCP 中的 keep-alive 各是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5MCzRZ",
          "body": "这两个完全是两样不同东西，实现的层面也不同：\r\n\r\n首先：\r\n- TTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；\r\n- TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Zss1990",
            "url": "https://github.com/Zss1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MCzWX",
          "body": "详细可参考：[面试官：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？_小林coding的技术博客_51CTO博客](https://blog.51cto.com/u_14888059/3812567)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Zss1990",
            "url": "https://github.com/Zss1990"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        },
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDUyODcwNzk=",
    "number": 658,
    "title": "【Q640】如何实现数组函数 reduce",
    "body": "满足以下两个测试用例\r\n\r\n``` js\r\n// => 55\r\nreduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y)\r\n\r\n// => 155\r\nreduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y, 100)\r\n\r\n// => NaN\r\nreduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y, undefined)\r\n```\r\n\r\n以下有一个特殊的测试用例，**可考虑，可不考虑**\r\n\r\n``` js\r\n// 在 lodash 中为 NaN\r\n// 在原生API 中为 15\r\nreduce([1, 2, 3, 4, 5,,,,,,,,,,,], (x, y) => x + y)\r\n```\r\n\r\nTC39 规范在此: <https://tc39.es/ecma262/#sec-array.prototype.reduce>。可参考标准，但无需按照标准实现。",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDYyMjI2MA==",
          "body": "代码见 [如何实现数组函数 reduce](https://codepen.io/shanyue/pen/dyWmLgQ?editors=0012)，可调试与测试用例\r\n\r\n``` js\r\nconst reduce = (list, fn, ...init) => {\r\n  let next = init.length ? init[0] : list[0]\r\n  for (let i = init.length ? 0 : 1; i < list.length; i++) {\r\n    next = fn(next, list[i], i)\r\n  }\r\n  return next\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDYyNDI4OA==",
          "body": "```javascipt\r\nArray.prototype.Reduce1 = function(callback, initialValue) {\r\n  if (typeof callback !== 'function') {\r\n    throw new TypeError('callback not a function');\r\n  }\r\n\r\n  const array = this;\r\n  const len = array.length;\r\n  let accumulator = null;\r\n  let currentIndex = 0;\r\n  let currentValue = null;\r\n  if (initialValue == null) {\r\n    // 没传入初始值的时候，取数组中第一个非 empty 的值为初始值\r\n    while(currentIndex < len && !(currentIndex in array)) {\r\n      currentIndex++;\r\n    }\r\n    if (currentIndex >= len) {// 未提供initialValue且无法在数组中找到有效值,报错\r\n      throw new Error('array is empty and initialValue is null');\r\n    }\r\n    accumulator = array[currentIndex++];\r\n  } else {\r\n    accumulator = initialValue;\r\n  }\r\n\r\n  while (currentIndex < len) {\r\n    if (currentIndex in array) {\r\n      currentValue = array[currentIndex];\r\n      accumulator = callback(accumulator, currentValue, currentIndex, array);\r\n    }\r\n    currentIndex++; \r\n  }\r\n  return accumulator;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDY4NTY2OQ==",
          "body": "```javascript\r\n\r\n\r\nArray.prototype.reduce = function reduce (fun, init) {\r\n    const length = this.length\r\n    let result\r\n    let start\r\n    if (typeof fun !== 'function') {\r\n        throw new TypeError('is not fun')\r\n    }\r\n    if (length === 0 && init === undefined) {\r\n        throw new TypeError('')\r\n    }\r\n    if (init !== undefined) {\r\n        result = init\r\n        start = 0\r\n    } else {\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.hasOwnProperty(i)) {\r\n                result = this[i]\r\n                start = i + 1\r\n                break\r\n            }\r\n        }\r\n        if (start === undefined) {\r\n            throw new TypeError('')\r\n        }\r\n    }\r\n\r\n    for (let i = start; i < length; i++) {\r\n        if (this.hasOwnProperty(i)) {\r\n            result = fun(result, this[i], i, this)\r\n        }\r\n    }\r\n    return result\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDY5MTE2OA==",
          "body": "@heretic-G 有点小问题，对于第二个测试用例\r\n\r\n``` js\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reduce1((x, y) => x + y, 120)\r\n//=> 120\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hLD9",
          "body": "```javascript\r\nfunction reduce(arr, cb, init) {\r\n  const l = arr.length\r\n\r\n  if (!l) {\r\n    if (init) return init\r\n    else throw new TypeError('Error')\r\n  }\r\n\r\n  if (init) {\r\n    for (let i = 0; i < l; i++) {\r\n      init = cb(init, arr[i], i, arr)\r\n    }\r\n    return init\r\n  } else {\r\n    let final\r\n    for (let i = 0; i < l; i++) {\r\n      final = cb(\r\n        !i ? arr[i++] : final,\r\n        !i ? arr[i++] : arr[i],\r\n        i,\r\n        arr\r\n      )\r\n    }\r\n    return final\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs40kv_H",
          "body": "```\r\n Array.prototype._reduce = function(arr, fn, defaultPre) {\r\n  let sum = 0;\r\n  let pre = defaultPre ?? arr[0];\r\n  for(let i = 0; i < arr.length; i+=1) {\r\n    pre = sum;\r\n    sum = fn(pre, arr[i], i, arr);\r\n  }  \r\n  return sum;\r\n }\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "IC_kwDODQzyOs400r13",
          "body": "> 满足以下两个测试用例\r\n> \r\n> ```js\r\n> // => 55\r\n> reduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y)\r\n> \r\n> // => 155\r\n> reduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (x, y) => x + y, 100)\r\n> ```\r\n\r\n@shfshanyue \r\n\r\n数组的`map`、`forEach`、`filter`等方法，需要考虑`callback `函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用\r\n`[0, , 2 , 3]`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs40-UHu",
          "body": "@haotie1990 这块确实没想到，我写一下\r\n\r\n---\r\n\r\n我查了下 `lodash.reduce` 没有此测试用例，因此我把它贴在题目描述中，可实现可不实现",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5EgazF",
          "body": "使用 `forEach`遍历可以过滤 `undefined`\r\n```javascript\r\nfunction reduce(arr, fn, init) {\r\n  let pre = init ? init : arr[0];\r\n  let startIndex = init ? 0 : 1;\r\n  arr.slice(startIndex).forEach((cur) => {\r\n    pre = fn(pre, cur);\r\n  });\r\n  console.log(pre);\r\n  return pre;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangjs-jacky",
            "url": "https://github.com/wangjs-jacky"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Fj6ga",
          "body": "@Kiera569 如果是undefined,测试用例无法通过",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "caomeibuaichibaicai",
            "url": "https://github.com/caomeibuaichibaicai"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YvE8W",
          "body": "```javascript\r\nfunction reduce(handle, initial) {\r\n\tlet arr = this;\r\n\r\n\tif (initial != null && arr.length == 0) {\r\n\t\treturn initial;\r\n\t}\r\n\r\n\tif (arr.length <= 0) {\r\n\t\tthrow new Error(\"array can't is empty\");\r\n\t}\r\n\r\n\tfunction next(pre, index) {\r\n\t\tif (index >= arr.length) {\r\n\t\t\treturn pre;\r\n\t\t}\r\n\r\n\t\tlet r = handle(pre, arr[index], index, arr);\r\n\t\treturn next(r, index + 1);\r\n\t}\r\n\r\n\tlet res;\r\n\tif (initial) {\r\n\t\tres = next(initial, 0);\r\n\t} else {\r\n\t\tres = next(arr[0], 1);\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nArray.prototype.reduce = reduce;\r\n\r\nlet arr = [1, 2, 3];\r\nlet res = arr.reduce((pre, cur, index, array) => {\r\n\treturn pre + cur;\r\n}, 0);\r\n\r\nconsole.log(res);\r\n\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "yxw007",
            "url": "https://github.com/yxw007"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDUzOTM5NTk=",
    "number": 659,
    "title": "【Q641】redis 中的哨兵与集群模式各是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDUzOTcxNjQ=",
    "number": 660,
    "title": "【Q642】在 Node 中流 (stream) 分为几类，有哪些应用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400DQ8",
          "body": "Node.js 中有四种基本的流类型：\r\n\r\n- Writable: 可以写入数据的流（例如，`fs.createWriteStream()`）。\r\n\r\n- Readable: 可以从中读取数据的流（例如，`fs.createReadStream()`）。\r\n\r\n- Duplex: Readable 和 Writable 的流（例如，`net.Socket`）。\r\n\r\n- Transform: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，`zlib.createDeflate()`）",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs402oFh",
          "body": "+ [Node 中流的类型](https://nodejs.org/api/stream.html#stream_types_of_streams)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDU1MzI3OTk=",
    "number": 661,
    "title": "【Q643】如何实现 chunk 函数，数组进行分组",
    "body": "示例如下：\r\n\r\n``` js\r\n// => [[1, 2, 3], [4, 5, 6], [7]]\r\nchunk([1, 2, 3, 4, 5, 6, 7], 3)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40hz5T",
          "body": "``` js\r\nfunction chunk (list, size) {\r\n  const l = []\r\n  for (let i = 0; i < list.length; i++ ) {\r\n    const index = Math.floor(i / size)\r\n    l[index] ??= [];\r\n    l[index].push(list[i])\r\n  }\r\n  return l\r\n}\r\n```\r\n\r\n或者直接构造出每一个 chunk\r\n\r\n``` js\r\nfunction chunk(list, size) {\r\n  const l = []\r\n\r\n  for (let i = 0; i < list.length; i += size) {\r\n    const chunk = list.slice(i, i + size)\r\n    l.push(chunk)\r\n  }\r\n\r\n  return l\r\n}\r\n```",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400DIe",
          "body": "```js\r\nfunction chunk(array, limit) {\r\n  limit = array.length <= limit ? array.length : limit;\r\n  const result = [];\r\n  while(array.length) {\r\n    result.push(array.splice(0, limit));\r\n  }\r\n  return result;\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs406FaI",
          "body": "@haotie1990 这种实现方式很漂亮，但是有可能有副作用，当传入数组时，数组会被置空，可以先 `[...array]` 浅拷贝一份",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5XHXY9",
          "body": "```js\r\nfunction chunk(list = [], size) {\r\n  return list.reduce((pre, cur) => {\r\n    const length = pre.length;\r\n    if (length === 0 || pre[length - 1].length === size)\r\n      return pre.concat([[cur]]);\r\n    else {\r\n      pre[length - 1].push(cur);\r\n      return pre;\r\n    }\r\n  }, []);\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kirazZ1",
            "url": "https://github.com/kirazZ1"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDU1MzU2OTk=",
    "number": 662,
    "title": "【Q644】实现一个异步的 sum/add",
    "body": "> 这是一道字节跳动的面试题目，见面经 [某银行前端一年半经验进字节面经](https://juejin.cn/post/6959364219162607630)。山月认为这也是一道水平较高的题目，promise 串行，并行，二分，并发控制，层层递进。\r\n\r\n请实现以下 sum 函数，只能调用 add 进行实现\r\n\r\n``` js\r\n/*\r\n  请实现一个 sum 函数，接收一个数组 arr 进行累加，并且只能使用add异步方法\r\n  \r\n  add 函数已实现，模拟异步请求后端返回一个相加后的值\r\n*/\r\nfunction add(a, b) {\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nfunction sum(arr) {\r\n  \r\n}\r\n```\r\n\r\n**追加问题：如何控制 add 异步请求的并发次数**\r\n\r\n相关问题：\r\n\r\n+ [【Q088】如何实现 promise.map，限制 promise 并发数](https://github.com/shfshanyue/Daily-Question/issues/89)\r\n+ [【Q643】如何实现 chunk 函数，数组进行分组](https://github.com/shfshanyue/Daily-Question/issues/661)",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDgzOTAyMA==",
          "body": "\r\n```js\r\n!async function () {\r\n        function add(a, b) {\r\n            // return new Promise((resolve)=>{\r\n            //     setTimeout(()=>{\r\n            //         resolve(a+b)\r\n            //     },1000)\r\n            // })\r\n            return Promise.resolve(a + b)\r\n        }\r\n        async function changeArr(arr) {//两两相加转化为新数组\r\n            let reArr = []\r\n            for (let i = 0; i < arr.length; i += 2) {\r\n                if (arr[i + 1] === undefined) {//如果是奇数个数组,只把最后一个push进去\r\n                    reArr.push(Promise.resolve(arr[i]))\r\n                } else {\r\n                    reArr.push(add(arr[i], arr[i + 1]))\r\n                }\r\n            }\r\n            return await Promise.all(reArr)\r\n        }\r\n        async function sum(arr) {\r\n            if (arr.length < 2) {//数组长度小于2\r\n                return arr[0]\r\n            }\r\n            let result = await changeArr(arr)//处理数组,两两相加转化为新数组\r\n            if (result.length < 2) {//递归结束条件\r\n                return result[0]\r\n            } else {\r\n                return sum(result)//递归两两相加\r\n            }\r\n        }\r\n        const r = await sum([2,2,2,2,2])\r\n        console.log(r)\r\n    }()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mtt3366",
            "url": "https://github.com/mtt3366"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hI3e",
          "body": "## 初级实现: 串行方式\r\n\r\n遇到这种题目，第一反应就是如同同步 sum 的实现一样，一个一个进行累加。\r\n\r\n以下是一个借助于 `Array.prototype.reduce` 实现的 Promise 版本。\r\n\r\n这里一个注意的点是：**不能将 0 作为累加器的初始值，因此 add 为异步的，不能保证 `add(x, 0) === x`**\r\n\r\n```js\r\nfunction sum(arr) {\r\n  if (arr.length === 1) return arr[0];\r\n  return arr.reduce((x, y) => Promise.resolve(x).then((x) => add(x, y)));\r\n}\r\n```\r\n\r\n借助于 `async/await` 的异步 sum 的实现，逻辑更为清楚，同样我们把初始值设置为数组中第一个数，而非 0。\r\n\r\n``` js\r\nasync function sum(arr) {\r\n  let s = arr[0]\r\n  for (let i = 1; i < arr.length; i++) {\r\n    s = await add(s, arr[i])\r\n  }\r\n  return s\r\n}\r\n```\r\n\r\n[代码片段](https://code.juejin.cn/pen/7091460261323735048)\r\n\r\n不管是基于 promise 还是 async 实现，这应该是大部分人的第一反应，然而还有很多同学，直接最简单的实现无法通过，很可能无法通过面试。\r\n\r\n但是它有一个问题，在异步sum函数中，**其中最为耗时的是 add()，因为他是一个异步 IO 操作，模拟的是服务器数据请求，假设 add 延时一秒，此时需要 N-1 秒，延时太长。**\r\n\r\n## 中级实现: 并行方式\r\n\r\n关于上边的同步实现，有可能就会筛了一部分同学。面试官到了这里，就会继续增加难度。\r\n\r\n接下来是并行的写法: **我们实现一个 `chunk` 函数，将数组两两分组，每两个计算一次，使用 chunk 二分，此时延时变为 logN 秒**\r\n\r\n关于 `chunk` 的 API 可以参考 [lodash.chunk](https://lodash.com/docs/4.17.15#concat): `_.concat(array, [values])`，在平常工作中也会用到。\r\n\r\n```js\r\nfunction chunk(list, size) {\r\n  const l = [];\r\n  for (let i = 0; i < list.length; i++) {\r\n    const index = Math.floor(i / size);\r\n    l[index] ??= [];\r\n    l[index].push(list[i]);\r\n  }\r\n  return l;\r\n}\r\n```\r\n\r\n**在通过 chunk 进行两两分组时，有可能最后一项为单数，此时直接返回数值即可，在最终得到结果后，迭代该函数继续二分，直到最后只有一个数值。**\r\n\r\n``` js\r\nasync function sum(arr) {\r\n  if (arr.length === 1) return arr[0];\r\n  const promises = chunk(arr, 2).map(([x, y]) =>\r\n    // 注意此时单数的情况\r\n    y === undefined ? x : add(x, y)\r\n  );\r\n  return Promise.all(promises).then((list) => sum(list));\r\n}\r\n```\r\n\r\n[代码片段](https://code.juejin.cn/pen/7091470717836853255)\r\n\r\n写到这里，感觉难度还不是很大，注意，此时使用的是 `Promise.all`，意味着不管 `Promise.all` 所接收的数组中有多少元素，将会同时进行处理。\r\n\r\n此时面试官会进行扩展: **比如有10000个数据，那第一次就会发送5000个请求，网络拥堵了，我想控制成只能同时发送10个请求怎么办？**\r\n\r\n## 更进一步: 控制并行数\r\n\r\n如果需要控制并行数，则可以先实现一个 `promise.map` 用以控制并发，这也是在面试中经常考察的一个点。使用 `promise.map` 来代替上一步的 `promise.all`。\r\n\r\n关于 `promise.map` 的 API 可以参考 `bluebird`: `new Promise(function(function resolve, function reject) resolver) -> Promise`。\r\n\r\n与上一步相同，使用 sum 迭代该函数继续二分，直到最后只有一个数值。\r\n\r\n```js\r\nfunction pMap(list, mapper, concurrency = Infinity) {\r\n  return new Promise((resolve, reject) => {\r\n    let currentIndex = 0;\r\n    let result = [];\r\n    let resolveCount = 0;\r\n    let len = list.length;\r\n    function next() {\r\n      const index = currentIndex++;\r\n      Promise.resolve(list[index])\r\n        .then((o) => mapper(o, index))\r\n        .then((o) => {\r\n          result[index] = o;\r\n          if (++resolveCount === len) {\r\n            resolve(result);\r\n          }\r\n          if (currentIndex < len) {\r\n            next();\r\n          }\r\n        });\r\n    }\r\n    for (let i = 0; i < concurrency && i < len; i++) {\r\n      next();\r\n    }\r\n  });\r\n}\r\n\r\nasync function sum(arr, concurrency) {\r\n  if (arr.length === 1) return arr[0];\r\n  return pMap(\r\n    chunk(arr, 2),\r\n    ([x, y]) => {\r\n      return y === undefined ? x : add(x, y);\r\n    },\r\n    concurrency\r\n  ).then((list) => sum(list, concurrency));\r\n}\r\n```\r\n\r\n关于 `promise.map` 还有一个更简单的实现，可参考 [async-pool](https://github.com/rxaviers/async-pool/blob/master/lib/es9.js)",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hJ93",
          "body": "```javascript\r\nfunction add(a, b) {\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nasync function sum(arr) {\r\n  let su = 0\r\n  for (const item of arr) {\r\n    su = await add(su, item)\r\n  }\r\n  return su\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hMPS",
          "body": "```javascript\r\n\r\nPromise.map = function (queue = [], opt = { }) {\r\n    let limit = opt.limit || 5\r\n    let queueIndex = 0\r\n    let completeCount = 0\r\n    let _resolve\r\n    let result = Array(queue.length)\r\n\r\n    for (let i = 0; i < limit; i++) {\r\n        next(queueIndex++)\r\n    }\r\n\r\n    function next (index) {\r\n        if (queue.length === 0) return\r\n        let curr = queue.shift()\r\n        if (typeof curr === 'function') {\r\n            curr = curr()\r\n        }\r\n        Promise.resolve(curr).then((res) => {\r\n            result[index] = res\r\n        }, (res) => {\r\n            result[index] = res\r\n        }).finally(() => {\r\n            completeCount += 1\r\n            if (completeCount === result.length) {\r\n                return _resolve(result)\r\n            }\r\n            next(queueIndex++)\r\n        })\r\n    }\r\n    return new Promise((resolve) => {\r\n        _resolve = resolve\r\n    })\r\n}\r\n\r\nfunction add (a, b) {\r\n    return Promise.resolve(a + b)\r\n}\r\n\r\nfunction sum (arr) {\r\n    if (arr.length <= 2) {\r\n        return add(arr[0] || 0, arr[1] || 0)\r\n    }\r\n    let mid = arr.length / 2 | 0\r\n    let promiseArr = []\r\n    for (let i = 0; i < mid; i++) {\r\n        promiseArr.push(add(arr[i], arr[mid + i]))\r\n    }\r\n    return Promise.map(promiseArr).then(res => {\r\n        if (arr.length % 2 !== 0) {\r\n            res.push(arr.pop())\r\n        }\r\n        return sum(res)\r\n    })\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs40hSag",
          "body": "串行\r\n```javascript\r\nconst sum = arr => arr.reduce(async (acc, item)=> add(await acc, item), Promise.resolve(0))\r\n```\r\n\r\n并行\r\n```javascript\r\nconst sum = arr => {\r\n  if (arr.length === 0) {\r\n    return 0\r\n  }\r\n\r\n  if (arr.length === 1) {\r\n    return arr[0]\r\n  }\r\n\r\n  const promiseArr = arr.reduce(\r\n    (acc, item, index) => {\r\n      if (index % 2 === 0) {\r\n        acc.push(arr.slice(index, index + 2))\r\n      }\r\n      return acc\r\n    },\r\n    []\r\n  ).map(chunk =>\r\n    chunk.length === 2\r\n      ? add(...chunk)\r\n      : Promise.resolve(chunk[0])\r\n  )\r\n\r\n  return Promise.all(promiseArr).then(sum)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "grace-shi",
            "url": "https://github.com/grace-shi"
          }
        },
        {
          "id": "IC_kwDODQzyOs40h2py",
          "body": "```javascript\r\nfunction add(a, b) {\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nasync function sum(arr){\r\n    let res = 0;\r\n    if(arr.length === 0) return res;\r\n    if(arr.length === 1) return arr[0];\r\n\r\n    let a = arr.pop();\r\n    let b = arr.pop();\r\n    arr.push(await add(a, b));\r\n    return sum(arr)\r\n}\r\n\r\nsum([2,2,2,2]).then(res=>{console.log(res)})\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mahaoming",
            "url": "https://github.com/mahaoming"
          }
        },
        {
          "id": "IC_kwDODQzyOs40h5x6",
          "body": "@mahaoming 这个思路眼前一亮啊！不过貌似是串行的\r\n\r\n> ```js\r\n> function add(a, b) {\r\n>   return Promise.resolve(a + b);\r\n> }\r\n> \r\n> async function sum(arr){\r\n>     let res = 0;\r\n>     if(arr.length === 0) return res;\r\n>     if(arr.length === 1) return arr[0];\r\n> \r\n>     let a = arr.pop();\r\n>     let b = arr.pop();\r\n>     arr.push(await add(a, b));\r\n>     return sum(arr)\r\n> }\r\n> \r\n> sum([2,2,2,2]).then(res=>{console.log(res)})\r\n> ```\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40h-CA",
          "body": "```javascript\r\nfunction add(a, b) {\r\n  // return a+b\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nasync function sum(arr) {\r\n  if (arr.length <= 2) {\r\n    const r= await add(arr[0]||0, arr[1] || 0)\r\n    return r\r\n  } else {\r\n    const len1 = Math.floor(arr.length/2)\r\n    const s1 = await sum(arr.slice(0,len1))\r\n    const s2 = await sum(arr.slice(len1))\r\n    return s1+s2\r\n  }\r\n}\r\nsum([1,2,3,4,5]).then(console.log)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lulusir",
            "url": "https://github.com/lulusir"
          }
        },
        {
          "id": "IC_kwDODQzyOs40zy-z",
          "body": "```js\r\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\nfunction add(a, b) {\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nfunction sum(arr, add) {\r\n  return arr.reduce((p, c) => {\r\n    return p.then(acc => {\r\n      if (!acc) {\r\n        acc = 0;\r\n      }\r\n      return add(acc, c);\r\n    });\r\n  }, Promise.resolve());\r\n}\r\n\r\n// 将数组拆分，分别计算，最后累加\r\nfunction sumPoll(arr, add, concurrency = Infinity) {\r\n  const chunks = [];\r\n  const len = arr.length <= concurrency ? arr.length : concurrency;\r\n  while (arr.length) {\r\n    chunks.push(arr.splice(0, len));\r\n  }\r\n  const tasks = [];\r\n  for (const chunk of chunks) {\r\n    tasks.push(chunk.reduce((p, c) => p.then(acc => {\r\n      if (!acc) acc = 0;\r\n      return add(acc, c);\r\n    }), Promise.resolve()));\r\n  }\r\n  return Promise.all(tasks).then(result => {\r\n    if (result.length === 1) {\r\n      return result[0];\r\n    }\r\n    return sumPoll(result, add);\r\n  });\r\n}\r\n\r\nsumPoll(arr, add, 3).then(result => console.log(result));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs4106Md",
          "body": "```js\r\n// 这是一道字节跳动的面试题目，见面经 某银行前端一年半经验进字节面经。山月认为这也是一道水平较高的题目，promise 串行，并行，二分，并发控制，层层递进。\r\n  // 请实现以下 sum 函数，只能调用 add 进行实现\r\n  /*\r\n    请实现一个 sum 函数，接收一个数组 arr 进行累加，并且只能使用add异步方法\r\n    add 函数已实现，模拟异步请求后端返回一个相加后的值\r\n  */\r\n  function add(a, b) {\r\n    return new Promise((resolve) => {\r\n      setTimeout(() => {\r\n        resolve(a + b);\r\n      }, 10);\r\n    });\r\n  }\r\n\r\n  // 异步串行 迭代 + promise\r\n  function sum(arr) {\r\n    // Promise.resolve传人一个promise会等传人的promise执行完毕再then\r\n    return arr.reduce((pre, next) => {\r\n      console.log(1);\r\n      // 瞬间循环完，然后会将当前作为一个primise返回到下一个，\r\n      //利用Promise.resolve入参是promise会等待的特点，异步线程会串行相加\r\n      return Promise.resolve(pre).then((x) => add(x, next));\r\n    }, 0);\r\n  }\r\n  // console.log(sum([1,2,3,4,5]).then(res=>console.log(res)))\r\n\r\n  // 异步串行 : async await 实现异步串行\r\n  async function sum2(arr) {\r\n    let su = 0;\r\n    for (let item of arr) {\r\n      console.log(2); // 等待打印\r\n      su = await add(su, item);\r\n    }\r\n    return su;\r\n  }\r\n  // console.log(sum2([1,2,3,4,5]).then(res=>console.log(res)))\r\n  // 异步串行: genrator实现\r\n  function sum3(arr) {\r\n    let sumGen = function* () {\r\n      let su = 0;\r\n      for (let item of arr) {\r\n        su = yield add(su, item);\r\n      }\r\n      return su;\r\n    };\r\n    let it = sumGen();\r\n    function co(it) {\r\n      return new Promise((resolve, reject) => {\r\n        function next(val) {\r\n          let { value, done } = it.next(val);\r\n          if (done) {\r\n            resolve(value);\r\n          } else {\r\n            Promise.resolve(value).then((data) => {\r\n              next(data);\r\n            }, reject);\r\n          }\r\n        }\r\n        next();\r\n      });\r\n    }\r\n    return co(it);\r\n  }\r\n  // console.log(sum3([1, 2, 3, 4, 5]).then((res) => console.log(res)));\r\n\r\n  // 并行\r\n  async function sum4(arr) {\r\n    if (arr.length == 0) return add(0, 0);\r\n    if (arr.length == 1) return add(0, arr[0]);\r\n    if (arr.length == 2) return add(arr[0], arr[1]);\r\n    let mid = Math.floor(arr.length / 2);\r\n    let [l, r] = await Promise.all([\r\n      sum4(arr.slice(0, mid)),\r\n      sum4(arr.slice(mid)),\r\n    ]);\r\n    return sum4([l, r]);\r\n  }\r\n  console.log(sum4([1, 2, 3, 4, 5, 6, 7, 8]).then((res) => console.log(res)));\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CD3Bj",
          "body": "function add(a, b) {\r\n  return Promise.resolve(a + b);\r\n}\r\n\r\nfunction sum(arr) {\r\n  const promises = []\r\n  for(let i=0,j=arr.length;i<j;i=i+2) {\r\n      promises.push(add(arr[i]||0,arr[i+1]||0))\r\n  }\r\n    Promise.all(promises).then((arr)=> {\r\n        const result = arr.reduce((total,item)=> {\r\n            return total+item\r\n        },0)\r\n    })\r\n}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shengrongchun",
            "url": "https://github.com/shengrongchun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5l43Sm",
          "body": "并发计算，最小时间\r\n\r\n```javascript\r\nfunction sum(arr: any[]) {\r\n  return new Promise((resolve, reject) => {\r\n    let rest = [...arr];\r\n    let addIngCount = 0;\r\n    function next() {\r\n      if (addIngCount === 0 && rest.length <= 1) {\r\n        resolve(rest[0] ?? 0);\r\n        return;\r\n      }\r\n      for (let i = 0; i < rest.length - 1; i = i + 2) {\r\n        addIngCount++;\r\n        add(rest[i], rest[i + 1]).then((result) => {\r\n          rest.push(result);\r\n          addIngCount--;\r\n          next();\r\n        });\r\n      }\r\n      rest = rest.length % 2 === 1 ? [rest[rest.length - 1]] : [];\r\n    }\r\n    next();\r\n  });\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "cloudGrin",
            "url": "https://github.com/cloudGrin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYxMDUyNTA=",
    "number": 663,
    "title": "【Q645】随机生成六位数的手机验证码(重复/不可重复)",
    "body": "> 字节跳动面经一道面试题，见 <https://juejin.cn/post/6959364219162607630>\r\n\r\n相关题目:\r\n\r\n+ [【Q447】如何实现一个数组洗牌函数 shuffle](https://github.com/shfshanyue/Daily-Question/issues/455)",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40h7GW",
          "body": "``` js\r\nconst random = n => Math.floor(Math.random() * (n + 1))\r\n\r\n// 可生成重复的随机验证码\r\nfunction randomCode () {\r\n  return [0, 0, 0, 0, 0, 0].map(() => random(9))\r\n}\r\n\r\n// 不可生成重复的随机验证码\r\nconst shuffle = (list) => list.sort((x, y) => Math.random() - 0.5)\r\nconst randomUniqueCode = () => shuffle([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).slice(0, 6)\r\n\r\n// 一种比较低效的解法\r\nfunction randomUniqueCode2 () {\r\n  let i = 0;\r\n  let l = []\r\n  while (i < 6) {\r\n    const x = random(9)\r\n    if (!l.includes(x)) {\r\n      i++;\r\n      l.push(x)\r\n    }\r\n  }\r\n  return l\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40iBh-",
          "body": "// 不可重复\r\n```js\r\nconst numArr = [] \r\nwhile(numArr.length < 6){\r\n    let num = parseInt(Math.random()*10)\r\n    if(numArr.indexOf(num) === -1){\r\n        numArr.push(num)\r\n    }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "real-jacket",
            "url": "https://github.com/real-jacket"
          }
        },
        {
          "id": "IC_kwDODQzyOs40iB5r",
          "body": "```javascript\r\n\r\nfunction sample (length) {\r\n    let arr = Array(100).fill(1).map((_, i) => i / 10 | 0)\r\n    return shuffle(arr, length)\r\n}\r\n\r\nfunction notSample (length) {\r\n    let arr = Array(10).fill(1).map((_, i) => i)\r\n    return shuffle(arr, length)\r\n}\r\n\r\nfunction shuffle (arr, length) {\r\n    let index = 0\r\n    while (index < length) {\r\n        let changeIndex = arr.length - 1 - index\r\n        let randomIndex = Math.round(Math.random() * (changeIndex - 1))\r\n        let temp = arr[changeIndex]\r\n        arr[changeIndex] = arr[randomIndex]\r\n        arr[randomIndex] = temp\r\n        index += 1\r\n    }\r\n    return arr.slice(arr.length - length).join('')\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-U1fY",
          "body": "//可重复的\r\nfunction liunum() {\r\n    let yanzheng = ''\r\n    for (let i = 0; i < 6; i++) {\r\n        let num = Math.floor(Math.random()*10)\r\n        yanzheng += num\r\n    }\r\n    return yanzheng\r\n}\r\nlet num = liunum()\r\nconsole.log('重复的',num);\r\n//不可重复的\r\nfunction liunum1() {\r\n    let yanzheng1 = ''\r\n    for (let j = 0; j < 6; j++) {\r\n        let num1 = Math.floor(Math.random()*10)\r\n        if (yanzheng1.indexOf(num1)==-1)yanzheng1 += num1\r\n        else j--;\r\n    }\r\n    return yanzheng1\r\n}\r\nlet num1 = liunum1()\r\nconsole.log('不重复的',num1);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liunengnengneng",
            "url": "https://github.com/liunengnengneng"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-dI4l",
          "body": "```typescript\r\nconst randTo = (n: number) => ~~(Math.random() * (n + 1))\r\n\r\nconst shuffle = (list: Array<any>) => list.sort(() => Math.random() - 0.5)\r\n\r\n// 随机生成六位数的手机验证码(重复/不可重复)\r\nconst vc = ({ len = 6, repeat = true } = {}) => {\r\n  if (len > 10 && repeat === false) {\r\n    throw new Error('len should less equal than 10 if repeat is false')\r\n  }\r\n  if (repeat) {\r\n    return Array(len)\r\n      .fill(0)\r\n      .map(() => randTo(9))\r\n  } else {\r\n    return shuffle([...Array(10).keys()]).slice(0, len)\r\n  }\r\n}\r\n\r\nconsole.log(vc())\r\nconsole.log(vc({ len: 9 }))\r\nconsole.log(vc({ repeat: false }))\r\nconsole.log(vc({ len: 9, repeat: false }))\r\nconsole.log(vc({ len: 11, repeat: false }))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "okyokuto",
            "url": "https://github.com/okyokuto"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-n0la",
          "body": "``` js\r\nconst random = (length) => Math.floor(Math.random() * length);\r\n\r\n// 重复\r\nconst randomCode = () => {\r\n  return [...new Array(6)].map((i) => random(10));\r\n};\r\n\r\n// 不重复\r\nconst randomUniqueCode = () => {\r\n  let arr = [...new Array(10)].map((_, index) => index);\r\n  return [...new Array(6)].map((i) => {\r\n    const selectIndex = random(arr.length);\r\n    return arr.splice(selectIndex, 1)[0];\r\n  });\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "createhappymemoryforlife",
            "url": "https://github.com/createhappymemoryforlife"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYxNzIyNjU=",
    "number": 664,
    "title": "【Q646】如何禁止打开浏览器控制台",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40mIX-",
          "body": "> https://github.com/AEPKILL/devtools-detector",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYzNDcxMzk=",
    "number": 665,
    "title": "【Q647】Array 中那些 API 可改变自身",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_LWCw",
          "body": "增删改\r\npush，pop，shift，unshift，splice",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "avatar0813",
            "url": "https://github.com/avatar0813"
          }
        },
        {
          "id": "IC_kwDODQzyOs5XW0Rm",
          "body": "push,pop,shift,unshift,splice,reverse,sort",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Elooer",
            "url": "https://github.com/Elooer"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYzNjY0Njc=",
    "number": 666,
    "title": "【Q648】如何把一个数组 Array 转化为迭代器 Iterable",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40iykK",
          "body": "``` js\r\nconst list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\nconst it = list[Symbol.iterator]()\r\n\r\nit.next()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDYzNzg0Nzc=",
    "number": 667,
    "title": "【Q649】如何去除字符串首尾空白字符",
    "body": "实现一个 trim 函数，如同原生的 `Array.prototype.trim`，以下有两个测试用例\r\n\r\n``` js\r\n//=> hello\r\n'    hello   '.trim()\r\n\r\n//=> hello\r\n'    hello   \\t\\n'.trim()\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40kxXR",
          "body": "在正则表达式中，`\\s` 指匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于`[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]`。\r\n\r\n``` js\r\nconst trim = str => str.trim || str.replace(/^\\s+|\\s+$/g, '')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40kx9E",
          "body": "```javascript\r\nfunction trim (str = '') {\r\n    str = String(str)\r\n    let left = 0\r\n    let right = str.length - 1\r\n    while (/\\s/.test(str[left]) && left < right) {\r\n        left += 1\r\n    }\r\n\r\n    while (/\\s/.test(str[right]) && left < right) {\r\n        right -= 1\r\n    }\r\n    return str.slice(left, right + 1)\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-n2wt",
          "body": "> ```js\r\n> const trim = str => str.trim || str.replace(/^\\s+|\\s+$/g, '')\r\n> ```\r\n\r\nconst trim = str => str.trim?.() || str.replace(/^\\s+|\\s+$/g, '')\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "createhappymemoryforlife",
            "url": "https://github.com/createhappymemoryforlife"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YvJ92",
          "body": "```javascript\r\nfunction trim() {\r\n\tlet str = this;\r\n\tlet len = str.length;\r\n\tif (len <= 0) {\r\n\t\treturn str;\r\n\t}\r\n\r\n\tlet l = 0;\r\n\tlet r = str.length - 1;\r\n\r\n\twhile (l <= r) {\r\n\t\tif (str[l] == \" \") {\r\n\t\t\tl++;\r\n\t\t}\r\n\t\tif (str[r] == \" \") {\r\n\t\t\tr--;\r\n\t\t}\r\n\t\tif (str[l] != \" \" && str[r] != \" \") {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tlet res = str.slice(l, r + 1);\r\n\treturn res;\r\n}\r\n\r\nString.prototype.trim = trim;\r\n\r\nlet s = \"  123\";\r\nconsole.log(s.trim().length);\r\n\r\nlet s1 = \"123 \";\r\nconsole.log(s1.trim().length);\r\n\r\nlet s2 = \" \";\r\nconsole.log(s2.trim().length);\r\n\r\nlet s3 = \"\";\r\nconsole.log(s3.trim().length);\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yxw007",
            "url": "https://github.com/yxw007"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY3MjIwMDU=",
    "number": 668,
    "title": "【Q650】http 各个版本间各有什么改进",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY3ODIzNzM=",
    "number": 669,
    "title": "【Q651】简述 http3，http3 解决了什么问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40kfk5",
          "body": "http3是基于UDP协议的。\r\n它主要解决了http1.1和http2都存在的队头阻塞，TCP和TLS的握手时延问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mingshengxiao",
            "url": "https://github.com/mingshengxiao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY3ODI2MDA=",
    "number": 670,
    "title": "【Q652】http2 中 Stream 与 Frame 是什么关系",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40ke7P",
          "body": "+ Stream 为 Request/Response 报文的双向通道，一个完整资源的请求与相应是一个 stream，特殊的 stream 作为 Settings、Window_Update 等 Frame 发送的通道\r\n+ Frame 为 http2 通信的最小单位，有 Data、Headers 等，一个 Stream 包含多个 Frame，如一条 http 请求包含 Header、Data Frame 等\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/20210619/image.yf6of3e60w0.png)\r\n\r\n![image](https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg)",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDY5OTE1MDM=",
    "number": 671,
    "title": "【Q653】useLayoutEffect 和 useEffect 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40pffc",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40xz8l",
          "body": "dom 时间，一个是之前，一个是之后",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs408CcD",
          "body": "可以参考：[useEffect 和 useLayoutEffect 的区别 - 掘金](https://juejin.cn/post/6844904008402862094) 和 [useEffect和useLayoutEffect到底有什么区别？](https://github.com/yaofly2012/note/issues/149#issuecomment-660593917) 这两篇文章\r\n\r\n- useLayoutEffect 和 componentDidMount 和 componentDidUpdate 触发时机一致（都在在 DOM 修改后且浏览器渲染之前）；\r\n- useLayoutEffect 要比 useEffect 更早的触发执行；\r\n- useLayoutEffect 会阻塞浏览器渲染，切记执行同步的耗时操作",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "luoheix",
            "url": "https://github.com/luoheix"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcwMjU0ODg=",
    "number": 672,
    "title": "【Q654】css加载会阻塞DOM树的解析和渲染吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40pey9",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44Unz1",
          "body": "css加载会直接影响网页的渲染，因为只有css加载完毕，构建完 CSSOM 后，渲染树(Render Tree)才会构建，然后渲染成位图\r\n\r\n如果html中有加载script的话，还会间接影响DOM树的解析，因为javascript的下载、解析和执行和阻塞DOM树的解析，而javascript中有可能访问CSSOM，比如 Element.getBoundingClientRect，因此CSSOM构建完毕以后才会开始javascript的执行，间接阻塞dom树的解析",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcwMjc2NTM=",
    "number": 673,
    "title": "【Q655】实现 intersection，取数组交集",
    "body": "类似 `lodash.intersection`，有以下测试用例\r\n\r\n``` js\r\n//=> [2]\r\nintersection([2, 1], [2, 3]);\r\n\r\n//=> [1, 2]\r\nintersection([1, 2, 2], [1, 2, 2])\r\n\r\n//=> [1, 2]\r\nintersection([1, 2, 2], [1, 2, 2], [1, 2])\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40kwmz",
          "body": "``` js\r\nconst intersection = (...list) => {\r\n  const result = list.reduce((x, y) => x.filter(i => y.includes(i)))\r\n  return [...new Set(result)]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40kw8X",
          "body": "```js\r\nconst intersection = (...list) => list.reduce((a, b) => [...new Set(a.filter(item => b.includes(item)))])\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Kiera569",
            "url": "https://github.com/Kiera569"
          }
        },
        {
          "id": "IC_kwDODQzyOs40kw9A",
          "body": "```javascript\r\n\r\nfunction intersection (...args) {\r\n    if (args.length === 0) return []\r\n    for (let i = 0; i < args.length; i++) {\r\n        if (!Array.isArray(args[i])) {\r\n            args[i] = [args[i]]\r\n        }\r\n    }\r\n    if (args.length === 1) return [...new Set(args[0])]\r\n    let index = 1\r\n    let sameArr = args[0]\r\n    while (index < args.length) {\r\n        let tempArr = []\r\n        for (let i = 0;i < args[index].length; i++) {\r\n            if (sameArr.includes(args[index][i])) {\r\n                tempArr.push(args[index][i])\r\n            }\r\n        }\r\n        sameArr = tempArr\r\n        if (sameArr.length === 0) return []\r\n        index += 1\r\n    }\r\n    return [...new Set(sameArr)]\r\n}\r\n\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs40lifo",
          "body": "```javascript\r\nconst intersection = (...args) => [...new Set(args.reduce((prev, next) => prev.filter(v => next.includes(v))))]\r\n```\r\nemm，绕了一圈绕回来了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs40liqV",
          "body": "@Asarua 去重一下，看第二个示例，而且还有可能是多个数组呀，我去补一下测试用例",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40lir_",
          "body": "> @Asarua 去重一下，看第二个示例\r\n\r\n已改",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs400C21",
          "body": "```js\r\nfunction intersection() {\r\n  const arrays = [].slice.call(arguments, 0);\r\n  const result = arrays.reduce(function(acc, arr){\r\n    return acc.filter((v) => arr.indexOf(v) !== -1);\r\n  });\r\n  return result.reduce((acc, c) => {\r\n    if (acc.indexOf(c) === -1) {\r\n      acc.push(c);\r\n    }\r\n    return acc;\r\n  }, []);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5dpqhD",
          "body": "```\r\n// 取数组交集\r\n\r\n/**\r\n * \r\n * \r\n * @param  {...any} arr 剩余数组\r\n * @returns \r\n * 思路:\r\n * 1.设置两个数组，一个存放未重复的数组元素，一个存放已重复的数组元素\r\n * 2.在总的数组的循环中，如果数组元素在未重复数组中，又出现一次，则将其推入已重复数组\r\n * 3.使用Set,去除多余的元素，使用Array.from将Set实例转化为数组，并返回\r\n */\r\nfunction intersection(...arr){\r\n  let filterArr = [];\r\n  let duplicateArr = []\r\n  let sumArr = [].concat(...arr)\r\n  sumArr.forEach(element => {\r\n    if(!filterArr.includes(element)){\r\n      filterArr.push(element)\r\n    }else{\r\n      duplicateArr.push(element)\r\n    }\r\n  });\r\n  return Array.from(new Set(duplicateArr));\r\n}\r\n\r\n//=> [2]\r\nconsole.log('intersection([2, 1], [2, 3]);: ', intersection([2, 1], [2, 3]));\r\n\r\n//=> [1, 2]\r\nconsole.log('intersection([1, 2, 2], [1, 2, 2]): ', intersection([1, 2, 2], [1, 2, 2]));\r\n\r\n//=> [1, 2]\r\nconsole.log('intersection([1, 2, 2], [1, 2, 2], [1, 2]): ', intersection([1, 2, 2], [1, 2, 2], [1, 2]));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rujptw",
            "url": "https://github.com/rujptw"
          }
        },
        {
          "id": "IC_kwDODQzyOs5gnUSR",
          "body": "```js\r\nconst intersection = (...arr) => [...new Set(arr.reduce((pre, cur) => pre.filter(item => cur.includes(item))))]\r\n// [ 2, 3 ]\r\nconsole.log(intersection([2, 3, 3], [2, 2, 3, 1], [2, 3, 1, 5]))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcwNjMwNTI=",
    "number": 674,
    "title": "【Q656】JS 中如何实现 call/apply",
    "body": "在 JS 中如何实现 call/apply?\r\n\r\n相关问题:\r\n\r\n+ [【Q033】如何实现一个 bind](https://github.com/shfshanyue/Daily-Question/issues/32)\r\n+ [【Q034】如何实现一个 softbind](https://github.com/shfshanyue/Daily-Question/issues/33)",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40ljJ3",
          "body": "``` js\r\nconst call = (fn, thisObj, ...args) => {\r\n  thisObj.fn = fn;\r\n  const r = thisObj.fn(...args);\r\n  delete thisObj.fn; \r\n  return r;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41CCva",
          "body": "bind/softBind/apply/call 都是this显式绑定的方法\r\n\r\n- bind会返回一个硬绑定的新函数，新函数会使用指定的第一个thisCtx去调用原始函数，并将其它参数传给原始函数。 硬绑定会降低函数的灵活性，在绑定之后不能通过显式或硬绑定的方式改变this，只能通过new改变\r\n- softBind 会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就用指定的thisCtx 去调用函数，否则不会修改 this  \r\n- apply和call功能相同，都是以指定的thisCtx和参数去执行方法，并返回原方法的返回值，只是apply中参数以数组传递\r\n```javascript\r\nFunction.prototype.myBind = function (ctx = globalThis) {\r\n  const fn = this;\r\n  const args = Array.from(arguments).slice(1);\r\n  function bound() {\r\n    if (this instanceof bound) {\r\n      fn.apply(this, args);\r\n    } else {\r\n      fn.apply(ctx, args);\r\n    }\r\n  }\r\n  bound.prototype = fn.prototype;\r\n  return bound;\r\n};\r\n```\r\n\r\n```javascript\r\nFunction.prototype.mySoftBind = function (ctx = globalThis) {\r\n  const fn = this;\r\n  const args = Array.from(arguments).slice(1);\r\n  function bound() {\r\n    if (!this || this === globalThis) {\r\n      fn.apply(ctx, args);\r\n    } else {\r\n      fn.apply(this, args);\r\n    }\r\n  }\r\n  bound.prototype = fn.prototype;\r\n  return bound;\r\n};\r\n```\r\n\r\n```javascript\r\nFunction.prototype.myCall = function (ctx = globalThis) {\r\n  const args = Array.from(arguments).slice(1);\r\n  const key = Symbol(\"key\");\r\n  ctx[key] = this;\r\n  const res=ctx[key](...args);\r\n  delete ctx[key]\r\n  return res\r\n};\r\n```\r\n```javascript\r\nFunction.prototype.myApply = function (ctx = globalThis) {\r\n  const args = arguments[1];\r\n  const key = Symbol(\"key\");\r\n  ctx[key] = this;\r\n  const res=ctx[key](...args);\r\n  delete ctx[key]\r\n  return res\r\n};\r\n```",
          "star": {
            "totalCount": 11
          },
          "author": {
            "login": "wussss",
            "url": "https://github.com/wussss"
          }
        },
        {
          "id": "IC_kwDODQzyOs41CDws",
          "body": "```javascript\r\n\r\nFunction.prototype.call = function call(arm, ...args) {\r\n    let fun = this\r\n    if (typeof fun !== 'function') throw TypeError('must is function')\r\n    let armObj = arm\r\n    if (typeof arm !== 'object') {\r\n        armObj = Object(arm)\r\n    }\r\n    \r\n    let symbolKey = Symbol('tempKey')\r\n    armObj[symbolKey] = fun\r\n    let result = armObj[symbolKey](...args)\r\n    delete armObj[symbolKey]\r\n    return result\r\n}\r\n\r\nFunction.prototype.apply = function call(arm, ...args) {\r\n    let fun = this\r\n    if (typeof fun !== 'function') throw TypeError('must is function')\r\n    let armObj = arm\r\n    if (typeof arm !== 'object') {\r\n        armObj = Object(arm)\r\n    }\r\n\r\n    let symbolKey = Symbol('tempKey')\r\n    armObj[symbolKey] = fun\r\n    let result = armObj[symbolKey](args)\r\n    delete armObj[symbolKey]\r\n    return result\r\n}\r\n\r\n// TODO 完善bind 这里其实还有很多问题\r\nFunction.prototype.bind = function aBind (that, ...args) {\r\n    let armFun = this\r\n    if (typeof armFun !== 'function') throw TypeError('must a function')\r\n    function BoundFun (...other) {\r\n        if (new.target) {\r\n            return new armFun(...args, ...other)\r\n        } else {\r\n            return armFun.call(that,...args, ...other)\r\n        }\r\n    }\r\n    BoundFun.__proto__ = armFun.__proto__\r\n    BoundFun.prototype = undefined\r\n    \r\n    return BoundFun\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs4102H4",
          "body": "```js\r\n  let person1 = {\r\n    name: \"Tom\",\r\n    sayHi(to,...args) {\r\n      console.log(`Hi,${to}, my name is ${this.name}。${args && args.toString()}`);\r\n    },\r\n  };\r\n  person1.sayHi();\r\n\r\n  let person2 = {\r\n    name: \"Jerry\",\r\n  };\r\n  // call\r\n  person1.sayHi.call(person2, \"Heydi\");\r\n  // apply\r\n  person1.sayHi.apply(person2, [\"Heydi\"]);\r\n  // bind\r\n  let sayHiToJark = person1.sayHi.bind(person2, \"Heydi\"); // 柯里化\r\n  sayHiToJark(\"Wellcom to you\");\r\n  // my call\r\n  Function.prototype.myCall = function(ctx,...args){\r\n    let fn = this\r\n    if(typeof fn !== 'function') throw TypeError('must is fucntion')\r\n    let thisObj = ctx;\r\n    if(typeof ctx !== 'object'){\r\n      thisObj = Object(ctx)\r\n    }\r\n    const key = Symbol(\"key\");\r\n    thisObj[key] = fn;\r\n    const res = thisObj[key](...args);\r\n    delete thisObj[key];\r\n    return res;\r\n  }\r\n  person1.sayHi.myCall(person2,\"Tim\")\r\n  // my apply\r\n  Function.prototype.myApply = function(ctx,args){\r\n    let fn = this\r\n    if(typeof fn !== 'function') throw TypeError('must is fucntion')\r\n    let thisObj = ctx;\r\n    if(typeof ctx !== 'object'){\r\n      thisObj = Object(ctx)\r\n    }\r\n    if(!Array.isArray(args)) throw TypeError('must is array')\r\n    const key = Symbol(\"key\");\r\n    thisObj[key] = fn;\r\n    const res = thisObj[key](...args);\r\n    delete thisObj[key];\r\n    return res;\r\n  }\r\n  person1.sayHi.myApply(person2,[\"Tim\"])\r\n  // my bind\r\n  Function.prototype.myBind = function(ctx,...args){\r\n    const fn = this\r\n    return function(...args2){\r\n      const key = Symbol(\"key\");\r\n      ctx[key] = fn;\r\n      const res = ctx[key](...args,...args2)\r\n      delete ctx[key]\r\n      return res;\r\n    }\r\n  }\r\n  let sayHiToMary = person1.sayHi.bind(person2,'Mary')\r\n  sayHiToMary('Wellcom to you')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DKu34",
          "body": "```ts\r\nFunction.prototype.myCall = function (target) {\r\n  const args = [].slice.apply(arguments, [1]);\r\n  const fnName = Symbol(\"fn\");\r\n  target[fnName] = this;\r\n  Object.defineProperty(target,fnName,{enumerable:false})\r\n  let res;\r\n  eval(`res  = target[fnName](${args.join(\",\")})`);\r\n  delete target[fnName];\r\n  return res;\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Vi-jay",
            "url": "https://github.com/Vi-jay"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Ev8kk",
          "body": "```javascript\r\n\r\nFunction.prototype.myCall = function (context) {\r\n\t//! 说明：node环境根作用域this 就是globalthis, browser 环境就是window\r\n\tif (context) {\r\n\t\t//! 参数：可能不为对象，所以需要利用Object包裹一层\r\n\t\tif (typeof context !== 'object') {\r\n\t\t\tcontext = Object(context);\r\n\t\t}\r\n\t} else {\r\n\t\tcontext = globalThis;\r\n\t}\r\n\r\n\t//! 说明：由于第一个参数为context，后面的才为调用函数参数，所以需要slice(1)\r\n\tconst args = Array.from(arguments).slice(1);\r\n\r\n\t//! f1 调用的myCall方法, 此时this就是调用的函数本身\r\n\tcontext.fn = this;\r\n\tlet ret = context.fn(...args);\r\n\r\n\t//! 说明：不应该改变了this指向，就给调用方法的对象添加一个方法属性，所以调用完后需要删除\r\n\tdelete context.fn;\r\n\r\n\treturn ret;\r\n}\r\n\r\nfunction f1() {\r\n\tconsole.log(\"f1, this:\", this, \",arguments:\", arguments);\r\n}\r\n\r\nf1.myCall(\"hello\", \"123\");\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yxw007",
            "url": "https://github.com/yxw007"
          }
        },
        {
          "id": "IC_kwDODQzyOs5TzxGo",
          "body": "```javascript\r\nFunction.prototype.myCall = function (ctx) {\r\n    ctx ??= globalThis\r\n    ctx = Object(ctx)\r\n\r\n    const args = [...arguments].slice(1)\r\n\r\n    const key = Symbol('key')\r\n    ctx[key] = this\r\n    const res = ctx[key](...args)\r\n    delete ctx[key]\r\n\r\n    return res\r\n}\r\n\r\nFunction.prototype.myApply = function (ctx) {\r\n    ctx ??= globalThis\r\n    ctx = Object(ctx)\r\n\r\n    const args = arguments[1]\r\n\r\n    const key = Symbol('key')\r\n    ctx[key] = this\r\n    const res = ctx[key](...args)\r\n    delete ctx[key]\r\n\r\n    return res\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangtuo1999",
            "url": "https://github.com/zhangtuo1999"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Yb4yw",
          "body": "实现一个call：\r\n```\r\nfunction person(a, b) {\r\n    return {\r\n        name: this.name,\r\n        sum: a + b\r\n    }\r\n}\r\n\r\nconst yeti = {\r\n    name: 'yeti'\r\n}\r\n\r\n// 实现一个call\r\nFunction.prototype.newCall = function (obj, ...args) {\r\n    const window = { windwo: 'window' }\r\n    if (!obj) {\r\n        obj = window\r\n    }\r\n    obj.p = this    //此处的this是person函数 相当于在obj中添加了一个person方法\r\n    const resCall = obj.p(...args)  //由于函数可能会返回值，所以将执行的结果保存并返回\r\n    delete obj.p\r\n    return resCall\r\n\r\n}\r\n\r\nconst res = person.newCall(yeti, 1, 2)\r\nconsole.log(res);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yeti-xxx",
            "url": "https://github.com/Yeti-xxx"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Yb5cI",
          "body": "实现一个apply:\r\n```\r\nfunction person(a, b, c) {\r\n    console.log(Math.max.apply(null, [...arguments]));\r\n    console.log(Math.max.newApplay(null, [...arguments]));\r\n    return {\r\n        name: this.name,\r\n        sum: a + b + c\r\n    }\r\n}\r\n\r\nconst yeti = {\r\n    name: 'yeti'\r\n}\r\n// 实现一个apply\r\nFunction.prototype.newApplay = function (obj, arr) {\r\n    const window = { windwo: 'window' }\r\n    if (!obj) {\r\n        obj = window\r\n    }\r\n    obj.p = this\r\n    if (!arr) { //如果为传入参数数组，直接执行\r\n        const resnewApply = obj.p()\r\n        delete obj.p\r\n        return resnewApply\r\n    } else {\r\n        const resnewApply = obj.p(...arr)\r\n        delete obj.p\r\n        return resnewApply\r\n    }\r\n\r\n}\r\n\r\nconst resApplay = person.newApplay(yeti, [1, 2, 6])\r\nconsole.log(resApplay);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yeti-xxx",
            "url": "https://github.com/Yeti-xxx"
          }
        },
        {
          "id": "IC_kwDODQzyOs5ksv5Y",
          "body": "如果contxt中原本就有同名的fn属性呢，调用完你这个call之后，原本的fn属性就消失了 @yxw007 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "algok-876",
            "url": "https://github.com/algok-876"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDcyMTEzOTc=",
    "number": 675,
    "title": "【Q657】实现一个 composeLeft/flow(从左向右) 函数，进行函数合成",
    "body": "实现一个 composeLeft/flow(从左向右) 函数，进行函数合成，类似于 `lodash.flow`\r\n\r\n\r\n``` js\r\nconst add10 = x => x + 10\r\nconst mul10 = x => x * 10\r\nconst add100 = x => x + 100\r\n\r\n// (10 + 10) * 10 + 100 = 300\r\nflow(add10, mul10, add100)(10)\r\n```\r\n\r\n相关问题: [【Q181】如何实现 compose 函数，进行函数合成](https://github.com/shfshanyue/Daily-Question/issues/182)",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40lV9e",
          "body": "// 我这个好理解，不够优雅\r\n```\r\nfunction compose(fn){\r\n    let args = [].slice.call(arguments)\r\n    return function(){\r\n        let sum = 0\r\n        let params = [].slice.call(arguments)[0]\r\n        for(let i = 0; i< args.length; i++){\r\n            let f = args[i]\r\n            sum += f(params)\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ovarte",
            "url": "https://github.com/ovarte"
          }
        },
        {
          "id": "IC_kwDODQzyOs40lW1V",
          "body": "@ovarte 使用 markdown 语法做代码高亮吧，这个 Issue 可以重复编辑，多余的 Issue 可以删掉。另外，这个问题和以前的重复了，我改为了从左到右执行了\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40lXGK",
          "body": "``` js\r\nconst flow = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40likH",
          "body": "```javascript\r\nfunction compose (...funArr) {\r\n    return function (...args) {\r\n        let result = args\r\n        for (let i = 0;i < funArr.length;i++) {\r\n            if (typeof funArr[i] === 'function') {\r\n                result = [funArr[i](...result)]\r\n            }\r\n        }\r\n        return result.length === 1 ? result[0] : result\r\n    }\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs400Bxr",
          "body": "```js\r\n/**\r\n * 创建一个函数。 返回的结果是调用提供函数的结果，\r\n * this 会绑定到创建函数。 每一个连续调用，\r\n * 传入的参数都是前一个函数返回的结果\r\n * @param {Function|Function[]} funcs 要调用的函数\r\n */\r\nfunction flow(funcs) {\r\n  if (!Array.isArray(funcs)) {\r\n    funcs = [funcs];\r\n  }\r\n  const context = this;\r\n  return function() {\r\n    let args = [].slice.call(arguments, 0);\r\n    return funcs.reduce((acc, func) => {\r\n      acc = Array.isArray(acc) ? acc : [acc];\r\n      return func.apply(context, acc);\r\n    }, args);\r\n  }\r\n}\r\n\r\nconst add10 = x => x + 10\r\nconst mul10 = x => x * 10\r\nconst add100 = x => x + 100\r\n\r\nconsole.log(flow([add10, mul10, add100])(10));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs44U9Y1",
          "body": "```javascript\r\nconst lodashFlow = (...fns) => (...args) => fns.reduce((a, b) => b(+a), args.map(a => +a))\r\n\r\nconst add10 = x => x + 10\r\nconst mul10 = x => x * 10\r\nconst add100 = x => x + 100\r\nconsole.log(lodashFlow(add10, mul10, add100)(10))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDczMTQxMTU=",
    "number": 676,
    "title": "【Q658】什么是点击劫持(ClickJacking)，如何预防",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40lo7K",
          "body": "可以使用 HTTP X-Frame-Options 响应头以及 `CSP: frame-ancestors` 指令，避免**自己网站被当做 iframe 嵌入到非法网站引导用户点击**\r\n\r\n``` bash\r\nX-Frame-Options: DENY\r\nX-Frame-Options: SAMEORIGIN\r\n```\r\n\r\n或者使用 CSP 的指令 `frame-ancestors` 进行预防\r\n\r\n```bash\r\nContent-Security-Policy: frame-ancestors 'none';\r\nContent-Security-Policy: frame-ancestors 'self' https://www.example.org;\r\n```\r\n\r\n同时，也可以使用 Javascript 进行控制，当发现自身网站置于 iframe 中时，将不予展现\r\n\r\n```html\r\n<head>\r\n</head>\r\n<body>\r\n  <script>\r\n    // 如果发现现在是在 iframe 中\r\n    if (self !== top) {\r\n      document.write('')\r\n    }\r\n  </script>\r\n</body>\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40lo7e",
          "body": "``` bash\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDc2MjM2OTc=",
    "number": 677,
    "title": "【Q659】在 React Hooks 中实现 usePreviouseValue 取上次渲染的值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40oWrx",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CZMxg",
          "body": "```ts\r\nimport { useRef } from \"react\";\r\n\r\ntype ShouldUpdateFunc<T> = (prev: T | undefined, next: T) => boolean;\r\n\r\nconst defalutShouldUpdate = <T>(prev?: T, next?: T) => prev !== next;\r\n\r\nfunction usePrevious<T>(\r\n  state: T,\r\n  shouldUpdateFun: ShouldUpdateFunc<T> = defalutShouldUpdate\r\n): T | undefined {\r\n  const prev = useRef<T>();\r\n  const cur = useRef<T>();\r\n\r\n  if (shouldUpdateFun(cur.current, state)) {\r\n    prev.current = cur.current;\r\n    cur.current = state;\r\n  }\r\n  return prev.current;\r\n}\r\n\r\nexport default usePrevious;\r\n```\r\nahook的实现版本 很简洁",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jarbinup",
            "url": "https://github.com/jarbinup"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDc2ODc1MjU=",
    "number": 678,
    "title": "【Q660】实现一个 render/template 函数，可以用以渲染模板",
    "body": "``` js\r\nconst template = '{{ user[\"name\"] }}，今天你又学习了吗 - 用户ID: {{ user.id }}';\r\n\r\nconst data = {\r\n  user: {\r\n    id: 10086,\r\n    name: '山月',\r\n  }\r\n};\r\n\r\n//=> \"山月，今天你又学习了吗 - 用户ID: 10086\"\r\nrender(template, data); \r\n```\r\n\r\n注意:\r\n\r\n1. 注意深层嵌套数据\r\n2. 注意 `user['name']` 属性\r\n\r\n> 关于复杂的模板编译解析执行，可参考 [mustache](https://github.com/janl/mustache.js) 与 [handlebars.js](https://github.com/handlebars-lang/handlebars.js)",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40mw7C",
          "body": "代码可见 [实现一个 render/template 函数，可以用以渲染模板 - codepen](https://codepen.io/shanyue/pen/yLboJQE?editors=0012)\r\n\r\n``` js\r\nfunction get (source, path, defaultValue = undefined) {\r\n  // a[3].b -> a.3.b -> [a, 3, b]\r\n  const paths = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/\\[\"(\\w+)\"\\]/g, '.$1').replace(/\\['(\\w+)'\\]/g, '.$1').split('.')\r\n  let result = source\r\n  for (const p of paths) {\r\n    result = result?.[p]\r\n  }\r\n  return result === undefined ? defaultValue : result \r\n}\r\n\r\nfunction render (template, data)  {\r\n  return template.replace(/{{\\s+([^\\s]+)\\s+}}/g, (capture, key) => {\r\n    return get(data, key)\r\n  })\r\n}\r\n```",
          "star": {
            "totalCount": 4
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40mxAX",
          "body": "```javascript\r\nfunction render (template, data) {\r\n    return template.replace(/({{).*?(}})/g, function (...args) {\r\n        return Function(`return this.${args[0].slice(2, -2).trim()}`).call(data)\r\n    })\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs40yGwn",
          "body": "```js\r\nfunction template(input, data) {\r\n  const regex = RegExp(/\\{\\{([\\w|\\.|\\[|\\]|\"]+)\\}\\}/, 'g');\r\n  let result;\r\n  while((result = regex.exec(input)) !== null) { // input字符串不能修改\r\n    const [pattern, key] = result;\r\n    // 由于改变了原字符串,但regex.lastIndex并未被重置,仍然从此位置开始匹配\r\n    input = input.replace(pattern, eval(`data.${key}`));\r\n    regex.lastIndex = 0; // 重置lastIndex;\r\n  }\r\n  return input;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs48gW7i",
          "body": "const render = function(template,data){\r\n\t\t return\ttemplate.replace(/\\{\\{(.*?)\\}\\}/g,($0,$1) => eval('data.' + $1))\r\n\t\t}",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "sunwenlong1995",
            "url": "https://github.com/sunwenlong1995"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        },
        {
          "id": "MDU6TGFiZWwzMjE2MjE2NDU2",
          "name": "regexp"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDkzODQzMTY=",
    "number": 679,
    "title": "【Q661】Number 中最大数、最大安全整数、EPSILON 都是多少，原理是什么",
    "body": "可参考 IEEE754 规范",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40r88b",
          "body": "> https://zh.wikipedia.org/zh-cn/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDk3MTYxOTA=",
    "number": 680,
    "title": "【Q662】TCP 是如何进行拥塞控制的",
    "body": "可参考文章: <https://zhuanlan.zhihu.com/p/76023663>",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40s8PD",
          "body": "+ Reno，慢启动，拥塞避免，快重传，快恢复\r\n+ BBR",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
          "name": "tcp"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NDk3NjI5Mzk=",
    "number": 681,
    "title": "【Q663】给定一个数值，给出它在 IEEE754 的表示，如符号位、指数位与分数位",
    "body": "相关问题：\r\n\r\n+ [【Q661】Number 中最大数、最大安全整数、EPSILON 都是多少，原理是什么](https://github.com/shfshanyue/Daily-Question/issues/679)",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40tEqY",
          "body": "代码见: [给定一个数值，给出它在 IEEE754 的表示，如符号位、指数位与分数位 - codepen](https://codepen.io/shanyue/pen/abWLooZ)\r\n\r\n``` js\r\nfunction formatToBinaryExponent (num) {\r\n  const [int, dec] = String(num).split(/(?=\\.)/).map(x => Number(x).toString(2))\r\n  const exponent = (int.length - 1).toString(2)\r\n  const fraction = int.slice(1) + dec.slice(2)\r\n  return {\r\n    exponent,\r\n    fraction: fraction.slice(0, 52),\r\n    sign: num > 0,\r\n    exact: fraction.length < 52,\r\n  }\r\n}\r\n\r\nconsole.log(formatToBinaryExponent(13.5))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTA0NTAyNjU=",
    "number": 682,
    "title": "【Q664】请简述下 Node 与浏览器环境中的事件循环",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40vG0M",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OE1F5",
          "body": "众所周知，js 是单线程的语言，同一时间只做一件事，单线程也就导致一个任务执行完才能执行下一个任务，一旦某个任务执行时间太长就容易造成阻塞，为了解决这一问题，js 引入了事件循环机制\r\n\r\njs 单线程任务分为同步任务和异步任务\r\n\r\n同步任务：立即执行的任务，直接在主线程上排队执行\r\n异步任务：不进入主线程，而是在异步任务有了结果之后将回调函数放入到任务队列中等待主线程空闲时调用执行\r\n\r\n主线程任务执行完毕后从任务队列中不断读取任务，放入到主线程去执行，这个过程是循环不停的\r\n\r\n而异步任务又可以分为宏任务和微任务\r\n\r\n微任务和宏任务\r\n常见微任务：Promise.then，Object.observe，MutationObserver，process.nextTick(Node 环境)\r\n常见宏任务：setTimeout，ajax，dom 事件，setImmediate(Node 环境)，requestAnimationFrame\r\n\r\n同步任务执行完毕后会开始从调用栈中去执行异步任务，优先执行的是微任务，当微任务队列清空后才会去执行宏任务，每次单个宏任务执行完毕后会去检查微任务队列是否为空，如果不为空会按照先入先出的原则执行微任务，待微任务队列清空后再执行下一个宏任务，如此循环往复，这种运行机制就叫做事件循环",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Richard-Zhang1019",
            "url": "https://github.com/Richard-Zhang1019"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTA1MjA2Nzk=",
    "number": 683,
    "title": "【Q665】JS 如何检测到对象中有循环引用",
    "body": "示例，如下数据为循环结构/循环引用\r\n\r\n``` js\r\nconst user = { id: 10086, name: '山月' }\r\nuser._user = user\r\n```\r\n\r\n追问:\r\n\r\n1. 由于 `JSON.stringify` 序列化对象时，将跳过不枚举的 key，因此此时可不考虑不可枚举的 key\r\n2. 如果考虑不可枚举 key 与 Symbol 如何处理",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40vTW0",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40vW-g",
          "body": "```\r\nconst a = {\r\na:1,\r\nc: 3\r\n}\r\n\r\nconst b = {\r\n  a: a,\r\n  c: 3\r\n}\r\na.b = b;\r\n\r\n//JSON.stringify(a);\r\n\r\nconst keyMap = new Map();\r\nkeyMap.set(a, \"1\");\r\nkeyMap.set(b, \"2\");\r\nfunction circle(target) {\r\n  const keys = Object.keys(target);\r\n  for(let i = 0; i < keys.length; i++) {\r\n    const key = keys[i];\r\n    const val = target[key];\r\n    if(keyMap.has(val)) {\r\n      return true\r\n    }else {\r\n      keyMap.set(val, key)\r\n      if(typeof val === 'object') {\r\n        circle(val)\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\nconsole.log(circle(a))\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yoyou",
            "url": "https://github.com/yoyou"
          }
        },
        {
          "id": "IC_kwDODQzyOs40vbIa",
          "body": "> ```\r\n> const a = {\r\n> a:1,\r\n> c: 3\r\n> }\r\n> \r\n> const b = {\r\n>   a: a,\r\n>   c: 3\r\n> }\r\n> a.b = b;\r\n> \r\n> //JSON.stringify(a);\r\n> \r\n> const keyMap = new Map();\r\n> keyMap.set(a, \"1\");\r\n> keyMap.set(b, \"2\");\r\n> function circle(target) {\r\n>   const keys = Object.keys(target);\r\n>   for(let i = 0; i < keys.length; i++) {\r\n>     const key = keys[i];\r\n>     const val = target[key];\r\n>     if(keyMap.has(val)) {\r\n>       return true\r\n>     }else {\r\n>       keyMap.set(val, key)\r\n>       if(typeof val === 'object') {\r\n>         circle(val)\r\n>       }\r\n>     }\r\n>   }\r\n>   return false;\r\n> }\r\n> console.log(circle(a))\r\n> ```\r\n\r\n可以将 `Object.keys()` 替换为 `Reflect.ownKeys()`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iotale",
            "url": "https://github.com/iotale"
          }
        },
        {
          "id": "IC_kwDODQzyOs40vuzS",
          "body": "```js\r\nfunction isCircularReference(value) {\r\n  const isObject = value => Object.prototype.toString.call(value) === '[object Object]';\r\n  const memory = new WeakMap();\r\n  let isCycled = false;\r\n  const traverse = function(value) {\r\n    if (isObject(value)) {\r\n      if (memory.has(value)) {\r\n        isCycled = true;\r\n        return;\r\n      }\r\n      memory.set(value, true);\r\n      const keys = Object.keys(value);\r\n      for (const key of keys) {\r\n        traverse(value[key]);\r\n      }\r\n    }\r\n  }\r\n  traverse(value);\r\n  return isCycled;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs40vxEN",
          "body": "> ```js\r\n> function isCircularReference(value) {\r\n>   const isObject = value => Object.prototype.toString.call(value) === '[object Object]';\r\n>   const memory = new WeakMap();\r\n>   let isCycled = false;\r\n>   const traverse = function(value) {\r\n>     if (isObject(value)) {\r\n>       if (memory.has(value)) {\r\n>         isCycled = true;\r\n>         return;\r\n>       }\r\n>       memory.set(value, true);\r\n>       const keys = Object.keys(value);\r\n>       for (const key of keys) {\r\n>         traverse(value[key]);\r\n>       }\r\n>     }\r\n>   }\r\n>   traverse(value);\r\n>   return isCycled;\r\n> }\r\n> ```\r\n\r\n```js\r\n// isObject改为isPrimitive\r\nconst isPrimitive = value => /Number|Boolean|String|Undefined|Null|Symbol/.test(Object.prototype.toString.call(value));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs40z5E7",
          "body": "希望不可枚举和Symbol 可以Reflect.ownKeys(obj).map(curr => obj[curr]) 获取全部的key对应的values \r\nObject上面也有 不过是分开的 两个API\r\n\r\n```javascript\r\nfunction checkObj (obj, set = new Set()) {\r\n    if (typeof obj === 'object' && obj !== null || Array.isArray(obj)) {\r\n        if (set.has(obj)) {\r\n            return true\r\n        } else {\r\n            set.add(obj)\r\n        }\r\n        return Object.values(obj).some(curr => {       \r\n            return checkObj(curr, set)\r\n        })\r\n    }\r\n    return false\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs42IsVS",
          "body": "```js\r\nfunction isCircular(obj) {\r\n    try {\r\n      JSON.stringify(obj) \r\n    } catch(e) {\r\n       return e.message.includes('Converting circular structure to JSON');\r\n    }\r\n    return false;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hishengs",
            "url": "https://github.com/Hishengs"
          }
        },
        {
          "id": "IC_kwDODQzyOs5reubB",
          "body": "上面没有一个答案是对的啊，试试这个对象返回的都是true\r\n\r\n`const c = {};\r\nconst d = {\r\n    e:c,\r\n    f:c\r\n}`\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cloudGrin",
            "url": "https://github.com/cloudGrin"
          }
        },
        {
          "id": "IC_kwDODQzyOs5reunx",
          "body": "```javascript\r\nfunction hasCircularReference(obj, seenObjects = new Set()) {\r\n  if (typeof obj !== 'object' || obj === null) {\r\n    return false;\r\n  }\r\n\r\n  if (seenObjects.has(obj)) {\r\n    return true;\r\n  }\r\n\r\n  seenObjects.add(obj);\r\n\r\n  for (let key in obj) {\r\n    if (hasCircularReference(obj[key], new Set([...seenObjects]))) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "cloudGrin",
            "url": "https://github.com/cloudGrin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTA3MjEwODA=",
    "number": 684,
    "title": "【Q666】实现二进制与十进制的互相转化的两个函数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40wEiQ",
          "body": "代码见：[实现二进制与十进制的互相转化的两个函数](https://codepen.io/shanyue/pen/GRmMQgy)\r\n\r\n``` js\r\nfunction integerToBin (num) {\r\n  // 64\r\n  const result = []\r\n  while (num / 2) {\r\n    next = num % 2\r\n    num = Math.floor(num / 2)\r\n    result.unshift(next)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction fractionalToBin (num) {\r\n  const result = []\r\n  let i = 0\r\n  while (num !== 0 && i < 54) {\r\n    num = num * 2\r\n    \r\n    next = num >= 1 ? 1 : 0\r\n    num = num % 1\r\n    i++\r\n    result.push(next)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction decToBinary (num) {\r\n  // 1.5\r\n  const [int, fraction] = String(num).split(/(?=\\.)/).map((x, i) => {\r\n    return i === 0 ? integerToBin(x) : fractionalToBin(x)\r\n  })\r\n  return [int, fraction]\r\n}\r\n\r\nfunction binToDec (num) {\r\n  const [_int, _fraction] = String(num).split('.')\r\n  const int = _int.split('').reduceRight((acc, x, i) => {\r\n    return acc + x * 2 ** i\r\n  }, 0)\r\n  const fraction = _fraction ? _fraction.split('').reduce((acc, x, i) => {\r\n    return acc + x * 2 ** -(i + 1)\r\n  }, 0) : 0\r\n  return `${int}${fraction ? '.' + fraction.toString().slice(2) : ''}`\r\n}\r\n\r\nconsole.log(16, integerToBin(16), Number(16).toString(2))\r\nconsole.log(18, integerToBin(18), Number(18).toString(2))\r\nconsole.log(0.5, fractionalToBin(0.5), Number(0.5).toString(2))\r\nconsole.log(0.1, fractionalToBin(0.1), Number(0.1).toString(2))\r\nconsole.log(1.1, decToBinary(1.1), Number(1.1).toString(2))\r\n\r\nconsole.log(7.875, decToBinary(7.875), Number(7.875).toString(2))\r\nconsole.log('111.111', binToDec('111.111'), parseInt('111.111', 2))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40xa0H",
          "body": "```javascript\r\n// 二进制转十进制\r\n\r\nfunction binaryToDecimal (num) {\r\n    let negative = false\r\n    if (num < 0) {\r\n        num = -num\r\n        negative = true\r\n    }\r\n    num += ''\r\n    let point = num.indexOf('.')\r\n    let int\r\n    let intDecimal = 0\r\n    let float\r\n    let floatDecimal = 0\r\n\r\n    if (point > -1) {\r\n        int = num.slice(0, point)\r\n        float = `${num.slice(point + 1)}`\r\n    } else {\r\n        int = num\r\n    }\r\n    if(int) {\r\n        for (let i = 0; i < int.length; i++) {\r\n            intDecimal += int[int.length - i - 1] * Math.pow(2, i)\r\n        }\r\n    }\r\n\r\n    if (float) {\r\n        for (let i = 0; i < float.length; i++) {\r\n            floatDecimal += float[i] * Math.pow(2, -(i + 1))\r\n        }\r\n    }\r\n    let result = ''\r\n    if (negative) {\r\n        result += '-'\r\n    }\r\n    result += (intDecimal + floatDecimal)\r\n    return +result\r\n}\r\n\r\n```\r\n\r\n\r\n```javascript\r\n// 十进制转二进制\r\n\r\nfunction decimalToBinary (num) {\r\n    let negative = false\r\n    if (num < 0) {\r\n        num = -num\r\n        negative = true\r\n    }\r\n    num += ''\r\n    let point = num.indexOf('.')\r\n    let int\r\n    let intBinary = ''\r\n    let float\r\n    let floatBinary = ''\r\n\r\n    if (point > -1) {\r\n        int = num.slice(0, point)\r\n        float = Number(`0${num.slice(point)}`)\r\n    } else {\r\n        int = num\r\n    }\r\n    if(int) {\r\n        int = +int\r\n        while (int >= 1) {\r\n            intBinary = int % 2 + intBinary\r\n            int = int / 2 | 0\r\n        }\r\n    }\r\n\r\n    if (float) {\r\n        while(float) {\r\n            float *= 2\r\n            if (float >= 1) {\r\n                floatBinary += 1\r\n            } else {\r\n                floatBinary += 0\r\n            }\r\n            float = float % 1\r\n        }\r\n    }\r\n    let result = ''\r\n    if (negative) {\r\n        result += '-'\r\n    }\r\n    result += (`${intBinary || 0}.${floatBinary}`)\r\n    return result\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs5YmLNG",
          "body": "> ```diff\r\n> function binToDec (num) {\r\n>   const [_int, _fraction] = String(num).split('.')\r\n> -  const int = _int.split('').reduceRight((acc, x, i) => {\r\n>     return acc + x * 2 ** i\r\n>   }, 0)\r\n>   const fraction = _fraction ? _fraction.split('').reduce((acc, x, i) => {\r\n>     return acc + x * 2 ** -(i + 1)\r\n>   }, 0) : 0\r\n>   return `${int}${fraction ? '.' + fraction.toString().slice(2) : ''}`\r\n> }\r\n> ```\r\n\r\n @shfshanyue 这一行有错误，reducRight 里的 i 是数组元素的当前索引，不是从 0 开始的。例如 13 是 1101，上面方法会计算成 11。\r\n\r\n```js\r\n// 修正\r\nconst int = _int.split('').reduce((acc, x, i, arr) => {\r\n    return acc + Number(x) * 2 ** (arr.length - 1 - i)\r\n}, 0)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEyNDMyOTQ=",
    "number": 685,
    "title": "【Q667】简述下 WebWorker，它如何进行通信",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs407aTv",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs407igZ",
          "body": "js多线程通信，只能访问navigator、setTimeout等有限的api\r\n\r\n通过onmessage和postmessage通信，全局对象是self",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEzMzYxNjk=",
    "number": 686,
    "title": "【Q668】JS 中异步任务为何分为微任务与宏任务",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40xxcd",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40x96I",
          "body": "转一下知乎的回答。\r\n为了插队。\r\n一个 Event Loop，Microtask 是在 Macrotask 之后调用，Microtask 会在下一个Event Loop 之前执行调用完，并且其中会将 Microtask 执行当中新注册的 Microtask 一并调用执行完，然后才开始下一次 Event loop，所以如果有新的 Macrotask 就需要一直等待，等到上一个 Event loop 当中 Microtask 被清空为止。\r\n由此可见， 我们可以在下一次 Event loop 之前进行插队。如果不区分 Microtask 和 Macrotask，那就无法在下一次 Event loop 之前进行插队，其中新注册的任务得等到下一个 Macrotask 完成之后才能进行，这中间可能你需要的状态就无法在下一个 Macrotask 中得到同步。状态的同步对于视图来说至关重要，这也就牵扯到了为什么 javascript 是单线程的原因所在。\r\n\r\n作者：evan\r\n链接：https://www.zhihu.com/question/316514618/answer/1311354630\r\n来源：知乎\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n写了代码很容易理解\r\n```javascript\r\nconsole.log('in')\r\nPromise.resolve().then(() => {\r\n    console.log('promise out1')\r\n    setTimeout(() => { console.log('settimeout in') })\r\n    Promise.resolve().then(() => {\r\n        console.log('promise in1')\r\n    }).then(() => {\r\n        console.log('promise in2')\r\n    })\r\n}).then(() => {\r\n    console.log('promise out2')\r\n})\r\nsetTimeout(() => { console.log('settimeout out') })\r\nconsole.log('out')\r\n// 执行结果：\r\n// in\r\n// out\r\n// promise out1\r\n// promise in1\r\n// promise out2\r\n// promise in2\r\n// settimeout out\r\n// settimeout in\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CheckLee",
            "url": "https://github.com/CheckLee"
          }
        },
        {
          "id": "IC_kwDODQzyOs40z5d5",
          "body": "首先很重要的一个概念是那俩叫做task和job...\r\n\r\n我觉得其实就是为了处理回调地狱的 然后error在job中都是在链中的 不需要在去try，能够保存值在后面then 出来 等等优势\r\n\r\n调用时机的优势在我们的开发中 ....基本无意义 你真会去单纯使用job去处理吗... 不还是要么和io关联要么和task关联去使用 所以我暂时还没有理解job的设计为啥需要和task又这么大的差异\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs44yJO7",
          "body": "为了减少锁的使用和锁的范围，Chromium采用了一个比较巧妙的方法：简单来讲，MessageLoop维护有两个队列，一个work_queue，一个incoming_queue。消息循环不断从work_queue取任务并执行，新加入任务放入incoming_queue。当work_queue中的任务都执行完后，再把incoming_queue拷贝到work_queue（需要加锁）。这样避免了每执行一个任务都要去加锁。\r\n\r\n原文链接：https://blog.csdn.net/wy5761/article/details/44095089",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEzNDM2NzY=",
    "number": 687,
    "title": "【Q669】在 CSS 中，使用 rem 作为单位有何缺点",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40xzyq",
          "body": "1.a11y可访问性不友好,不跟随系统字体\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs40xz4a",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40z5k-",
          "body": "不支持iframe 而且有一个理念问题 大屏是为了更大更清晰还是为了承载更多内容 \r\n\r\n其实这也是现在很多舍弃rem的原因  1:1还原之后 你希望pad也和手机一样？ 大屏手机也和普通手机一样？ 这个我觉得你体验过其实会发现这里其实不是一个好的展示逻辑\r\n\r\n还有一个找到的 但是没有实际踩过得坑 就是在很高的高倍屏上rem会有展示问题 但是我没遇到过...",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTEzNTIwNDE=",
    "number": 688,
    "title": "【Q670】如何提高首屏渲染时间？",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40x0ss",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs40x20A",
          "body": "1. 对于 pv 量比较高的页面，比如b站等流量图也比较大的，采用ssr \r\n   采用 ssr 如何优化性能\r\n    - 性能瓶颈在于 react-dom render/hydrate 和 server 端的 renderToString \r\n    - 尽量减少 dom 结构， 采用流式渲染，jsonString 一个对象，而不是 literal 对象\r\n    - server 去获取数据\r\n    - 不同情况不同分析，减少主线程阻塞时间\r\n    - 减少不必要的应用逻辑在服务端运行\r\n2. 减少依赖和包的体积\r\n   - 利用 webpack 的 contenthash 缓存\r\n   -  重复依赖包处理，可以采用 pnpm\r\n   - 采用code splitting，减少首次请求体积\r\n   - 减少第三方依赖的体积\r\n   \r\n 3. FP (First Paint) 首次绘制\r\n  FCP (First Contentful Paint) 首次内容绘制\r\n  LCP (Largest Contentful Paint) 最大内容渲染\r\n  DCL (DomContentloaded)\r\n  FMP(First Meaningful Paint) 首次有效绘制\r\n  L (onLoad)\r\n  TTI (Time to Interactive) 可交互时间\r\n  TBT (Total Blocking Time) 页面阻塞总时长\r\n  FID (First Input Delay) 首次输入延迟\r\n  CLS (Cumulative Layout Shift) 累积布局偏移\r\n  SI (Speed Index)\r\n  一些性能指标可以监控性能\r\n\r\n4.网络 prefetch cdn ",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        },
        {
          "id": "MDU6TGFiZWwzMDkwODMwMjI5",
          "name": "perf"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTE1MTgzOTM=",
    "number": 689,
    "title": "【Q671】浏览器中监听事件函数 addEventListener 第三个参数有那些值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40z1gY",
          "body": "- capture。监听器会在时间捕获阶段传播到event.target时触发。\r\n- passive。监听器不会调用preventDefault()。\r\n- once。监听器只会执行一次，执行后移除。\r\n- singal。调用abort()移除监听器。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "buzuosheng",
            "url": "https://github.com/buzuosheng"
          }
        },
        {
          "id": "IC_kwDODQzyOs5VCBD9",
          "body": "详见 MDN https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTE2MDQ3NzI=",
    "number": 690,
    "title": "【Q672】什么是原码、补码与反码",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40yhpe",
          "body": "+ 原码:\r\n+ 反码: 反码按位取反\r\n+ 补码: 正数和0的补码就是该数字本身，负数的补码则是反码加一\r\n## 补码\r\n\r\n| 符 |   |   |   |   |   |   |   |   |      |\r\n|-----|---|---|---|---|---|---|---|---|------|\r\n| 0   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | = | 127  |\r\n| 0   | 0 | 0 | 0 | 0 | 0 | 1 | 0 | = | 2    |\r\n| 0   | 0 | 0 | 0 | 0 | 0 | 0 | 1 | = | 1    |\r\n| 0   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | = | 0    |\r\n| 1   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | = | −1   |\r\n| 1   | 1 | 1 | 1 | 1 | 1 | 1 | 0 | = | −2   |\r\n| 1   | 0 | 0 | 0 | 0 | 0 | 0 | 1 | = | −127 |\r\n| 1   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | = | −128 |\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTIyMzYwMDY=",
    "number": 692,
    "title": "【Q673】求给定数组中 N 个数相加之和为 sum 所有可能集合",
    "body": "求给定数组中 N 个数相加之和为 sum 所有可能集合，请补充以下代码\r\n\r\n``` js\r\nfunction fn(arr, n, sum) {}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs400fNx",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs400grw",
          "body": "```javascript\r\n\r\nfunction fun (arr, n, sum) {\r\n    let result = []\r\n    if (arr.length < n) return -1\r\n    arr.sort((prev, next) => {\r\n        return prev - next\r\n    })\r\n    function getSum (arr, n, currSum, index, incArr = []) {\r\n        for (let i = index; i < arr.length; i++) {\r\n            let temp = currSum + arr[i]\r\n            if (temp > sum) break\r\n            \r\n            if (n > 1) {\r\n                getSum(arr, n - 1, temp, i + 1, [arr[i], ...incArr])\r\n            }\r\n\r\n            if (n === 1 && temp === sum) {\r\n                result.push([arr[i], ...incArr]) \r\n            }\r\n        }\r\n    }\r\n    getSum(arr, n, 0, 0)\r\n    return result\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs400hI_",
          "body": "```js\r\nfunction findSumNumbers(array, n, sum) {\r\n  // 枚举所有n个数的组合，判断组合的和等于sum\r\n  let result = [];\r\n  const generateAll = function(index, collection, arr) {\r\n    if (collection.length === n) {\r\n      const s = collection.reduce((acc, c) => acc += c, 0);\r\n      if (s === sum) {\r\n        result.push(collection);\r\n      }\r\n      return;\r\n    }\r\n    for (let i = 0; i < arr.length; i++) {\r\n      generateAll(index + 1, collection.concat(arr[i]), arr.slice(i + 1));\r\n    }\r\n  }\r\n  generateAll(0, [], array.slice(0));\r\n  return result;\r\n}\r\n\r\nfindSumNumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2, 10);\r\n\r\nfindSumNumbers([1, 0, -1, 0, -2, 2], 4, 0);\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs5KFZ_Y",
          "body": "https://leetcode.cn/problems/combination-sum-ii/",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shen076",
            "url": "https://github.com/shen076"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTQwMDU0Mzk=",
    "number": 693,
    "title": "【Q674】在 Node 中如何读取可读流的内容",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs407ion",
          "body": "fs.createReadStream吗，有人知道了踢我一下",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs4085Dt",
          "body": "``` js\r\nlet data = ''\r\nstream.on('data', chunk => data += chunk)\r\nstream.on('end', () => console.log(data))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTU4OTQ2Mjg=",
    "number": 694,
    "title": "【Q675】浏览器中 Frame 与 Event Loop 的关系是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs40_-nU",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44U_oH",
          "body": "浏览器组成中有两大引擎，JS引擎和渲染引擎。\r\n\r\nFrame(帧)是渲染引擎每隔16ms(默认60fps)将渲染树渲染、合成成位图的结果\r\n\r\n每次Event Loop是JS引擎执行的一个周期，执行过程中可能依赖渲染引擎的执行结果，比如访问DOM和CSSOM，也可能影响渲染引擎绘制帧，比如调用 requestAnimationFrame，在每个帧开始绘制时执行一段回调函数(通常包含影响渲染结果的代码)\r\n\r\n因此 Frame 和 Event Loop 是相对独立运行的，但是 Event Loop 中执行的代码可能依赖或影响 Frame",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY1NTczMzA=",
    "number": 695,
    "title": "【Q676】在 Typescript 中如何实现类型标记 Pick 与 Omit",
    "body": "有以下测试用例\r\n\r\n``` ts\r\ninterface User {\r\n  id: number;\r\n  age: number;\r\n  name: string;\r\n};\r\n\r\n// 相当于: type PickUser = { age: number; name: string; }\r\ntype OmitUser = Omit<User, \"id\">\r\n\r\n// 相当于: type PickUser = { id: number; age: number; }\r\ntype PickUser = Pick<User, \"id\" | \"age\">\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41CI6L",
          "body": "``` ts\r\ntype Pick<T, K extends keyof T> = {\r\n  [P in K]: T[P];\r\n};\r\n\r\ntype Exclude<T, U> = T extends U ? never : T;\r\n\r\ntype Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\r\n```\r\n\r\n``` ts\r\ninterface User {\r\n  id: number;\r\n  age: number;\r\n  name: string;\r\n};\r\n\r\n// 相当于: type PickUser = { age: number; name: string; }\r\ntype OmitUser = Omit<User, \"id\">\r\n\r\n// 相当于: type PickUser = { id: number; age: number; }\r\ntype PickUser = Pick<User, \"id\" | \"age\">\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41CKQY",
          "body": "```typescript\r\ntype MyPick<O extends object, K extends keyof O> = {\r\n  [P in K]: O[P]\r\n}\r\n\r\ntype MyOmit<O extends object, K extends keyof O> = MyPick<O, Exclude<keyof O, K>>\r\n\r\ntype MyOmit2<O extends object, K extends keyof O> = {\r\n  [P in Exclude<keyof O, K>]: O[P]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMjEzODUzNTU2",
          "name": "ts"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY3MzQ1MDI=",
    "number": 696,
    "title": "【Q677】如何实现一个 sampleSize 函数，从数组中随机取N个元素 ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41CpgO",
          "body": "``` js\r\nconst shuffle = (list) => list.sort((x, y) => Math.random() - 0.5)\r\nconst sampleSize = (list, n) => shuffle(list).slice(0, n)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Mvw6x",
          "body": "```javascript\r\nArray.prototype.sampleSie = function(size) {\r\n    const result = [];\r\n    const tmp = [...this];\r\n    const len = tmp.length;\r\n    for (let i = 0; i < size && i < len; i++) {\r\n        const index = Math.floor(Math.random() * tmp.length);\r\n        result[i] = tmp.splice(index, 1)[0];\r\n    }\r\n    return result;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "voezy",
            "url": "https://github.com/voezy"
          }
        },
        {
          "id": "IC_kwDODQzyOs5cjadb",
          "body": "不知道这样可不可以，从随机挑选的数，组成的数组，长度达到size，就返回\r\n```\r\nfunction sampleSize(array,size){\r\n  let len = array.length,i,pickArr = [];\r\n  while(len&&size){\r\n    i = Math.floor(Math.random()*len);\r\n    len--;\r\n    pickArr.push(array.splice(i,1)[0]);\r\n    size--;\r\n  }\r\n  return pickArr\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rujptw",
            "url": "https://github.com/rujptw"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY3NDU0NTg=",
    "number": 697,
    "title": "【Q678】实现一个函数 keyBy",
    "body": "类似 [lodash.keyBy](https://lodash.com/docs/4.17.15#keyBy)，这里仅仅考虑第二个参数为函数的情况\r\n\r\n``` js\r\n// Output: {\r\n//   \"1\": {\r\n//     \"id\": 1,\r\n//     \"name\": \"山月\"\r\n//   },\r\n//   \"2\": {\r\n//     \"id\": 2,\r\n//     \"name\": \"shanyue\"\r\n//   }\r\n// }\r\nkeyBy([{ id: 1, name: '山月' }, { id: 2, name: 'shanyue' }], x => x.id)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41C-no",
          "body": "``` js\r\nfunction keyBy (list, by) {\r\n  return list.reduce((acc, x) => {\r\n    acc[by(x)] = x \r\n    return acc \r\n  }, {})\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Zkm2k",
          "body": "这里其实是利用对象的键都是有序的，把类数组转成了对象",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yinzhuo19970516",
            "url": "https://github.com/Yinzhuo19970516"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY3NTI5MDg=",
    "number": 698,
    "title": "【Q679】实现一个函数 groupBy",
    "body": "类似 [lodash.groupBy](https://lodash.com/docs/4.17.15#groupBy)\r\n\r\n``` js\r\ngroupBy([\r\n  { id: 1, name: '山月', sex: 'male' },\r\n  { id: 2, name: '张三', sex: 'female' },\r\n  { id: 3, name: '李四', sex: 'female' }\r\n], x => x.sex)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41C-mU",
          "body": "``` js\r\nfunction groupBy (collection, by) {\r\n  return collection.reduce((acc, x) => {\r\n    if (acc[by(x)]) { acc[by(x)].push(x)}\r\n    else { acc[by(x)] = [x] }\r\n    return acc \r\n  }, {})\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41XB-O",
          "body": "```javascript\r\n\r\nfunction groupBy (data, filter) {\r\n    const map = {}\r\n    data.forEach(curr => {\r\n        const key = filter(curr)\r\n        if (!map[key]) map[key] = []\r\n        map[key].push(curr)\r\n    })\r\n    return map\r\n}\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs42cnqs",
          "body": "```js\r\nfunction groupBy(arr = [], callback) {\r\n  const obj = {}\r\n  const keys = arr.map(callback)\r\n  keys.forEach(key => {\r\n    obj[key] = []\r\n  })\r\n\r\n  arr.forEach(ele => {\r\n    obj[callback(ele)].push(ele)\r\n  })\r\n\r\n  return obj\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JoeWrights",
            "url": "https://github.com/JoeWrights"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY4NDM5OTA=",
    "number": 699,
    "title": "【Q680】在 Node 中如何读取大文件的内容",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41C9YD",
          "body": "``` js\r\nimport { createReadStream } from 'fs';\r\n\r\nconst stream = createReadStream('bigfile.json');\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY4NTU5MTI=",
    "number": 700,
    "title": "【Q681】求正序增长的正整数数组中，其和为 N 的两个数",
    "body": "``` js\r\n//=> [5, 10]\r\ntwoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15)\r\n\r\n//=> null\r\ntwoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 150)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41C_vA",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41DcSS",
          "body": "```javascript\r\nconst twoSum = (arr, sum) => {\r\n  if (arr.length < 2 || arr[arr.length - 1] + arr[arr.length - 2] < sum) {\r\n    return null\r\n  }\r\n  const sumList = {}, res = []\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let val = arr[i]\r\n    if (sumList[val]) {\r\n      res.push([Math.min(val, sumList[val]), Math.max(val, sumList[val])])\r\n    } else {\r\n      sumList[sum - val] = val\r\n    }\r\n  }\r\n  return res.length === 0 ? null : res\r\n}\r\ntwoSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15)  // [[7, 8], [6, 9], [5, 10]]\r\n```\r\n返回的数组不唯一",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hengistchan",
            "url": "https://github.com/hengistchan"
          }
        },
        {
          "id": "IC_kwDODQzyOs41EIG8",
          "body": "一，常规两数之和\r\n```js\r\nvar twoSum = function (nums, target) {\r\n    const hash = new Map();\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (hash.has(target - nums[i])) return [nums[i], nums[target - i]];\r\n        hash.set(nums[i], i);\r\n    }\r\n    return null;\r\n};\r\n```\r\n\r\n二，双指针\r\n利用题目的提示 “正序增长的正整数数组”\r\n而且例1的提示很明显了，左右两个指针\r\n当前和大于目标值，右指针左移\r\n当前和小于目标值，左指针右移\r\n左指针等于右指针，循环中断，返回null\r\n```js\r\nconst twoSum = (number, target) => {\r\n    let left = 0,\r\n        right = number.length - 1;\r\n    while (left < right) {\r\n        const sum = number[left] + number[right];\r\n        if (sum === target) return [number[left], number[right]]; // 等于目标值，返回对应值\r\n        else if (sum < target) left++; // 小于目标值，左指针向右移动\r\n        else right--; // 大于目标值，右指针向左移动\r\n    }\r\n    return null;\r\n};\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "AaronKwong929",
            "url": "https://github.com/AaronKwong929"
          }
        },
        {
          "id": "IC_kwDODQzyOs42ciUD",
          "body": "一、获取其中某一种组合\r\n\r\n```js\r\nfunction twoSum(arr, target) {\r\n  let first\r\n  let second\r\n  arr.forEach(element => {\r\n    if (arr.includes(target - element)) {\r\n      first = element\r\n    }\r\n  })\r\n  second = arr.find(ele => ele === target - first)\r\n\r\n  if (!first || !second) return null\r\n\r\n  return [first, second]\r\n}\r\n```\r\n\r\n二、获取所有组合\r\n\r\n```js\r\nfunction twoSum(arr, target) {\r\n  let firstArr = []\r\n  let secondArr = []\r\n  let result = []\r\n\r\n  arr.forEach(ele => {\r\n    if (arr.includes(target - ele)) {\r\n      firstArr.push(ele)\r\n    }\r\n  })\r\n\r\n  firstArr.forEach(ele => {\r\n    secondArr.push(target - ele)\r\n  })\r\n\r\n  firstArr.forEach((firstEle, i) => {\r\n    secondArr.forEach((secondEle, j) => {\r\n      if (i === j) {\r\n        result.push([firstEle, secondEle])\r\n      }\r\n    })\r\n  })\r\n\r\n  return result.length > 0 ? result : null\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "JoeWrights",
            "url": "https://github.com/JoeWrights"
          }
        },
        {
          "id": "IC_kwDODQzyOs44VzG8",
          "body": "双指针法获取所有组合\r\n```javascript\r\nconst twoSum = (arr, sum) => {\r\n    if (arr.length <= 1) return []\r\n    let len = arr.length\r\n    let left = 0\r\n    let right = len - 1\r\n    let result = []\r\n    while (left < right) {\r\n      let _sum = arr[left] + arr[right]\r\n      if (_sum === sum) {\r\n        result.push([arr[left], arr[right]])\r\n        left++\r\n        right--\r\n      } else if (_sum > sum) {\r\n        right--  \r\n      } else {\r\n        left++ \r\n      }\r\n    }\r\n    return result\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hwb2017",
            "url": "https://github.com/hwb2017"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jck7x",
          "body": "```\r\nfunction twoSum(arr, target) {\r\n  const map = {};\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const num = arr[i];\r\n    const diff = target - num;\r\n    if (map[diff] !== undefined) {\r\n      return [map[diff], arr[i]];\r\n    }\r\n    map[num] = arr[i];\r\n  }\r\n  return null;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jcnIL",
          "body": "> \r\n\r\n\r\nvar twoSum = function (nums, target) {\r\n  const hash = new Map();\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const diff = target - nums[i];\r\n    if (hash.has(diff)) return [i, hash.get(diff)];\r\n    hash.set(nums[i], i);\r\n  }\r\n  return null;\r\n};\r\n\r\n第一个有点问题，应该是这样",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jcnZD",
          "body": "> 一，常规两数之和\r\n> \r\n> ```js\r\n> var twoSum = function (nums, target) {\r\n>     const hash = new Map();\r\n>     for (let i = 0; i < nums.length; i++) {\r\n>         if (hash.has(target - nums[i])) return [nums[i], nums[target - i]];\r\n>         hash.set(nums[i], i);\r\n>     }\r\n>     return null;\r\n> };\r\n> ```\r\n> \r\n> 二，双指针 利用题目的提示 “正序增长的正整数数组” 而且例1的提示很明显了，左右两个指针 当前和大于目标值，右指针左移 当前和小于目标值，左指针右移 左指针等于右指针，循环中断，返回null\r\n> \r\n> ```js\r\n> const twoSum = (number, target) => {\r\n>     let left = 0,\r\n>         right = number.length - 1;\r\n>     while (left < right) {\r\n>         const sum = number[left] + number[right];\r\n>         if (sum === target) return [number[left], number[right]]; // 等于目标值，返回对应值\r\n>         else if (sum < target) left++; // 小于目标值，左指针向右移动\r\n>         else right--; // 大于目标值，右指针向左移动\r\n>     }\r\n>     return null;\r\n> };\r\n> ```\r\n\r\n\r\n```\r\nvar twoSum = function (nums, target) {\r\n  const hash = new Map();\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const diff = target - nums[i];\r\n    if (hash.has(diff)) return [i, hash.get(diff)];\r\n    hash.set(nums[i], i);\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n第一个有点小问题",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTY4ODE0NzE=",
    "number": 701,
    "title": "【Q682】100层楼，两个玻璃球，求最少多少次测出能摔碎玻璃球的楼层",
    "body": "给你两个一摸一样的球，这两个球如果从一定的高度掉到地上有可能就会摔碎，当然，如果在这个高度以下往下扔，怎么都不会碎，当然超过这个高度肯定就一定摔碎了。\r\n\r\n现在已知这个恰巧摔碎高度范围在一层楼到100层楼之间。\r\n\r\n如何用最少的试验次数，用这两个玻璃球测试出摔碎的楼高",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41DD4i",
          "body": "假设最少次数是x次 那么第一个我们从哪里扔呢 ？从x 因为如果碎了 另一个球从1到x 正好就是x\r\n如果没碎这时候我们第一个球第二次只剩x-1次 所以我们从x+x-1层扔 碎了从x+1到x + x-2 遍历\r\n后面逻辑一样 减1去扔第一个球 没碎下次再减1 碎了从上一次的没碎的上一层遍历就好了 \r\n\r\n所以可以一共层数等于x + (x-1) + (x-2) + ... + 1 = 100\r\n\r\n下面我们来解这个这个方程:\r\n\r\n(x+1)*x/2 = 100\r\n\r\n最终x向上取整,得到 x=14\r\n\r\n因此，最优解在最坏情况的尝试次数是14次，第一次扔鸡蛋的楼层也是14层。\r\n\r\n最后，让我们把第一个鸡蛋没碎的情况下，所尝试的楼层数完整列举出来：\r\n\r\n14，27， 39， 50， 60， 69， 77， 84， 90， 95， 99， 100",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-AXoz",
          "body": "```javascript\r\nfunction solution(n) {\r\n    const dp = Array.from({ length: 2 }, () => new Array(n + 1).fill(0));\r\n    for (let i = 1; i <= n; i++) {\r\n        dp[0][i] = i;\r\n        dp[1][i] = n;\r\n        for (let j = 1; j <= i; j++) {\r\n            dp[1][i] = Math.min(dp[1][i], Math.max(dp[0][j - 1], dp[1][i - j]) + 1);\r\n        }\r\n    }\r\n    return dp[1][n - 1];\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "3N26",
            "url": "https://github.com/3N26"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTcyMDY3MzM=",
    "number": 702,
    "title": "【Q683】FizzBuzz，是否能被3或5整除",
    "body": "输入一个整数，如果能够被3整除，则输出 `Fizz`\r\n\r\n如果能够被5整除，则输出 `Buzz`\r\n\r\n如果既能被3整数，又能被5整除，则输出 `FizzBuzz`\r\n\r\n\r\n``` js\r\n//=> 'fizz'\r\nfizzbuzz(3)\r\n\r\n//=> 'buzz'\r\nfizzbuzz(5)\r\n\r\n//=> 'fizzbuzz'\r\nfizzbuzz(15)\r\n\r\n//=> 7\r\nfizzbuzz(7)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41ESbd",
          "body": "``` js\r\nfunction fizzbuzz (n) {\r\n  if (n % 5 === 0 && n % 3 === 0) {\r\n    return 'fizzbuzz'\r\n  } else if (n % 3 === 0) {\r\n    return 'fizz'\r\n  } else if (n % 5 === 0) {\r\n    return 'buzz'\r\n  }\r\n  return n\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41EVDO",
          "body": "```javascript\r\nfunction fizzbuzz(n) {\r\n    let str = ''\r\n    if (n % 3 === 0) {\r\n        str += 'Fizz'\r\n    }\r\n    if (n % 5 ==0 0) {\r\n        str += 'Buzz'\r\n    }\r\n    return str || n\r\n}\r\n\r\n\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs5KR7uy",
          "body": "const fizzbuzz = (num)=>`${num%3?'':'fizz'}${num%5?'':'buzz'}`||num",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "borraken",
            "url": "https://github.com/borraken"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Zx3t7",
          "body": "```js\r\nfunction fizzbuzz(n) {\r\n  if(n%5===0 && n%3 === 0) {\r\n    return 'FizzBuzz'\r\n  } else if(n%5===0) {\r\n    return 'Buzz'\r\n  } else if(n%3===0) {\r\n    return 'Fizz'\r\n  } else {\r\n    return n\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yinzhuo19970516",
            "url": "https://github.com/Yinzhuo19970516"
          }
        },
        {
          "id": "IC_kwDODQzyOs5gub7c",
          "body": "```js\r\nfunction fizzbuzz(number){\r\n  return number % 3 === 0 && number % 5 === 0\r\n  ? 'fizzbuzz'\r\n  : number % 5 === 0\r\n  ? 'buzz'\r\n  : number % 3 === 0\r\n  ? 'fizz'\r\n  : number;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jWm7W",
          "body": "```\r\nfunction fizzbuzz(n) {\r\n  const fizz = n % 3 === 0 ? \"fizz\" : \"\";\r\n  const buzz = n % 5 === 0 ? \"buzz\" : \"\";\r\n  return fizz + buzz || n;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Ghaining",
            "url": "https://github.com/Ghaining"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTcyNzA2MDI=",
    "number": 703,
    "title": "【Q684】实现一个函数  camelCase，对变量转化为驼峰命名",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5BOSfU",
          "body": "```js\r\n//驼峰转短横线\r\nfunction toKebabCase(str) {\r\n    let res =  str.replace(/([A-Z])/g, (all, i) => {\r\n        return \"-\" + i.toLowerCase();\r\n    })\r\n    if (res.slice(0, 1) === '-') {\r\n        res = res.slice(1); //去除开头的-\r\n    }\r\n    return res;\r\n}\r\n//短横线转驼峰\r\nfunction toCamelCase(str) {\r\n    return str.replace(/-([a-zA-Z])/g, function(all, i){\r\n        return i.toUpperCase();\r\n    })\r\n}\r\n\r\nconsole.log(toCamelCase('get-element-by-id'));\r\nconsole.log(toKebabCase('GetElementById'));\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "jyehn",
            "url": "https://github.com/jyehn"
          }
        },
        {
          "id": "IC_kwDODQzyOs5dit5M",
          "body": "```\r\n// 字符串转驼峰\r\nlet str = \"--talk-much--\"\r\nlet str2 = \"__talk_much__\"\r\nlet str3 = \"Talk Much\"\r\nlet reg = /([-|_|\\s]\\w)/g;\r\nfunction camelCase(str){\r\n  let formatStr = str.replace(reg,function(match){\r\n    return match.slice(1).toUpperCase()\r\n  })\r\n  formatStr = formatStr.replace(/[-|_|\\s]/g,'')\r\n  formatStr = formatStr[0].toLowerCase() + formatStr.slice(1,formatStr.length+1)\r\n  return formatStr\r\n}\r\nconsole.log(\"camelCase\",camelCase(str));\r\nconsole.log(\"camelCase\",camelCase(str2));\r\nconsole.log(\"camelCase\",camelCase(str3));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "rujptw",
            "url": "https://github.com/rujptw"
          }
        },
        {
          "id": "IC_kwDODQzyOs5gaY4v",
          "body": "```js\r\nconst camelCase = (variableName) =>{\r\n  const wordList = variableName.split(/[-_\\s]+/)\r\n  let camelCaseList = wordList.map((word,index) =>{\r\n    if(!index) {\r\n      return word.toLowerCase()\r\n    }\r\n    return word.charAt(0).toUpperCase() + word.slice(1)\r\n  })\r\n  return camelCaseList.join('')\r\n}\r\n\r\nconsole.log(camelCase('third variable'));\r\nconsole.log(camelCase('Third variable'));\r\nconsole.log(camelCase('third_variable'));\r\nconsole.log(camelCase('third-variable'));\r\nconsole.log(camelCase('thirdVariable'));\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Hazel-Lin",
            "url": "https://github.com/Hazel-Lin"
          }
        },
        {
          "id": "IC_kwDODQzyOs5rM_Q9",
          "body": "```js\r\nfunction camelCase(str) {\r\n    return str.split(/[\\-_\\s]+/)\r\n        .filter(w => w !== '')\r\n        .reduce((prev, cur, index) => {\r\n            if (index === 1) prev = prev.toLowerCase()\r\n            cur = cur.charAt(0).toUpperCase() + cur.slice(1).toLowerCase()\r\n            return prev + cur\r\n        })\r\n}\r\n\r\ncamelCase('fooBar');\r\n// => 'fooBar'\r\n\r\ncamelCase('Foo Bar');\r\n// => 'fooBar'\r\n \r\ncamelCase('--foo-bar--');\r\n// => 'fooBar'\r\n \r\ncamelCase('__FOO_BAR__');\r\n// => 'fooBar'\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTkxMjI2MzQ=",
    "number": 704,
    "title": "【Q685】如何遍历一个对象",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41KJDN",
          "body": "1. `Reflect.ownKeys({ a: 3, b: 4})`\r\n2. `Object.keys({ a: 3, b: 4 })`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41U21X",
          "body": "1.  for in\r\n2. object.keys()\r\n3. object.entries()",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DanielLeefu",
            "url": "https://github.com/DanielLeefu"
          }
        },
        {
          "id": "IC_kwDODQzyOs49q_DT",
          "body": "普通对象可以通过添加一个`Symbol.iterator`属性，实现使用 `for of` 遍历\r\n```js\r\nconst obj = {a: 1, b: 2, c: 3}\r\n\r\nobj[Symbol.iterator] = function () {\r\n  let i = 0\r\n  const keys = Object.keys(this)\r\n  return {\r\n    next: () => {\r\n      return i <= keys.length - 1 ? \r\n        {value: this[keys[i++]], done: false} : \r\n        {value: undefined, done: true}\r\n    }\r\n  }\r\n}\r\n\r\nfor (let item of obj) {\r\n  console.log(item)\r\n}\r\n\r\n//   1\r\n//   2\r\n//   3\r\n```\r\n`for of` 遍历每次都会调用 `Symbol.iterator` 中的 `next` 方法",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Yand-hi",
            "url": "https://github.com/Yand-hi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTkxMjkxMzk=",
    "number": 705,
    "title": "【Q686】网站性能优化中，如何对小图片进行优化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41KKVp",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44QzFe",
          "body": "通过整合小图片到一张精灵图，减少请求图片次数。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kv1991",
            "url": "https://github.com/kv1991"
          }
        },
        {
          "id": "IC_kwDODQzyOs44uGna",
          "body": "base64 或者搞成 svg",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CySKY",
          "body": "小图的话，基本都是通过工程化转base64。精灵图我觉得麻烦而且还得请求一次拿到精灵图",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Qiu-Jun",
            "url": "https://github.com/Qiu-Jun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CyYxv",
          "body": "> 小图的话，基本都是通过工程化转base64。精灵图我觉得麻烦而且还得请求一次拿到精灵图\n\n凌晨三四点，厉害了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "EricWong1994",
            "url": "https://github.com/EricWong1994"
          }
        },
        {
          "id": "IC_kwDODQzyOs5C0LD4",
          "body": "> > 小图的话，基本都是通过工程化转base64。精灵图我觉得麻烦而且还得请求一次拿到精灵图\r\n> \r\n> 凌晨三四点，厉害了\r\n\r\n基本操作",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Qiu-Jun",
            "url": "https://github.com/Qiu-Jun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DLtGT",
          "body": "需要注意的是 base64 处理过的过的图片会比原先更大，编码到项目的 htmlcss/js 中，会增加静态文件的体积且 html/css/js 是经常修改的内容，base64 随着这些文件也不好处理缓存",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nmsn",
            "url": "https://github.com/nmsn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDkwODMwMjI5",
          "name": "perf"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NTkyNTQ5MjE=",
    "number": 706,
    "title": "【Q687】https 如何被抓包，原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41KjRg",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjE0MzUzNDI=",
    "number": 708,
    "title": "【Q688】setTimeout为什么最小只能设置4ms，如何实现一个0ms的setTimeout?",
    "body": "可参考两篇文章\r\n\r\n1. [为什么 setTimeout 有最小时延 4ms ?](https://juejin.cn/post/6846687590616137742)\r\n2. [如何实现一个0ms的setTimeout?](https://zhuanlan.zhihu.com/p/379637806)\r\n",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41PJC4",
          "body": "postMessage",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41PNBf",
          "body": "[blink引擎的DOMTimer类源码](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/dom_timer.cc;l=47)\r\n前几天刚好找了一下源码，在47-49行设置了`kMaxTimerNestingLevel` 和 `kMinimumInterval` 两个变量分别为5和4，\r\n分别表示最大的嵌套层数和最小的毫秒数\r\n![image](https://user-images.githubusercontent.com/46242125/128295969-fc674ccf-40b2-475c-8c32-6432dd7f7ff8.png)\r\n截取一下DOMTimer类的部分代码\r\n```cpp\r\nDOMTimer::DOMTimer(ExecutionContext* context,\r\n                   ScheduledAction* action,\r\n                   base::TimeDelta timeout,\r\n                   bool single_shot,\r\n                   int timeout_id)\r\n    : ExecutionContextLifecycleObserver(context),\r\n      TimerBase(nullptr),\r\n      timeout_id_(timeout_id),\r\n      // Step 9:\r\n      nesting_level_(context->Timers()->TimerNestingLevel()),\r\n      action_(action) {\r\n  DCHECK_GT(timeout_id, 0);\r\n\r\n  // Step 10:\r\n  if (timeout < base::TimeDelta())\r\n    timeout = base::TimeDelta();\r\n\r\n  // Steps 12 and 13:\r\n  // Note: The implementation increments the nesting level before using it to\r\n  // adjust timeout, contrary to what the spec requires crbug.com/1108877.\r\n  IncrementNestingLevel();\r\n\r\n  // Step 11:\r\n  // Note: The implementation uses >= instead of >, contrary to what the spec\r\n  // requires crbug.com/1108877.\r\n  if (nesting_level_ >= kMaxTimerNestingLevel && timeout < kMinimumInterval)\r\n    timeout = kMinimumInterval;\r\n\r\n  // Select TaskType based on nesting level.\r\n  TaskType task_type;\r\n  if (timeout.is_zero()) {\r\n    task_type = TaskType::kJavascriptTimerImmediate;\r\n    DCHECK_LT(nesting_level_, kMaxTimerNestingLevel);\r\n  } else if (nesting_level_ >= kMaxTimerNestingLevel) {\r\n    task_type = TaskType::kJavascriptTimerDelayedHighNesting;\r\n  } else {\r\n    task_type = TaskType::kJavascriptTimerDelayedLowNesting;\r\n  }\r\n  MoveToNewTaskRunner(context->GetTaskRunner(task_type));\r\n\r\n  // Clamping up to 1ms for historical reasons crbug.com/402694.\r\n  timeout = std::max(timeout, base::TimeDelta::FromMilliseconds(1));\r\n```\r\n看代码中setp11的那部分，当嵌套层数大于5且timeout小于4ms时，timeout才会等于4ms\r\n然后（代码最后一行），timeout 还会和1ms作比较取最大值，作为最终的timeout",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hengistchan",
            "url": "https://github.com/hengistchan"
          }
        },
        {
          "id": "IC_kwDODQzyOs41U2vR",
          "body": "```\r\nlet timeouts = [];\r\nconst messageName = 'zero-settimeout'\r\n\r\nfunction setTimeoutZero(fn) {\r\n  timeouts.push(fn);\r\n  window.postMessage(messageName, '*')\r\n}\r\n\r\nfunction handleMessage (evt) {\r\n  if (evt.source == window && evt.data === messageName ) {\r\n    if (timeouts.length > 0) {\r\n      const f = timeouts.shift()\r\n      f()\r\n    }\r\n  }\r\n}\r\n\r\nwindow.addEventListener('message', handleMessage)\r\n\r\nwindow.zeroSettimeout = setTimeoutZero;\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DanielLeefu",
            "url": "https://github.com/DanielLeefu"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjMzMzYxMTA=",
    "number": 710,
    "title": "【Q689】JS 中如何原生实现 instanceOf",
    "body": "``` js\r\nfunction fakeInstanceOf (instance, parent): Boolean {}\r\n\r\n//=> true\r\nfakeInstanceOf([], Array)\r\n\r\n//=> true\r\nfakeInstanceOf([], Object)\r\n\r\n//=> true\r\nfakeInstanceOf(x => x, Object)\r\n\r\n//=> false\r\nfakeInstanceOf('hello', Object)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41VIOs",
          "body": "``` js\r\nfunction fakeInstanceOf (instance, parent) {\r\n  if (typeof(instance) !== 'object' && typeof(instance) !== 'function') {\r\n    return false\r\n  }\r\n  let proto = instance?.__proto__ || null\r\n  while (true) {\r\n    if (proto === null) { return false }\r\n    if (proto === parent.prototype) { return true }\r\n    proto = proto.__proto__\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41VJUE",
          "body": "```js\r\nfunction fakeInstanceOf (instance, parent) {\r\n  if(! instance?.__proto__ ||  ! parent.prototype) return false;\r\n  if( instance.__proto__ === parent.prototype ) return true;\r\n  return fakeInstanceOf(instance, parent.prototype\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ywang305",
            "url": "https://github.com/ywang305"
          }
        },
        {
          "id": "IC_kwDODQzyOs41VNGK",
          "body": "\r\n```javascript\r\nfunction typeObj (val) {\r\n    if ((typeof val === 'function' || typeof val === 'object') && val !== null) {\r\n        return true\r\n    } else {\r\n        return false\r\n    } \r\n}\r\n\r\nfunction instanceOf (left, right) {\r\n    if (!typeObj(right)) {\r\n        throw new Error('error info')\r\n    }\r\n    let hasInstance = right[Symbol.hasInstance]\r\n    if (hasInstance !== undefined && typeof hasInstance === 'function') {\r\n        return !!hasInstance.call(right, left)\r\n    } else {\r\n        if (typeof right !== 'function') {\r\n            throw new Error('error info')\r\n        }\r\n        if (!typeObj(left)) return false\r\n        let proto = right.prototype\r\n        if (!typeObj(proto)) throw new Error('error Info')\r\n        let leftProto = left.prototype\r\n        while (leftProto !== null) {\r\n            if (leftProto === proto) return true\r\n            leftProto = leftProto.prototype            \r\n        }\r\n        return false\r\n    }\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs41VxWv",
          "body": "```js\r\n// left instanceof right\r\nfunction _instanceof(left, right) {\r\n  // 构造函数原型\r\n  const prototype = right.prototype\r\n  // 实列对象属性，指向其构造函数原型\r\n  left = left.__proto__\r\n  // 查实原型链\r\n  while (true) {\r\n    // 如果为null，说明原型链已经查找到最顶层了，真接返回false\r\n    if (left === null) {\r\n      return false\r\n    }\r\n    // 查找到原型\r\n    if (prototype === left){\r\n      return true\r\n    }\r\n    // 继续向上查找\r\n    left = left.__proto__\r\n  }\r\n}\r\n\r\nconst str = \"abc\"\r\n_instanceof(str, String) // true\r\n```",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "lizheng0515",
            "url": "https://github.com/lizheng0515"
          }
        },
        {
          "id": "IC_kwDODQzyOs41WK47",
          "body": "```js\r\nfunction fakeInstanceOf(left, right) {\r\n    if (!left) return false;\r\n    if (typeof left !== 'object' && typeof left !== 'function') return false;\r\n    let proto = left.__proto__;\r\n    const prototype = right.prototype\r\n\r\n    while (proto) {\r\n        if (proto === prototype) {\r\n            return true\r\n        }\r\n        proto = proto.__proto__\r\n    }\r\n\r\n    return false;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "vandvassily",
            "url": "https://github.com/vandvassily"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DKUy8",
          "body": "有一个小问题问一下大家\r\n代码中判断当前对象是否等于函数prototype的方法是直接用相等判断，即类似这样：\r\n```js\r\nif(parentProto===childProto)\r\n```\r\n但是有个问题就是，不管是函数的prototype还是对象的`__proto__`，实际上都是对象，对象之间为什么能用`===`判断相等？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "penghei",
            "url": "https://github.com/penghei"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DKoO2",
          "body": "@penghei 因为他们是同一个对象啊",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5L2-Qd",
          "body": "@penghei  因为他们指向同一个对象",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Awalter0411",
            "url": "https://github.com/Awalter0411"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjMzNTE0Nzk=",
    "number": 711,
    "title": "【Q690】如何根据 random5 随机生成 [0, 5]，生成一个函数 random7？",
    "body": "已知有一个函数 叫做 `random5`，执行这个函数会随机返回 0-5 之间任意一个数，概率相同。\r\n\r\n根据这个 `random5`，实现一个 `random7`，要求执行这个函数后随机返回 0-7 之间任意一个数，概率相同。\r\n\r\n这是一道群友分享的百度面经中的问题。",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41YyGQ",
          "body": "https://www.growingwiththeweb.com/2014/03/given-random5-implement-random7.html\r\n看到一题近似的，不过random5和random7 是返回[0, 5]和[0, 7]",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "AaronKwong929",
            "url": "https://github.com/AaronKwong929"
          }
        },
        {
          "id": "IC_kwDODQzyOs44-pgb",
          "body": "- 参考 [leetcode 470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)-\r\n- 方法：拒绝采样\r\n- 思路：`random5`生成 `[0, 5]`每个数的概率是  $ \\frac {1}{6} $， **使用两次** `random` 函数，**相乘**，找到等概率出现的 8个数就可以，不满足的数据排除掉\r\n\r\n  \r\n\r\n|       | 0    | 1    | 2    | 3    | 4    | 5    |\r\n| ----- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| **0** | 0    | 0    | 0    | 0    | 0    | 0    |\r\n| **1** | 0    | 1    | 2    | 3    | 4    | 5    |\r\n| **2** | 0    | 2    | 4    | 6    | 8    | 10   |\r\n| **3** | 0    | 3    | 6    | 9    | 12   | 15   |\r\n| **4** | 0    | 4    | 8    | 12   | 16   | 20   |\r\n| **5** | 0    | 5    | 10   | 15   | 20   | 25   |\r\n\r\n|       |      **0**      |     **1**      |     **2**      |     **3**      |     **4**      |     **5**      |\r\n| ----- | :-------------: | :------------: | :------------: | :------------: | :------------: | :------------: |\r\n| **P** | $\\frac{11}{36}$ | $\\frac{1}{36}$ | $\\frac{2}{36}$ | $\\frac{2}{36}$ | $\\frac{3}{36}$ | $\\frac{2}{36}$ |\r\n|       |      **6**      |     **8**      |     **9**      |     **10**     |     **12**     |     **15**     |\r\n| **P** | $\\frac{2}{36}$  | $\\frac{2}{36}$ | $\\frac{1}{36}$ | $\\frac{2}{36}$ | $\\frac{2}{36}$ | $\\frac{2}{36}$ |\r\n|       |     **16**      |     **20**     |     **25**     |                |                |                |\r\n| **P** | $\\frac{1}{36}$  | $\\frac{2}{36}$ | $\\frac{1}{36}$ |                |                |                |\r\n\r\n根据上图可知，我们只需要取 `[1, 2, 3, 5, 6, 8, 9, 12, 15]`,这几个数，对8取余后可得到：\r\n\r\n\r\n\r\n| 1              | 2              | 3              | 4              | 5              | 6              | 0              | 1              | 7              |\r\n| -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- |\r\n| $\\frac{1}{36}$ | $\\frac{2}{36}$ | $\\frac{3}{36}$ | $\\frac{2}{36}$ | $\\frac{2}{36}$ | $\\frac{2}{36}$ | $\\frac{2}{36}$ | $\\frac{1}{36}$ | $\\frac{2}{36}$ |\r\n\r\n至此，我们可以得到等概率的[0, 7] 之间的数，每个数出现的概率为 $\\frac{2}{36}$\r\n\r\n故，简单粗暴的方式可用以下方式实现：\r\n\r\n```python\r\n    def random5(self):\r\n        return randint(0, 5)\r\n    \r\n    def random7(self):\r\n        picked = [1, 2, 3, 5, 6, 8, 9, 12, 15]\r\n        while True:\r\n            rd1 = self.random5()\r\n            rd2 = self.random5()\r\n            if (rd1 * rd2) in picked:\r\n                return (rd1 * rd2) % 8\r\n            rd1 = self.random5()\r\n            rd2 = self.random5()\r\n```\r\n\r\n如果要更进一步优化，减少`random5` 函数的调用，我们就需要优化，如果随机出现的值不在我们采样的范围中时，怎么去减少对函数 `random5` 的调用，具体操作可看到官方题解\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Camliar",
            "url": "https://github.com/Camliar"
          }
        },
        {
          "id": "IC_kwDODQzyOs49lsNG",
          "body": "```javascript\r\nfunction rand5 () {\r\n    return Math.random() * 6 | 0\r\n}\r\n\r\nfunction rand7 () {\r\n    while (true) {\r\n        let num = rand5() * 6 + rand5()\r\n        if (num < 32) {\r\n            return num % 8\r\n        }\r\n    } \r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-AT8c",
          "body": "```javascript\r\nfunction rand5 () {\r\n    return Math.random() * 6 | 0\r\n}\r\n\r\nfunction rand7 () {\r\n    return (rand5() & 1) * 4 + (rand5() & 1) * 2 + (rand5() & 1);\r\n};\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "3N26",
            "url": "https://github.com/3N26"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjM0NDQzMTA=",
    "number": 712,
    "title": "【Q691】如何实现一个 ORM 类似的 find 链式调用",
    "body": "如下代码所示，使用 `find` 函数实现链式调用\r\n\r\n``` js\r\nconst data = [\r\n  {userId: 8, title: 'title1'},\r\n  {userId: 11, title: 'other'},\r\n  {userId: 15, title: null},\r\n  {userId: 19, title: 'title2'}\r\n];\r\n\r\n// 查找data中，符合where中条件的数据，并根据orderBy中的条件进行排序\r\nconst result = find(data).where({\r\n  \"title\": /\\d$/   // 这里意思是过滤出数组中，满足title字段中符合 /\\d$/的项\r\n}).orderBy('userId', 'desc');  // 这里的意思是对数组中的项按照userId进行倒序排列\r\n\r\n//=> 返回 [{ userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }];\r\nconsole.log(result.value); ",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41Vahc",
          "body": "代码见 codepen，[如何实现链式调用](https://codepen.io/shanyue/pen/abWQLZv?editors=0012)\r\n\r\n``` js\r\nfunction find (data) {\r\n  return {\r\n    data,\r\n    where (match) {\r\n      this.data = this.data.filter((item) => {\r\n        return Object.entries(match).every(([key, value]) => {\r\n          if (value instanceof RegExp) {\r\n            return value.test(item[key])\r\n          }\r\n          return item[key] === value\r\n        })\r\n      })\r\n      return this\r\n    },\r\n\r\n    orderBy (key, type) {\r\n      this.data.sort((x, y) => type !== 'desc' ? x[key] - y[key] : y[key] - x[key])\r\n      return this\r\n    }\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41Vbfv",
          "body": "```js\r\nfunction find(data) {\r\n  class FindManager {\r\n    constructor(data) {\r\n      this.data = data;\r\n    }\r\n    where(query) {\r\n      const data = [...this.data];\r\n      return new FindManager(data.filter((item) => {\r\n        return Object.entries(query).every(([key, filter]) => {\r\n          if (Object.prototype.toString.call(filter).slice(8, -1) === 'Regex') {\r\n            return filter.test(item[key]);\r\n          } else {\r\n            return filter === item[key];\r\n          }\r\n        });\r\n      }));\r\n    }\r\n    orderBy(key, order) {\r\n      const data = [...this.data];\r\n      data.sort((a, b) => {\r\n        return order === 'asc' ? a[key] - b[key] : b[key] - a[key];\r\n      });\r\n      return new FindManager(data);\r\n    }\r\n    get value() {\r\n      return this.data;\r\n    }\r\n  }\r\n  return new FindManager(data);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "haotie1990",
            "url": "https://github.com/haotie1990"
          }
        },
        {
          "id": "IC_kwDODQzyOs41V06j",
          "body": "```javascript\r\n\r\nfunction find (data) {\r\n    const temp = Array.isArray(data) ? [...data] : {...data}\r\n    let opt = {\r\n        where: function where (opt) {\r\n            return find(Object.entries(opt).reduce((prev, [key, match]) => {\r\n                return prev.filter(curr => {\r\n                    return match.test(curr[key])\r\n                })\r\n            }, this))\r\n        },\r\n        orderBy: function order (key, type) {\r\n            return this.sort((prev, next) => {\r\n                switch (type) {\r\n                    case 'desc':\r\n                        return next - prev\r\n                    case 'asc':\r\n                        return prev - next\r\n                    default:\r\n                        return prev - next\r\n                }\r\n            })\r\n        }\r\n    }\r\n    Object.setPrototypeOf(opt, Array.prototype)\r\n    Object.setPrototypeOf(temp, opt)\r\n    return temp\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs41WMRt",
          "body": "```js\r\n// 综合一下两位大佬的写法\r\nclass Find {\r\n    constructor(data) {\r\n        this.data = [...data];\r\n    }\r\n\r\n    where(query) {\r\n        this.data = this.data.filter((item) => {\r\n            return Object.entries(query).every(([key, value]) => {\r\n                if (value instanceof RegExp) {\r\n                    return value.test(item[key]);\r\n                } else {\r\n                    return item[key] === value;\r\n                }\r\n            });\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    orderBy(key, type) {\r\n        this.data = this.data.sort((a, b) => (type !== 'desc' ? a[key] - b[key] : b[key] - a[key]));\r\n\r\n        return this;\r\n    }\r\n\r\n    get value() {\r\n        return this.data;\r\n    }\r\n}\r\n\r\nfunction find(data) {\r\n    return new Find(data);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "vandvassily",
            "url": "https://github.com/vandvassily"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjM2NTUyMzQ=",
    "number": 713,
    "title": "【Q692】什么是协变与逆变",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41V_pN",
          "body": "> 协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45QIPR",
          "body": "https://github.com/sl1673495/blogs/issues/54",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "IC_kwDODQzyOs45QIQO",
          "body": "https://www.zhihu.com/question/38861374",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "IC_kwDODQzyOs5QSFA1",
          "body": "# TypeScript 逆变和协变\r\n> 文章中所有的代码均在这里 [TS Playground - An online editor for exploring TypeScript and JavaScript](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgIImAWzgG2QbwChkTkQ5MIAuZAZzClAHNCBfQw0SWRFAEQD2TZBAAekEABNaaDNjxFSyAPTLkgcRNAfDqAX3WKkA7nCZNmAFTjAcACgCUNAG4Dgkthy7R4SZAGEBUEyLiEFIygsKKpAhwIADqRiYgTDTwOLQQroQ4EGDI0Vi4NOj5eAC8BHok5JQ0AOR58jUANGwA3JnZyJJCNGHIZRGVFNTINWACmE0VyIbGZhbWNgTICAIgtAJZAHQ4QlY1MwlM5pYAhDWLrM2sbYT1uH2dQhxgAJ4ADigAYiAAjA9WcH8PSEixKAD5kGFnu8viAAEz-QFJWTFUEQ3z+YAcLI5GC-GjfH5tHHIPFwgnwm6EPF-MpkoA)\r\n\r\n## 一些概念\r\n### Subtyping 子类型\r\n在编程语言理论中，子类型是一种类型多态的形式，这种类型可以替换其超类型(supertype)。如果 S 是 T 的子类型，一般表示为 S <: T，意思是在任何类型为 T 的地方都可以安全的使用 S。\r\n```js\r\ntype T = number\r\ntype S = T | string\r\n\r\ntype Fn = (arg: T) => void\r\n\r\nlet fn: Fn = (arg: S) => {}\r\n```\r\n上面的代码我们定义了 T 和 S 类型，然后定义了一个 参数为 T 返回值为 any 的函数类型 Fn， 但是在具体的赋值的时候我们将 args 变为 S，程序是可以正常运行的。\r\n### 协变与逆变\r\n> 协变与逆变（Covariance and contravariance）是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。\r\n在一门程序设计语言的[类型系统](https://zh.wikipedia.org/wiki/%E5%9E%8B%E5%88%A5%E7%B3%BB%E7%B5%B1)中，一个类型规则或者类型构造器是：\r\n- 协变（covariant），如果它保持了[子类型序关系≦](https://zh.wikipedia.org/wiki/%E5%AD%90%E5%9E%8B%E5%88%A5)。该序关系是：子类型≦基类型。\r\n- 逆变（contravariant），如果它逆转了子类型序关系。\r\n- 不变（invariant），如果上述两种均不适用。\r\n维基百科中的描述有点抽象，我们提取一下关键词\r\n- 父/子型别\r\n- 构造器构造\r\n- 是否具有父/子型别关系\r\n我们先用简单的数学模拟一下，假设我们现在有两个值 x = -1 ， y = -5，x 和 y 的关系为 x > y。\r\n假设现在有函数 \r\n$$f(t) = t + 10$$\r\n将我们的 x 和 y 代入 f(t) 后得到 f(x) = 9 和 f(y) = 5 ，可以发现 f(x) 和 f(y) 的关系仍然为 f(x) > f(y)，这就是典型的协变。\r\n假设如下函数\r\n$$g(t) = t^2$$\r\ng(x) = 1 < g(y) = 5 这就是逆变。\r\n上面只是举了一个很简单并且不够严谨的例子，主要是为了方便理解，现在我们看一下在 ts 中的实现。\r\n### TypeScript实现\r\n考虑如下类型\r\n```js\r\ndinterface Animal {\r\n    name: string\r\n}\r\n\r\ninterface Dog extends Animal {\r\n    // 摇尾巴\r\n    waggingTail(): void\r\n}\r\n\r\ninterface Corgi extends Dog {\r\n    canWagging: false\r\n}\r\n```\r\n代码中我们定义了三个类型，他们之间的子集关系为 Corgi <: Dog <: Animal。\r\n```js\r\n// 协变\r\ntype AnimalList = Array<Animal>\r\ntype DogList = Array<Dog>\r\n\r\nlet animalArr: AnimalList = [];\r\nlet dogArr: DogList = [];\r\n// ✅ DogList 为 AnimalList 子集\r\nanimalArr = dogArr;\r\n```\r\n我们再考虑一种特殊情况\r\n```js\r\ntype Fn1 = (arg: Dog) => Dog\r\n```\r\nFn1 类型的子类型是什么呢？\r\n是 (arg: Corgi) => Corgi吗？\r\n考虑如下场景\r\n![image](https://user-images.githubusercontent.com/73587626/207111255-346a9f4b-22ae-4f8b-939d-1429b95888cc.png)\r\n显然 Fn3 并不是 Fn1 的子类型。\r\n我们分析一下这样为什么不被允许，由于 Fn3 类型的限制，这里 fn3 函数的参数只能传入 arg 为 Corgi 类型的函数，但是本来的 Fn1 是允许任何 Dog 类型的参数，所以 ts 禁止了这样的操作。\r\n所以 Fn1 的子类型应该为参数可以接受任何类型的 Dog，返回值具有 Dog 所有值的类型。\r\n所以正确答案是 (arg: Animal) => Corgi 。\r\n![image](https://user-images.githubusercontent.com/73587626/207111384-9e00ad55-266f-4149-b487-60530555a103.png)\r\n> 为了方便表示，这里我们定义 A → B 指的是以 A 为参数类型，以 B 为返回值类型的函数类型。\r\n返回值类型很容易理解：柯基是狗的子类型。但参数类型则是相反的：动物是狗的父类。\r\n用合适的术语来描述这个奇怪的表现，可以说我们允许一个函数类型中，返回值类型是协变的，而参数类型是逆变的。返回值类型是协变的，意思是 A <: B 就意味着 (T → A) <: (T → B) 。参数类型是逆变的，意思是 A <: B 就意味着 (B → T) <: (A → T) （ A 和 B 的位置颠倒过来了）。\r\n一个有趣的现象：在 TypeScript 中， [参数类型是双向协变的](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant) ，也就是说既是协变又是逆变的，而这并不安全。但是现在你可以在 [TypeScript 2.6](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html) 版本中通过 --strictFunctionTypes 或 --strict 标记来修复这个问题。\r\n\r\n参考\r\n- [维基百科-子类型](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%B1%BB%E5%9E%8B)\r\n- [维基百科-协变与逆变](https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98#%E2%80%9C%E5%8D%8F%E5%8F%98%E2%80%9D%E4%B8%80%E8%AF%8D%E7%9A%84%E6%9D%A5%E6%BA%90)\r\n- [What are covariance and contravariance? | Stephan Boyer](https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "huangyulie",
            "url": "https://github.com/huangyulie"
          }
        },
        {
          "id": "IC_kwDODQzyOs5jsuxV",
          "body": "dinterface Animal -> interface",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "pkc918",
            "url": "https://github.com/pkc918"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMjEzODUzNTU2",
          "name": "ts"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjQ2MzkxMTM=",
    "number": 714,
    "title": "【Q693】在 ts 中如何实现 Partial",
    "body": "实现 `Partial`，使得 Object 所有的属性变为可选属性。\r\n\r\n> PS: `Partial` 已经在 TS 中原生实现，见文档: <https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype>\r\n\r\n``` ts\r\ntype User = {\r\n  id: number;\r\n  age: number;\r\n  name: string;\r\n}\r\n\r\n// Output:\r\n// type PartialUser = {\r\n//   id?: number | undefined;\r\n//   age?: number | undefined;\r\n//   name?: string | undefined;\r\n// }\r\ntype PartialUser = Partial<User>\r\n```\r\n\r\n以下是使用案例\r\n\r\n``` ts\r\ninterface Todo {\r\n  title: string;\r\n  description: string;\r\n}\r\n \r\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\r\n  return { ...todo, ...fieldsToUpdate };\r\n}\r\n \r\nconst todo1 = {\r\n  title: \"organize desk\",\r\n  description: \"clear clutter\",\r\n};\r\n \r\nconst todo2 = updateTodo(todo1, {\r\n  description: \"throw out trash\",\r\n});\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41ZEcJ",
          "body": "``` ts\r\ntype Partial<T> = {\r\n  [P in keyof T]?: T[P]\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMjEzODUzNTU2",
          "name": "ts"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjQ2NDYxMTE=",
    "number": 715,
    "title": "【Q694】在 ts 中什么是 infer，并实现 Parameters 与 ReturnType",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41Z7ci",
          "body": "```typescript\r\ntype Parameters<T extends (...args: any[]) => unknown> = T extends (...args: infer R) => unknown ? R : never\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs41fPTs",
          "body": "Parameters 是啥",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhimazz",
            "url": "https://github.com/zhimazz"
          }
        },
        {
          "id": "IC_kwDODQzyOs41fScx",
          "body": "> Parameters 是啥\r\n\r\n取得某个函数的参数类型的高级类型",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs41xVFb",
          "body": "Parameters<T> 的作用是用于获得函数的参数类型组成的元组类型。\r\n\r\n```tsx\r\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any \r\n  ? P : never;\r\n```\r\n\r\n```tsx\r\ntype A = Parameters<() => void>; // []\r\ntype B = Parameters<typeof Array.isArray>; // [any]\r\ntype C = Parameters<typeof parseInt>; // [string, (number | undefined)?]\r\ntype D = Parameters<typeof Math.max>; // number[]\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMjEzODUzNTU2",
          "name": "ts"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NjU3OTA4NDE=",
    "number": 716,
    "title": "【Q695】Flex 布局中的 flex-basis 与 width 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41bwYZ",
          "body": "1. 当 `flex-direction` 为 `column` 时，主轴为纵轴，此时 `flex-basis` 与 `height` 对应\r\n2. `flex-basis` 的值为理想情况，而在实际情况中可能被压缩",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5lXgVr",
          "body": "flex-basis用于在flex布局时候给定项目的一个初始值， 默认情况下是auto，也就是说根据容器宽度去自动计算，width是给定项目固定宽度。\r\n1. 当flex布局的主轴是水平方向即flex-direction: row;那么flex-basis设定的就是初始宽度，如果同时存在width，width会覆盖flex-basis属性\r\n2. 当flex布局的主轴是垂直方向即flex-direction: column;那么flex-basis设定的就是初始高度，如果同时存在height，width会覆盖flex-basis属性;\r\n[demo示例](https://stackblitz.com/edit/web-platform-rprew4?file=styles.css,index.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Neisun",
            "url": "https://github.com/Neisun"
          }
        },
        {
          "id": "IC_kwDODQzyOs5m-oed",
          "body": "> flex-basis用于在flex布局时候给定项目的一个初始值， 默认情况下是auto，也就是说根据容器宽度去自动计算，width是给定项目固定宽度。\r\n> \r\n> 1. 当flex布局的主轴是水平方向即flex-direction: row;那么flex-basis设定的就是初始宽度，如果同时存在width，width会覆盖flex-basis属性\r\n> 2. 当flex布局的主轴是垂直方向即flex-direction: column;那么flex-basis设定的就是初始高度，如果同时存在height，width会覆盖flex-basis属性;\r\n>    [demo示例](https://stackblitz.com/edit/web-platform-rprew4?file=styles.css,index.html)\r\n\r\n我觉得你说错了，flex-basis设置的宽高的优先级是大于传统的width和height，希望你可以再去看看再来回答。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ainightf",
            "url": "https://github.com/ainightf"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Njk4MzEwNTg=",
    "number": 718,
    "title": "【Q696】OSCP Stapling 是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NzI3NDU2MTA=",
    "number": 719,
    "title": "【Q697】npm 执行命令传递参数时，为何需要双横线",
    "body": "如在` npm script` 中有以下命令：\r\n\r\n``` js\r\n{\r\n  \"start\": \"serve\"\r\n}\r\n```\r\n\r\n其中 `serve` 可通过 `--port` 指定端口号：\r\n\r\n``` bash\r\n$ npm start -- --port 8080\r\n\r\n# 而在 yarn 时无需传递参数\r\n$ yarn start --port 8080\r\n```\r\n\r\n那为什么 npm 执行命令传递参数时，为何需要双横线",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41xQIX",
          "body": "https://github.com/npm/npm/pull/5518\r\nnpm脚本执行时会开启一个shell，执行后面指定的脚本命令或文件， -- 是为了给后面shell脚本命令传递参数，类似node环境的process.argv的吧。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        },
        {
          "id": "MDU6TGFiZWwyMTA5NjQyNTA2",
          "name": "shell"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5NzMyMjM3NTg=",
    "number": 720,
    "title": "【Q698】有没有使用过 Node 的 inspect 这个核心模块",
    "body": "文档：[Node Inspector API](https://nodejs.org/api/inspector.html)\r\n\r\n``` js\r\nconst inspector = require('inspector');\r\n```\r\n",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs41sWTt",
          "body": "``` js\r\n  const session = new inspector.Session()\r\n  session.connect()\r\n  session.post('Profiler.enable', () => {\r\n    session.post('Profiler.start', start)\r\n  })\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs41xLOK",
          "body": "inspector 模块提供了与 V8 检查器交互的 API。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "iceycc",
            "url": "https://github.com/iceycc"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5Nzc4NDI1NzM=",
    "number": 721,
    "title": "【Q699】在虚拟 DOM 中进行 diff 算法时，介绍当根据 key 对数组进行重用时的算法",
    "body": "如以下示例，当从上方五个 div 变为下方五个 div 时，由于 diff 算法，无需重复构建 DOM 创建五个新的 div 标签。\r\n\r\n请写出此时重用的算法，并给出时间复杂度\r\n\r\n``` html\r\n<div key=\"1\">Demo 1</div>\r\n<div key=\"2\">Demo 2</div>\r\n<div key=\"3\">Demo 3</div>\r\n<div key=\"4\">Demo 4</div>\r\n<div key=\"5\">Demo 5</div>\r\n\r\n\r\n<div key=\"4\">Demo 4</div>\r\n<div key=\"5\">Demo 5</div>\r\n<div key=\"2\">Demo 2</div>\r\n<div key=\"1\">Demo 1</div>\r\n<div key=\"3\">Demo 3</div>\r\n```\r\n\r\n``` js\r\nfunction updateChildren (element, oldVnodes, newVnodes) {\r\n  \r\n}\r\n```\r\n\r\n## 可参考\r\n\r\n1. [编辑距离](https://leetcode-cn.com/problems/edit-distance/)",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5GMPkg",
          "body": "vue2用的双端diff，复杂度O(n²).\r\n代码：\r\n function updateChildren(\r\n    parentElm,\r\n    oldCh,\r\n    newCh,\r\n    insertedVnodeQueue,\r\n    removeOnly\r\n  ) {\r\n    let oldStartIdx = 0\r\n    let newStartIdx = 0\r\n    let oldEndIdx = oldCh.length - 1\r\n    let oldStartVnode = oldCh[0]\r\n    let oldEndVnode = oldCh[oldEndIdx]\r\n    let newEndIdx = newCh.length - 1\r\n    let newStartVnode = newCh[0]\r\n    let newEndVnode = newCh[newEndIdx]\r\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\r\n\r\n    // removeOnly is a special flag used only by <transition-group>\r\n    // to ensure removed elements stay in correct relative positions\r\n    // during leaving transitions\r\n    const canMove = !removeOnly\r\n\r\n    if (__DEV__) {\r\n      checkDuplicateKeys(newCh)\r\n    }\r\n\r\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n      if (isUndef(oldStartVnode)) {\r\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\r\n      } else if (isUndef(oldEndVnode)) {\r\n        oldEndVnode = oldCh[--oldEndIdx]\r\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n        patchVnode(\r\n          oldStartVnode,\r\n          newStartVnode,\r\n          insertedVnodeQueue,\r\n          newCh,\r\n          newStartIdx\r\n        )\r\n        oldStartVnode = oldCh[++oldStartIdx]\r\n        newStartVnode = newCh[++newStartIdx]\r\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n        patchVnode(\r\n          oldEndVnode,\r\n          newEndVnode,\r\n          insertedVnodeQueue,\r\n          newCh,\r\n          newEndIdx\r\n        )\r\n        oldEndVnode = oldCh[--oldEndIdx]\r\n        newEndVnode = newCh[--newEndIdx]\r\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n        // Vnode moved right\r\n        patchVnode(\r\n          oldStartVnode,\r\n          newEndVnode,\r\n          insertedVnodeQueue,\r\n          newCh,\r\n          newEndIdx\r\n        )\r\n        canMove &&\r\n          nodeOps.insertBefore(\r\n            parentElm,\r\n            oldStartVnode.elm,\r\n            nodeOps.nextSibling(oldEndVnode.elm)\r\n          )\r\n        oldStartVnode = oldCh[++oldStartIdx]\r\n        newEndVnode = newCh[--newEndIdx]\r\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n        // Vnode moved left\r\n        patchVnode(\r\n          oldEndVnode,\r\n          newStartVnode,\r\n          insertedVnodeQueue,\r\n          newCh,\r\n          newStartIdx\r\n        )\r\n        canMove &&\r\n          nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\r\n        oldEndVnode = oldCh[--oldEndIdx]\r\n        newStartVnode = newCh[++newStartIdx]\r\n      } else {\r\n        if (isUndef(oldKeyToIdx))\r\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\r\n        idxInOld = isDef(newStartVnode.key)\r\n          ? oldKeyToIdx[newStartVnode.key]\r\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\r\n        if (isUndef(idxInOld)) {\r\n          // New element\r\n          createElm(\r\n            newStartVnode,\r\n            insertedVnodeQueue,\r\n            parentElm,\r\n            oldStartVnode.elm,\r\n            false,\r\n            newCh,\r\n            newStartIdx\r\n          )\r\n        } else {\r\n          vnodeToMove = oldCh[idxInOld]\r\n          if (sameVnode(vnodeToMove, newStartVnode)) {\r\n            patchVnode(\r\n              vnodeToMove,\r\n              newStartVnode,\r\n              insertedVnodeQueue,\r\n              newCh,\r\n              newStartIdx\r\n            )\r\n            oldCh[idxInOld] = undefined\r\n            canMove &&\r\n              nodeOps.insertBefore(\r\n                parentElm,\r\n                vnodeToMove.elm,\r\n                oldStartVnode.elm\r\n              )\r\n          } else {\r\n            // same key but different element. treat as new element\r\n            createElm(\r\n              newStartVnode,\r\n              insertedVnodeQueue,\r\n              parentElm,\r\n              oldStartVnode.elm,\r\n              false,\r\n              newCh,\r\n              newStartIdx\r\n            )\r\n          }\r\n        }\r\n        newStartVnode = newCh[++newStartIdx]\r\n      }\r\n    }\r\n    if (oldStartIdx > oldEndIdx) {\r\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\r\n      addVnodes(\r\n        parentElm,\r\n        refElm,\r\n        newCh,\r\n        newStartIdx,\r\n        newEndIdx,\r\n        insertedVnodeQueue\r\n      )\r\n    } else if (newStartIdx > newEndIdx) {\r\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx)\r\n    }\r\n  }\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zzzlight",
            "url": "https://github.com/zzzlight"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5ODAwNzMzNjI=",
    "number": 722,
    "title": "【Q700】http client 中如何得知已接收完所有响应数据",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5ODAyMjcyNDY=",
    "number": 723,
    "title": "【Q701】实现函数 promisify，把回调函数改成 promise 形式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs42DW4M",
          "body": "```javascript\r\nfunction promisify(fn) {\r\n  return function(...args) {\r\n    let hasCb = args.some(v => typeof v === 'function')\r\n    if (hasCb) {\r\n      fn(...args)\r\n    } else {\r\n      return new Promise((resolve, reject) => {\r\n        fn(...args, cb)\r\n\r\n        function cb(err, data) {\r\n          if (err) {\r\n            reject(err)\r\n          } else {\r\n            resolve(data)\r\n          }\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Asarua",
            "url": "https://github.com/Asarua"
          }
        },
        {
          "id": "IC_kwDODQzyOs47qgl1",
          "body": "首先明确nodeCallback的规范：\r\n1、回调函数在主函数参数的位置是最后一个\r\n2、回调函数的第一个参数是error\r\n 例如\r\n```\r\nfunction main(err, b, c, callback) {\r\n  let data = b+c\r\n  callback(err,data)\r\n }\r\n```\r\n所以实现的思路就是：\r\n 把结果由原先的放在callback中返回，改成放在Promise中返回\r\n```\r\nconst promisify = (fnc) => (...args) => {\r\n  return new Promise((resolve, reject) => {\r\n    fnc.call(this, ...args, function (err, data) {\r\n      if (err) {\r\n        reject(err);\r\n      } else {\r\n        resolve(data);\r\n      }\r\n    });\r\n  });\r\n};\r\n```\r\n测试结果：\r\n```\r\nvar func1 = function (a, b, c, callback) {\r\n  let rst = a + b + c;\r\n  callback(null, rst);\r\n};\r\n```\r\n```\r\nvar func2 = promisify(func1);\r\nfunc2(1, 2, 3).then((rst) => {\r\n  console.log(\"rst\", rst);\r\n}); //输出6\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangjiayan",
            "url": "https://github.com/wangjiayan"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5ODE2Njc4MzE=",
    "number": 724,
    "title": "【Q702】return promise 与 return await promise 有何区别",
    "body": "如\r\n\r\n``` js\r\nasync function p1 () {\r\n  return 3\r\n}\r\n\r\nasync function p2 () {\r\n  return Promise.resolve(3)\r\n}\r\n\r\nasync function p3 () {\r\n  return await Promise.resolve(3)\r\n}\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46ZoNP",
          "body": "return promise:\r\n\r\n返回结果为 Promise {fulfilled或者 rejected}\r\n\r\nreturn await promise:\r\n\r\n返回结果为 Promise {pending}, 因为 async 函数总是返回一个 promise (resolved promise?\r\n\r\n希望可以得到山月的反馈",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liweinanone",
            "url": "https://github.com/liweinanone"
          }
        },
        {
          "id": "IC_kwDODQzyOs46eX51",
          "body": "``` js\r\nasync function p1 () {\r\n  return 3\r\n}\r\n\r\nasync function p2 () {\r\n  return Promise.resolve(3)\r\n}\r\n\r\nasync function p3 () {\r\n  return await Promise.resolve(3)\r\n}\r\n\r\n// Output: p1、p3、p2\r\np3().then(o => console.log(o, 'p3'))\r\np2().then(o => console.log(o, 'p2'))\r\np1().then(o => console.log(o, 'p1'))\r\n```\r\n\r\n@liweinanone 最终返回得到的结果是相同的，但是有些顺序的变化，可看此例",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5OzIId",
          "body": "主要在await会等待Promise的完结状态，如果Promise为reject，会在当前trycatch中被捕获，否则会将reject传递到外层。\r\nhttps://stackoverflow.com/questions/38708550/difference-between-return-await-promise-and-return-promise",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "PstereoJW",
            "url": "https://github.com/PstereoJW"
          }
        },
        {
          "id": "IC_kwDODQzyOs5mQbnl",
          "body": "上述例子为什么先调用p2 结果还是没有改变?\r\n``` \r\np2().then(o => console.log(o, 'p2'))\r\np3().then(o => console.log(o, 'p3'))\r\np1().then(o => console.log(o, 'p1'))\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xylon001",
            "url": "https://github.com/xylon001"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5ODIzODUwMzM=",
    "number": 725,
    "title": "【Q703】在 ES6 Class 中，super 的过程中做了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44yEPo",
          "body": "本质就是call（this）",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs44yEXc",
          "body": "```\r\nclass Super {\r\n  constructor() {\r\n    //do something\r\n  }\r\n}\r\n\r\nclass Sub extends Super {\r\n  constructor() {\r\n    super();\r\n    //do something else\r\n  }\r\n}\r\n\r\n//=========等价于=========\r\n\r\nfunction Super() {\r\n  //do something\r\n}\r\n\r\nfunction Sub() {\r\n  Sub.prototype.__proto__ = Super.prototype; //extends\r\n  Super.call(this); //constructor中的super\r\n  //但是其实这个地方严格讲是有问题的\r\n  //在使用ES6 class的时候，constructor并不负责创建成员函数\r\n  //但是在用Constructor function时，一个function要管所有的\r\n  //成员变量和函数的创建。\r\n  //而Super里的所有东西都释放到当前上下文this中是不合适的\r\n  //会出现命名冲突之类的\r\n  //babel的具体的实现要比这个复杂很多。\r\n\r\n  //do something else\r\n}```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU5OTQxNjYwNzg=",
    "number": 727,
    "title": "【Q704】关于 Promise，判断以下代码的输出",
    "body": "``` js\r\nPromise.resolve().then(() => {\r\n  console.log(0)\r\n  return Promise.resolve(4)\r\n}).then(res => {\r\n  console.log(res)\r\n})\r\n\r\nPromise.resolve().then(() => {\r\n  console.log(1)\r\n}).then(() => {\r\n  console.log(2)\r\n}).then(() => {\r\n  console.log(3)\r\n}).then(() => {\r\n  console.log(5)\r\n}).then(() => {\r\n  console.log(6)\r\n})\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45tW63",
          "body": "0 1 2 3 4 5 6\r\n?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "okbug",
            "url": "https://github.com/okbug"
          }
        },
        {
          "id": "IC_kwDODQzyOs46Zjiq",
          "body": "> \r\n可以解释一下为什么吗?\r\n我的错误答案是: 0 1 2 3 5 6 4",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "liweinanone",
            "url": "https://github.com/liweinanone"
          }
        },
        {
          "id": "IC_kwDODQzyOs46vHCX",
          "body": "0142356",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "mengliren666",
            "url": "https://github.com/mengliren666"
          }
        },
        {
          "id": "IC_kwDODQzyOs48yOTk",
          "body": "`0 1 2 3 4 5 6`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "9527YL",
            "url": "https://github.com/9527YL"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-Dnpx",
          "body": "之前看过PromiseA+源码，结果碰上这道题还是理解，我给大家找到了相应的知乎解答：https://www.zhihu.com/question/453677175。\r\n这边，我来阐述下我的理解：\r\n顺序执行 0 和 1 应该大家都没什么问题，所以现在问题变成了为什么return Promise 为什么产生了 2 次微任务？\r\n知乎评论里有人说：根据 promise/A+ ，结果应该为 0 1 2 4 3 5 6 ，也就是根据Promise/A++ 标准只产生了1次微任务。\r\n按照PromiseA+的规范，此处应该是2.3.2标准：`If x is a promise` ,根据A+准则的源码是以这么处理的：\r\n1. 遇到.then就创建一pending状态的Promise保存起来。\r\n2. 如果是一个普通的number类型，则直接用Promise.resolve(number)即可。\r\n    如果是 promise类型的话，需要做一个状态同步操作，代码如下：\r\n    其中 x 是接收的已经resolved 的 Promise，即(Promise.resolve(4))，而this指向我们刚创建的 pending 状态的 Promise \r\n```javascript\r\nresolveWithPromise(x) {\r\n    x.then(\r\n      result => {\r\n        this.resolve(result); // promise将结果给resolve\r\n      },\r\n      reason => {\r\n        this.reject(reason);\r\n      }\r\n    );\r\n```\r\n也就是说，这1个micro task的作用就是同步状态。\r\n\r\n至于还有一个微任务的产生原因是来自：v8和PromiseA+规范的差异。\r\nv8中的Promie实现是通过C++编写的，与promise/A+规范的不同之处在于，v8并没有对`x is a promise` 的情况做处理，而是只有对`x is an object`的处理。所以多了一步micro task：作用就是将 resolveWithPromise => resolveWithThenableObject，伪代码如下：\r\n```javascript\r\nif(x instanceOf MyPromise){\r\n    createPromiseResolveThenableJob // + micro task\r\n}\r\n```\r\n========================================================================\r\n以上仅仅只是我阅读知乎后的粗略理解，如果有说的不对的望指正！\r\n面试的时候只需要简单记住：如果resolve()的括号内的结果是一个promise的话，会多执行两个`micro task`\r\n类似的题目有：\r\n\r\n```javascript\r\nnew Promise(resolve => {\r\n    let resolvedPromise = Promise.resolve()\r\n    resolve(resolvedPromise)\r\n}).then(() => {\r\n    console.log('resolvePromise resolved')\r\n})\r\n\r\nPromise.resolve()\r\n   .then(() => { console.log('promise1') })\r\n   .then(() => { console.log('promise2') })\r\n   .then(() => { console.log('promise3') })\r\n```\r\n结果是：'resolvePromise resolved' 是在 'promise2' 后面打印出来的。\r\n\r\n\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangjs-jacky",
            "url": "https://github.com/wangjs-jacky"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs48CaWm",
    "number": 729,
    "title": "【Q705】webpack 的 runtime 做了什么事情",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs43RFL_",
          "body": "## Webpack Runtime\r\n\r\n`webpack` 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事:\r\n\r\n1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。\r\n2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，执行 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存\r\n3. `__webpack_require__(0)`: 运行第一个模块，即运行入口模块\r\n\r\n另外，当涉及到多个 chunk 的打包方式中，比如 `code spliting`，webpack 中会有 `jsonp` 加载 chunk 的运行时代码。\r\n\r\n以下是 `webpack runtime` 的最简代码，配置示例可见 [node-examples](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/cjs/example/main.js)\r\n\r\n``` js\r\n/******/ var __webpack_modules__ = ([\r\n/* 0 */,\r\n/* 1 */\r\n/***/ ((module) => {\r\n\r\nmodule.exports = (...args) => args.reduce((x, y) => x + y, 0)\r\n\r\n/***/ })\r\n/******/ ]);\r\n/************************************************************************/\r\n/******/ // The module cache\r\n/******/ var __webpack_module_cache__ = {};\r\n/******/ \r\n/******/ // The require function\r\n/******/ function __webpack_require__(moduleId) {\r\n/******/ \t// Check if module is in cache\r\n/******/ \tvar cachedModule = __webpack_module_cache__[moduleId];\r\n/******/ \tif (cachedModule !== undefined) {\r\n/******/ \t\treturn cachedModule.exports;\r\n/******/ \t}\r\n/******/ \t// Create a new module (and put it into the cache)\r\n/******/ \tvar module = __webpack_module_cache__[moduleId] = {\r\n/******/ \t\t// no module.id needed\r\n/******/ \t\t// no module.loaded needed\r\n/******/ \t\texports: {}\r\n/******/ \t};\r\n/******/ \r\n/******/ \t// Execute the module function\r\n/******/ \t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\r\n/******/ \r\n/******/ \t// Return the exports of the module\r\n/******/ \treturn module.exports;\r\n/******/ }\r\n/******/ \r\n/************************************************************************/\r\nvar __webpack_exports__ = {};\r\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\r\n(() => {\r\nconst sum = __webpack_require__(1)\r\n\r\nsum(3, 8)\r\n\r\n})();\r\n```\r\n\r\n对 `webpack runtime` 做进一步的精简，代码如下\r\n\r\n``` js\r\nconst __webpack_modules__ = [() => {}]\r\nconst __webpack_require__ = id => {\r\n  const module = { exports: {} }\r\n  const m = __webpack_modules__[id](module, __webpack_require__)\r\n  return module.exports\r\n}\r\n\r\n__webpack_require__(0)\r\n```\r\n\r\n使用动画表示 Webpack 的输入输出:\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-28/bundle-webpack.0693ce.gif)\r\n\r\n## Rollup\r\n\r\n在 Rollup 中，并不会将所有模块置于 `modules` 中使用 Module Wrapper 进行维护，**它仅仅将所有模块铺平展开**。\r\n\r\n试举一例:\r\n\r\n``` js\r\n// index.js\r\nimport name from './name'\r\nconsole.log(name)\r\n```\r\n\r\n``` js\r\n// name.js\r\nconst name = 'shanyue'\r\nexport default name\r\n```\r\n\r\n在打包后，直接把所有模块平铺展开即可，可见[实时示例](https://rollupjs.org/repl/?version=2.62.0&shareable=JTdCJTIybW9kdWxlcyUyMiUzQSU1QiU3QiUyMm5hbWUlMjIlM0ElMjJtYWluLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMmltcG9ydCUyMG5hbWUlMjBmcm9tJTIwJy4lMkZuYW1lJyU1Q25jb25zb2xlLmxvZyhuYW1lKSUyMiUyQyUyMmlzRW50cnklMjIlM0F0cnVlJTdEJTJDJTdCJTIybmFtZSUyMiUzQSUyMm5hbWUuanMlMjIlMkMlMjJjb2RlJTIyJTNBJTIyY29uc3QlMjBuYW1lJTIwJTNEJTIwJ3NoYW55dWUnJTVDbmV4cG9ydCUyMGRlZmF1bHQlMjBuYW1lJTIyJTJDJTIyaXNFbnRyeSUyMiUzQWZhbHNlJTdEJTVEJTJDJTIyb3B0aW9ucyUyMiUzQSU3QiUyMmZvcm1hdCUyMiUzQSUyMmVzJTIyJTJDJTIybmFtZSUyMiUzQSUyMm15QnVuZGxlJTIyJTJDJTIyYW1kJTIyJTNBJTdCJTIyaWQlMjIlM0ElMjIlMjIlN0QlMkMlMjJnbG9iYWxzJTIyJTNBJTdCJTdEJTdEJTJDJTIyZXhhbXBsZSUyMiUzQW51bGwlN0Q=)\r\n\r\n``` js\r\n// output.js\r\nconst name = 'shanyue'\r\nconsole.log(name)\r\n```\r\n\r\n对于 Rollup 这种方案，当两个模块中发生变量冲突如何解决？很简单，直接重新命名，看示例:\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-28/clipboard-9429.b9ad82.webp)\r\n\r\n使用动画表示 Rollup 的输入输出:\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-28/bundle-rollup.60cb6a.gif)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs48doFg",
    "number": 730,
    "title": "【Q706】typescript 中 interface 与 type 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs43m8A5",
          "body": "https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs44x-CJ",
          "body": "interface是接口，type是类型，本身就是两个概念。只是碰巧表现上比较相似。\r\n希望定义一个变量类型，就用type，如果希望是能够继承并约束的，就用interface。\r\n如果你不知道该用哪个，说明你只是想定义一个类型而非接口，所以应该用type。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "illumi520",
            "url": "https://github.com/illumi520"
          }
        },
        {
          "id": "IC_kwDODQzyOs5O4yrx",
          "body": "interface和type都可以用来声明和约束变量类型结构，interface可以被继承重载，type要想被继承只能使用联合&，而且interface的性能比type更好\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coderhn",
            "url": "https://github.com/coderhn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMjEzODUzNTU2",
          "name": "ts"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs48doXN",
    "number": 731,
    "title": "【Q707】请简述 typescript 中的 infer",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45tW5l",
          "body": "和returnType有点关联，做返回值推断的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "okbug",
            "url": "https://github.com/okbug"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DbDgu",
          "body": "`infer` 表示在 `extends` 条件语句中待推断的类型变量。\r\n\r\n例子：\r\n```ts\r\n/**\r\n * Obtain the parameters of a function type in a tuple\r\n */\r\ntype Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/31235016/169199143-86c51c9c-12a8-4512-bdaa-911d93116b97.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "canvascat",
            "url": "https://github.com/canvascat"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMjEzODUzNTU2",
          "name": "ts"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs481wLk",
    "number": 733,
    "title": "【Q708】webpack 中的 code spliting 是如何动态加载 chunk 的？",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs437rs-",
          "body": "一个 `webpack` 的运行时，包括最重要的两个数据结构：\r\n\r\n1. `__webpack_modules__`: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 `(module, module.exports, __webpack_require__)` 对模块进行包裹构成。\r\n2. `__webpack_require__(moduleId)`: 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，根据 id 定位到 `__webpack_modules__` 中的包裹函数，执行并返回 `module.exports`，并缓存。\r\n\r\n## code spliting\r\n\r\n在 webpack 中，通过 `import()` 可实现 code spliting。假设我们有以下文件:\r\n\r\n``` js\r\n// 以下为 index.js 内容\r\nimport('./sum').then(m => {\r\n  m.default(3, 4)\r\n})\r\n\r\n// 以下为 sum.js 内容\r\nconst sum = (x, y) => x + y\r\nexport default sum\r\n```\r\n\r\n我们将使用以下简单的 `webpack` 配置进行打包，具体示例可参考 [node-examples:code-spliting](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/code-spliting/build.js)\r\n\r\n``` js\r\n{\r\n  entry: './index.js',\r\n  mode: 'none',\r\n  output: {\r\n    filename: '[name].[contenthash].js',\r\n    chunkFilename: 'chunk.[name].[id].[contenthash].js',\r\n    path: path.resolve(__dirname, 'dist/deterministic'),\r\n    clean: true\r\n  },\r\n  optimization: {\r\n    moduleIds: 'deterministic',\r\n    chunkIds: 'deterministic'\r\n  }\r\n}\r\n```\r\n\r\n## 运行时解析\r\n\r\n通过观察打包后的文件 `dist/deterministic/main.xxxxxx.js`，可以发现: 使用 `import()` 加载数据时，以上代码将被 `webpack`  编译为以下代码\r\n\r\n``` js\r\n__webpack_require__.e(/* import() | sum */ 644)\r\n.then(__webpack_require__.bind(__webpack_require__, 709))\r\n.then(m => {\r\n  m.default(3, 4)\r\n})\r\n```\r\n\r\n此时 `644` 为 chunkId，观察 `chunk.sum.xxxx.js` 文件，以下为 `sum` 函数所构建而成的 chunk:\r\n\r\n``` js\r\n\"use strict\";\r\n(self[\"webpackChunk\"] = self[\"webpackChunk\"] || []).push([[644],{\r\n\r\n/***/ 709:\r\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\r\n\r\n        __webpack_require__.r(__webpack_exports__);\r\n        /* harmony export */ __webpack_require__.d(__webpack_exports__, {\r\n        /* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\r\n        /* harmony export */ });\r\n        const sum = (x, y) => x + y\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sum);\r\n\r\n\r\n/***/ })\r\n\r\n}]);\r\n```\r\n\r\n以下两个数据结构是加载 `chunk` 的关键:\r\n\r\n1. `__webpack_require__.e`: 加载 chunk。该函数将使用 `document.createElement('script')` 异步加载 chunk 并封装为 Promise。\r\n1. `self[\"webpackChunk\"].push`: JSONP cllaback，收集 modules 至 `__webpack_modules__`，并将 `__webpack_require__.e` 的 Promise 进行 resolve。\r\n\r\n实际上，在 `webpack` 中可配置 `output.chunkLoading` 来选择加载 chunk 的方式，比如选择通过 `import()` 的方式进行加载。(由于在生产环境需要考虑 import 的兼容性，目前还是 JSONP 方式较多)\r\n\r\n``` js\r\n{\r\n  entry: './index.js',\r\n  mode: 'none',\r\n  output: {\r\n    filename: 'main.[contenthash].js',\r\n    chunkFilename: '[name].chunk.[chunkhash].js',\r\n    path: path.resolve(__dirname, 'dist/import'),\r\n    clean: true,\r\n    // 默认为 `jsonp`\r\n    chunkLoading: 'import'\r\n  }\r\n})\r\n```\r\n\r\n可参考示例 [webpack 运行时代码](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/code-spliting/example/runtime.js) 中查看加载一个 chunk 的实现。\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs488Y9k",
    "number": 734,
    "title": "【Q709】core-js 是做什么用的？",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44BO0t",
          "body": "垫片",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coderxixi",
            "url": "https://github.com/coderxixi"
          }
        },
        {
          "id": "IC_kwDODQzyOs44BO3c",
          "body": "[core-js](https://github.com/zloirock/core-js) 是关于 ES 标准最出名的 `polyfill`，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。你也许每天都与它打交道，但你毫不知情。\r\n\r\n> 有一段时间，当你执行 `npm install` 并且项目依赖 `core-js` 时，会发现 `core-js` 的作者正借助于 `npm postinstall` 在找工作。\r\n\r\n由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本​越高，垫片越少，体积就会越小。\r\n\r\n以下代码便是 `Array.from`(ES6) 的垫片代码，有了它的存在，在任意浏览器中都可以使用 `Array.from` 这个 API。\r\n\r\n``` js\r\n// Production steps of ECMA-262, Edition 6, 22.1.2.1\r\nif (!Array.from) {\r\n  Array.from = () => { // 省略若干代码 }\r\n}\r\n```\r\n\r\n**而 `core-js` 的伟大之处是它包含了所有 `ES6+` 的 polyfill，并集成在 `babel` 等编译工具之中**\r\n\r\n试举一例: \r\n\r\n你在开发环境使用了 [Promise.any](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)，而它属于 `ES2021` 新出的 API，在部分浏览器里尚未实现，同时，你又使用了 `ES2020` 新出的操作符 `?.`。\r\n\r\n为了使代码能够在大部分浏览器里能够实现，你将会使用 `babel` 或者 `swc` 将代码编译为 ES5。\r\n\r\n**但是此时你会发现问题，*如果不做任何配置*，`babel`/`swc` 只能处理操作符，而无法处理新的 API。以下代码会报错**\r\n\r\n![babel](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/babel.j056lzjd1g0.png)\r\n\r\n好消息是，`core-js` 已集成到了 `babel`/`swc` 之中，你可以使用 `@babel/preset-env` 或者 `@babel/polyfill` 进行配置，详见文档 [core-js](https://github.com/zloirock/core-js)。**通过配置，`babel` 编译代码后将会自动包含所需的 polyfill**，如下所示。\r\n\r\n+ [点击查看以下代码在线演示](https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=usage&corejs=3.6&spec=false&loose=false&code_lz=AoJw9gtglgzgpgOgIYDsCeAKA2gZgLoCUCALgBZwoZgAEAvAHzUDGYKMYANoh2AOZUECAKCEs2xajVrUUAVw4cRY9lwQ9-YAPzJtAIwJA&debug=false&forceAllTransforms=true&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env&prettier=false&targets=&version=7.15.8&externalPlugins=&assumptions=%7B%7D)\r\n\r\n![babel-preset-env](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/babel-preset.4rbb4gbe77o0.png)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs49CIKr",
    "number": 735,
    "title": "【Q710】打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44GIfW",
          "body": "如果最终打包生成的 `main.js` 既没有做 code spliting，也没有做 `hash` 化路径。大可以通过在 `index.html` 中手动控制 JS 资源。\r\n\r\n``` js\r\n<body>\r\n  <script src=\"main.js\" defer />\r\n</body>\r\n```\r\n\r\n但往往事与愿违:\r\n\r\n1. `main.js` 即我们最终生成的文件带有 hash 值，如 `main.8a9b3c.js`。\r\n1. 由于长期缓存优化的需要，入口文件不仅只有一个，还包括由第三方模块打包而成的 `verdor.js`，同样带有 hash。\r\n1. 脚本地址同时需要注入 `publicPath`，而在生产环境与测试环境的 publicPath 并不一致\r\n\r\n因此需要有一个插件自动做这种事情。在 webpack 的世界里，它是 [html-webpak-plugin](https://github.com/jantimon/html-webpack-plugin)，在 rollup 的世界里，它是 [@rollup/plugin-html](https://github.com/rollup/plugins/tree/master/packages/html)。\r\n\r\n**而注入的原理为当打包器已生成 entryPoint 文件资源后，获得其文件名及 `publicPath`，并将其注入到 html 中**\r\n\r\n以 `html-webpack-plugin` 为例，它在 `compilation` 处理资源的 `processAssets` 获得其打包生成的资源。伪代码如下，可在 [mini-node:html-webpack-plugin](https://github.com/shfshanyue/mini-code/tree/master/code/html-webpack-plugin) 获得源码并运行示例。\r\n\r\n``` js\r\nclass HtmlWebpackPlugin {\r\n  constructor(options) {\r\n    this.options = options || {}\r\n  }\r\n\r\n  apply(compiler) {\r\n    const webpack = compiler.webpack\r\n\r\n    compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', (compilation) => {\r\n      // compilation 是 webpack 中最重要的对象，文档见 [compilation-object](https://webpack.js.org/api/compilation-object/#compilation-object-methods)\r\n\r\n      compilation.hooks.processAssets.tapAsync({\r\n        name: 'HtmlWebpackPlugin',\r\n\r\n        // processAssets 处理资源的时机，此阶段为资源已优化后，更多阶段见文档\r\n        // https://webpack.js.org/api/compilation-hooks/#list-of-asset-processing-stages\r\n        stage: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE\r\n      }, (compilationAssets, callback) => {\r\n        // compilationAssets 将得到所有生成的资源，如各个 chunk.js、各个 image、css\r\n\r\n        // 获取 webpac.output.publicPath 选项，(PS: publicPath 选项有可能是通过函数设置)\r\n        const publicPath = getPublicPath(compilation)\r\n\r\n        // 本示例仅仅考虑单个 entryPoint 的情况\r\n        // compilation.entrypoints 可获取入口文件信息\r\n        const entryNames = Array.from(compilation.entrypoints.keys())\r\n\r\n        // entryPoint.getFiles() 将获取到该入口的所有资源，并能够保证加载顺序！！！如 runtime-chunk -> main-chunk\r\n        const assets = entryNames.map(entryName => compilation.entrypoints.get(entryName).getFiles()).flat()\r\n        const scripts = assets.map(src => publicPath + src)\r\n        const content = html({ title: this.options.title || 'Demo', scripts })\r\n\r\n        // emitAsset 用以生成资源文件，也是最重要的一步\r\n        compilation.emitAsset('index.html', new webpack.sources.RawSource(content))\r\n        callback()\r\n      })\r\n    })\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs49GpC6",
    "number": 736,
    "title": "【Q711】打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44KbBr",
          "body": "在前端中，网页只能加载 `javascript` 脚本资源，即便在 node，也只能加载 `javascript` 与 `json` 资源。那类似 `webpack`、`rollup` 及 `vite` 这类工具是如何加载图片、JSON 资源的呢？\r\n\r\n在 `webpack` 等打包工具中，号称**一切皆是模块**。\r\n\r\n![一切皆是模块](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/webpack.1bgkaa8r9d7k.png)\r\n\r\n当 `webpack` 在这类打包器中，需要加载 JSON 等非 Javascript 资源时，则通过**模块加载器(`loader`)**将它们转化为模块的形式。\r\n\r\n## 加载 JSON\r\n\r\n以 JSON 为例:\r\n\r\n``` js\r\n// user.json 中内容\r\n{\r\n  \"id\": 10086,\r\n  \"name\": \"shanyue\",\r\n  \"github\": \"https://github.com/shfshanyue\"\r\n}\r\n```\r\n\r\n在现代前端中，我们把它视为 `module` 时，使用 `import` 引入资源。\r\n\r\n``` js\r\nimport user from './user.json'\r\n```\r\n\r\n而我们的打包器，如 `webpack` 与 `rollup`，将通过以下方式来加载 JSON 资源。\r\n\r\n这样它将被视为普通的 Javascript \r\n\r\n``` js\r\n// 实际上的 user.json 被编译为以下内容\r\nexport default {\r\n  \"id\": 10086,\r\n  \"name\": \"shanyue\",\r\n  \"github\": \"https://github.com/shfshanyue\"\r\n}\r\n```\r\n\r\n在 webpack 中通过 loader 处理此类非 JS 资源，以下为一个 `json-loader` 的示例:\r\n\r\n> [mini-code:json-loader](https://github.com/shfshanyue/mini-code/tree/master/code/json-loader) 中可见最小实现及示例。\r\n\r\n``` js\r\nmodule.exports = function (source) {\r\n  const json = typeof source === 'string' ? source : JSON.stringify(source)\r\n  return `module.exports = ${json}`\r\n}\r\n```\r\n\r\n## 加载图片\r\n\r\n那图片是如何处理的呢？\r\n\r\n更简单，它将替换为它自身的路径。示例如下\r\n\r\n``` js\r\nexport default `$PUBLIC_URL/assets/image/main.png` \r\n```\r\n\r\n而我们在 `import image` 时，其实是图片的自身路径，将它置于 `src` 属性即可\r\n\r\n``` js\r\nimport mainImage from 'main.png'\r\n\r\n<img src={mainImage} />\r\n```\r\n\r\n那如何加载一个 CSS 脚本呢？此处涉及到各种 DOM API，以及如何将它抽成一个 `.css` 文件，复杂很多，下一篇介绍。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs49ahqr",
    "number": 737,
    "title": "【Q712】打包器(webpack/rollup) 如何加载 style 样式资源",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45tW4T",
          "body": "style-loader的原理是，创建一个style标签，并且把样式资源写到这个style的innerHTML中",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "okbug",
            "url": "https://github.com/okbug"
          }
        },
        {
          "id": "IC_kwDODQzyOs460dV4",
          "body": "在打包器，比如 webpack 中，需要借用 `loader` 将非 JS 资源转化成可识别为 Javascript 的 module。\r\n\r\n## 现状\r\n\r\n在 webpack 中，处理 css 稍微比较费劲，需要借用两个 loader 来做成这件事情:\r\n\r\n``` js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader']\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n1. [css-loader](https://github.com/webpack-contrib/css-loader): 处理 CSS 中的 `url` 与 `@import`，并将其视为模块引入，此处是通过 postcss 来解析处理，postcss 对于工程化中 css  处理的影响力可见一斑。\r\n1. [style-loader](https://github.com/webpack-contrib/style-loader): 将样式注入到 DOM 中\r\n\r\n``` css\r\n@import url(./basic.css);\r\n\r\n.bg {\r\n  background: url(./shanyue.png);\r\n}\r\n```\r\n\r\n## 原理\r\n\r\n如果说现代前端中 Javascript 与 CSS 是其中最重要的两种资源，那么 `Babel` 与 `PostCSS` 就是前端工程化中最有影响力的两个编译器。\r\n\r\n`css-loader` 的原理就是 postcss，借用 `postcss-value-parser` 解析 CSS 为 AST，并将 CSS 中的 `url()` 与 `@import` 解析为模块。\r\n\r\n`style-loader` 用以将 CSS 注入到 DOM 中，原理为使用 DOM API 手动构建 `style` 标签，并将 CSS 内容注入到 `style` 中。\r\n\r\n在其源码实现中，借用了许多运行时代码 [style loader runtime](https://github.com/webpack-contrib/style-loader/tree/master/src/runtime)，而最简单的实现仅仅需要几行代码:\r\n\r\n``` js\r\nmodule.exports = function(source) {\r\n  return `\r\nfunction injectCss(css) {\r\n  const style = document.createElement('style')\r\n  style.appendChild(document.createTextNode(css))\r\n  document.head.appendChild(style)\r\n}\r\n\r\ninjectCss(\\`${source}\\`)\r\n  `\r\n}\r\n```\r\n\r\n使用 DOM API 加载 CSS 资源，由于 CSS 需要在 JS 资源加载完后通过 DOM API 控制加载，容易出现页面抖动，在线上低效且性能低下。且对于 SSR 极度不友好。\r\n\r\n由于性能需要，在线上通常需要单独加载 CSS 资源，这要求打包器能够将 CSS 打包，此时需要借助于 [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin) 将 CSS 单独抽离出来。\r\n\r\n深入 webpack 中如何抽离 CSS 的源码有助于加深对 webpack 的理解。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs468LlS",
          "body": "学习学习",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiutian00",
            "url": "https://github.com/qiutian00"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs49iWc3",
    "number": 738,
    "title": "【Q713】如何提升 webpack 构建资源的速度",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44isNG",
          "body": "使用 [speed-measure-webpack-plugin](https://github.com/stephencookdev/speed-measure-webpack-plugin) 可评估每个 loader/plugin 的执行耗时。\r\n\r\n## 更快的 loader: swc\r\n\r\n在 `webpack` 中耗时最久的当属负责 AST 转换的 loader。\r\n\r\n当 loader 进行编译时的 AST 操作均为 CPU 密集型任务，使用 Javascript 性能低下，此时可采用高性能语言 rust  编写的  `swc`。\r\n\r\n比如 Javascript 转化由 `babel` 转化为更快的 [swc](https://swc.rs/)。\r\n\r\n``` js\r\nmodule: {\r\n  rules: [\r\n    {\r\n      test: /\\.m?js$/,\r\n      exclude: /(node_modules)/,\r\n      use: {\r\n        loader: \"swc-loader\"\r\n      }\r\n    }\r\n  ];\r\n}\r\n```\r\n\r\n## 持久化缓存: cache\r\n\r\n`webpack5` 内置了关于缓存的插件，可通过 [cache 字段](https://webpack.js.org/configuration/cache/)配置开启。\r\n\r\n它将 `Module`、`Chunk`、`ModuleChunk` 等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大提升。\r\n\r\n``` js\r\n{\r\n  cache: {\r\n    type: 'filesystem'\r\n  }\r\n}\r\n```\r\n\r\n如对一个 JS 文件配置了 `eslint`、`typescript`、`babel` 等 `loader`，他将有可能执行五次编译，被五次解析为 AST\r\n\r\n1. `acorn`: 用以依赖分析，解析为 `acorn` 的 AST\r\n2. `eslint-parser`: 用以 lint，解析为 `espree` 的 AST\r\n3. `typescript`: 用以 ts，解析为 `typescript` 的 AST\r\n4. `babel`: 用以转化为低版本，解析为 `@babel/parser` 的 AST\r\n5. `terser`: 用以压缩混淆，解析为 `acorn` 的 AST\r\n\r\n而当开启了持久化缓存功能，最耗时的 AST 解析将能够从磁盘的缓存中获取，再次编译时无需再次进行解析 AST。\r\n\r\n**得益于持久化缓存，二次编译甚至可得到与 Unbundle 的 vite 等相近的开发体验**\r\n\r\n在 webpack4 中，可使用 [cache-loader](https://github.com/webpack-contrib/cache-loader) 仅仅对 `loader` 进行缓存。需要注意的是该 loader 目前已是 `@deprecated` 状态。\r\n\r\n``` js\r\nmodule.exports = {\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.ext$/,\r\n        use: ['cache-loader', ...loaders],\r\n        include: path.resolve('src'),\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n![cache-loader](https://cdn.jsdelivr.net/gh/shfshanyue/assets@master/src/cache-loader.7hlpm1nh2z40.png)\r\n\r\n## 多进程: thread-loader\r\n\r\n[thread-loader](https://github.com/webpack-contrib/thread-loader) 为官方推荐的开启多进程的 `loader`，可对 babel 解析 AST 时开启多线程处理，提升编译的性能。\r\n\r\n``` js\r\nmodule.exports={\r\n  module:{\r\n    rules:[\r\n      {\r\n        test:/\\.js$/,\r\n        use:[\r\n          {\r\n            loader: 'thread-loader',\r\n            options: {\r\n              workers: 8\r\n            }\r\n          },\r\n          'babel-loader'\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n在 `webpack4` 中，可使用 [happypack plugin](https://github.com/amireh/happypack)，但需要注意的是 `happypack` 已经久不维护了。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs49wP7g",
    "number": 739,
    "title": "【Q714】如何处理白屏错误页的监控的？",
    "body": "用户反馈白屏了，你怎么处理？",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs48v_HS",
          "body": "1. 排查兼容性。大部分原因是因为低端机型/浏览器低版本 polyfill的问题导致报错\r\n2. 排查网络。js是否下载成功 cdn是否生效\r\n3. 做js错误上报。分析是否存在代码缺陷\r\n4. 做重试逻辑/诱导用户重试\r\n5. Error Boundry避免整页崩溃。限制在组件级别",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "akbchris",
            "url": "https://github.com/akbchris"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs491CIg",
    "number": 740,
    "title": "【Q715】简述 npm script 的生命周期",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs44yw-G",
          "body": "在 npm 中，使用 `npm scripts` 可以组织整个前端工程的工具链。\r\n\r\n``` js\r\n{\r\n  start: 'serve ./dist',\r\n  build: 'webpack',\r\n  lint: 'eslint'\r\n}\r\n```\r\n\r\n除了可自定义 `npm script` 外，npm 附带许多内置 scripts，他们无需带 `npm run`，可直接通过 `npm <script>` 执行\r\n\r\n``` bash\r\n$ npm install\r\n$ npm test\r\n$ npm publish\r\n```\r\n\r\n我们在实际工作中会遇到以下几个问题：\r\n\r\n1. 在某个 npm 库安装结束后，自动执行操作如何处理？\r\n1. npm publish 发布 npm 库时将发布打包后文件，如果遗漏了打包过程如何处理，如何在发布前自动打包？\r\n\r\n这就要涉及到一个 npm script 的生命周期\r\n\r\n## 一个 npm script 的生命周期\r\n\r\n当我们执行任意 `npm run` 脚本时，将自动触发 `pre`/`post` 的生命周期。\r\n\r\n当手动执行 `npm run abc` 时，将在此之前自动执行 `npm run preabc`，在此之后自动执行 `npm run postabc`。\r\n\r\n``` js\r\n// 自动执行\r\nnpm run preabc\r\n\r\nnpm run abc\r\n\r\n// 自动执行\r\nnpm run postabc\r\n```\r\n\r\n[patch-package](https://github.com/ds300/patch-package) 一般会放到 `postinstall` 中。\r\n\r\n``` js\r\n{\r\n  postinstall: 'patch-package'\r\n}\r\n```\r\n\r\n而发包的生命周期更为复杂，当执行 `npm publish`，将自动执行以下脚本。\r\n\r\n+ **prepublishOnly**: 最重要的一个生命周期。\r\n+ prepack\r\n+ prepare\r\n+ postpack\r\n+ publish\r\n+ postpublish\r\n\r\n当然你无需完全记住所有的生命周期，如果你需要在发包之前自动做一些事情，如测试、构建等，请在 `prepulishOnly` 中完成。\r\n\r\n``` js\r\n{\r\n  prepublishOnly: 'npm run test && npm run build'\r\n}\r\n```\r\n\r\n## 一个最常用的生命周期\r\n\r\n`prepare`\r\n\r\n1. `npm install` 之后自动执行\r\n1. `npm publish` 之前自动执行\r\n\r\n比如 `husky`\r\n\r\n``` js\r\n{\r\n  prepare: 'husky install'\r\n}\r\n```\r\n\r\n## npm script 钩子的风险\r\n\r\n假设某一个第三方库的 `npm postinstall`  为 `rm -rf /`，那岂不是又很大的风险?\r\n\r\n``` js\r\n{\r\n  postinstall: 'rm -rf /'\r\n}\r\n```\r\n\r\n实际上，确实有很多 npm package 被攻击后，就是通过 `npm postinstall` 自动执行一些事，比如挖矿等。\r\n\r\n如果 npm 可以限制某些库的某些 hooks 执行，则可以解决这个问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-GQfp",
    "number": 741,
    "title": "【Q716】git hooks 原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45C5wA",
          "body": "`git` 允许在各种操作之前添加一些 `hook` 脚本，如未正常运行则 git 操作不通过。最出名的还是以下两个\r\n\r\n+ `precommit`\r\n+ `prepush`\r\n\r\n而 `hook` 脚本置于目录 `~/.git/hooks` 中，以可执行文件的形式存在。\r\n\r\n\r\n``` bash\r\n$ ls -lah .git/hooks\r\napplypatch-msg.sample     pre-merge-commit.sample\r\ncommit-msg.sample         pre-push.sample\r\nfsmonitor-watchman.sample pre-rebase.sample\r\npost-update.sample        pre-receive.sample\r\npre-applypatch.sample     prepare-commit-msg.sample\r\npre-commit.sample         update.sample\r\n```\r\n\r\n\r\n另外  git hooks 可使用 `core.hooksPath` 自定义脚本位置。\r\n\r\n``` bash\r\n# 可通过命令行配置 core.hooksPath\r\n$ git config 'core.hooksPath' .husky\r\n\r\n# 也可通过写入文件配置 core.hooksPath\r\n$ cat .git/config\r\n[core]\r\n  ignorecase = true\r\n  precomposeunicode = true\r\n  hooksPath = .husky\r\n```\r\n\r\n在前端工程化中，`husky` 即通过自定义 `core.hooksPath` 并将 `npm scripts` 写入其中的方式来实现此功能。\r\n\r\n`~/.husky` 目录下**手动创建 hook 脚本**。\r\n\r\n``` bash\r\n# 手动创建 pre-commit hook\r\n$ vim .husky/pre-commit\r\n```\r\n\r\n在 `pre-commit` 中进行代码风格校验\r\n\r\n``` bash\r\n#!/bin/sh\r\n\r\nnpm run lint\r\nnpm run test\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs45c0qI",
          "body": "https://www.jb51.net/article/180357.htm",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-L8Rl",
    "number": 742,
    "title": "【Q717】如何检测出你们安装的依赖是否安全",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45Lqiz",
          "body": "如何确保所有 `npm install` 的依赖都是安全的？\r\n\r\n当有一个库偷偷在你的笔记本后台挖矿怎么办？\r\n\r\n比如，不久前一个周下载量超过八百万的库被侵入，它在你的笔记本运行时会偷偷挖矿。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-0833.d9da75.webp)\r\n\r\n## Audit\r\n\r\n`Audit`，审计，检测你的所有依赖是否安全。`npm audit`/`yarn audit` 均有效。\r\n\r\n通过审计，可看出有风险的 `package`、依赖库的依赖链、风险原因及其解决方案。\r\n\r\n``` bash\r\n$ npm audit\r\n┌───────────────┬──────────────────────────────────────────────────────────────┐\r\n│ high          │ Regular Expression Denial of Service in trim                 │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Package       │ trim                                                         │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Patched in    │ >=0.0.3                                                      │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Dependency of │ @mdx-js/loader                                               │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ Path          │ @mdx-js/loader > @mdx-js/mdx > remark-mdx > remark-parse >   │\r\n│               │ trim                                                         │\r\n├───────────────┼──────────────────────────────────────────────────────────────┤\r\n│ More info     │ https://www.npmjs.com/advisories/1002775                     │\r\n└───────────────┴──────────────────────────────────────────────────────────────┘\r\n76 vulnerabilities found - Packages audited: 1076\r\nSeverity: 49 Moderate | 27 High\r\n✨  Done in 4.60s.\r\n```\r\n\r\n你可以在我的笔记本上挖矿，但绝不能在生产环境服务器下挖矿，此时可使用以下两条命令。\r\n\r\n``` bash\r\n$ npm audit production\r\n\r\n$ yarn audit dependencies\r\n```\r\n\r\n![Audit](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-1904.f4c916.webp)\r\n\r\n通过 `npm audit fix` 可以自动修复该库的风险，原理就是升级依赖库，升级至已修复了风险的版本号。\r\n\r\n``` bash\r\n$ npm audit fix\r\n```\r\n\r\n`yarn audit` 无法自动修复，需要使用 `yarn upgrade` 手动更新版本号，不够智能。\r\n\r\n[synk](https://snyk.io/) 是一个高级版的 `npm audit`，可自动修复，且支持 CICD 集成与多种语言。\r\n\r\n\r\n``` bash\r\n$ npx snyk\r\n\r\n$ npx wizard\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-1409.96de76.webp)\r\n\r\n## CI 机器人\r\n\r\n可通过 CI/gitlab/github 中配置机器人，使他们每天轮询一次检查仓库的依赖中是否有风险。\r\n\r\n![Github 机器人](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-4186.0dac46.webp)\r\n\r\n在 Github 中，可单独设置 `dependabot` 机器人，在仓库设置中开启小机器人，当它检测到有问题时，会自动向该仓库提交 PR。\r\n\r\n![dependabot](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-6581.08f1c2.webp)\r\n\r\n而它的解决方案也是升级版本号。\r\n\r\n![Github Bot 提的 PR](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-03/clipboard-8617.e80863.webp)\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-UtTS",
    "number": 744,
    "title": "【Q718】请简述下 eslint 的作用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45UwzW",
          "body": "`eslint`，对代码不仅有风格的校验，更有可读性、安全性、健壮性的校验。\r\n\r\n关于校验分号、冒号等，属于风格校验，与个人风格有关，遵循团队标准即可，可商量可妥协。\r\n\r\n``` js\r\n// 这属于风格校验\r\n{\r\n  semi: ['error', 'never']\r\n}\r\n```\r\n\r\n与 `prettier` 不同，`eslint` 更多是关于代码健壮性校验，试举一例。\r\n\r\n+ `Array.prototype.forEach` 不要求也**不推荐回调函数返回值**\r\n+ `Array.prototype.map` 回调函数**必须返回一个新的值**用以映射\r\n\r\n当代码不遵守此两条要求时，通过 `eslint` 以下规则校验，则会报错。此种校验与代码健壮有关，不可商量不可妥协。\r\n\r\n``` js\r\n// 这属于代码健壮性校验\r\n{\r\n  'array-callback-return': ['error', { checkForEach: true }]\r\n}\r\n```\r\n\r\n## Rule\r\n\r\n在 `eslint` 中，使用 `Rule` 最为校验代码最小规则单元。\r\n\r\n``` js\r\n{\r\n  rules: {\r\n    semi: ['error', 'never']\r\n    quotes: ['error', 'single', { avoidEscape: true }]\r\n  }\r\n}\r\n```\r\n\r\n在 `eslint` 自身，内置大量 `rules`，比如分号冒号逗号等配置。\r\n\r\n> [eslint rules 源码位置](https://github.com/eslint/eslint/tree/main/lib/rules)\r\n\r\n校验 `typescript`、`react` 等规则，自然不会由 `eslint` 官方提供，那这些 Rules 如何维护？\r\n\r\n## Plugin\r\n\r\n如 `react`、`typescript`、`flow` 等，需要自制 `Rule`，此类为 `Plugin`，他们维护了一系列 `Rules`。\r\n\r\n在命名时以 `eslint-plugin-` 开头并发布在 `npm` 仓库中，而执行的规则以 `react/`、`flow/` 等开头。\r\n\r\n``` js\r\n{\r\n  'react/no-multi-comp': [error, { ignoreStateless: true }]\r\n}\r\n```\r\n\r\n+ [React ESLint Rules](https://www.npmjs.com/package/eslint-plugin-react)\r\n+ [TypeScript ESLint Rules](https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin/src/rules)\r\n\r\n## Config\r\n\r\n在第三方库、公司业务项目中需要配置各种适应自身的规则、插件等，称为 `Config`。\r\n\r\n1. 作为库发布，在命名时以 `elint-config-` 开头，并发布在 `npm` 仓库中。\r\n1. 为项目服务，在项目中以 `.eslintrc` 命名或者置于项目 package.json 中的 `eslintConfig` 字段中，推荐第二种方案。\r\n\r\n+ [eslint-config-react-app](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)\r\n+ [eslint-config-airbnb](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb)\r\n\r\n以下是 `eslint-config-airbnb` 的最外层配置。\r\n\r\n``` js\r\nmodule.exports = {\r\n  extends: [\r\n    'eslint-config-airbnb-base',\r\n    './rules/react',\r\n    './rules/react-a11y',\r\n  ].map(require.resolve),\r\n  rules: {}\r\n}\r\n```\r\n\r\n在我们公司实际项目中，无需重新造轮子，只需要配置文件中的 `extends` 继承那些优秀的 `eslint-config` 即可。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-k0ws",
    "number": 745,
    "title": "【Q719】在项目中，如何平滑升级 npm 包",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45hwQZ",
          "body": "# 如何对 npm 包进行升级\r\n\r\nnpm 的版本号为 `semver` 规范，由 [major, minor, patch] 三部分组成，其中\r\n\r\n+ major: 当你发了一个含有 Breaking Change 的 API\r\n+ minor: 当你新增了一个向后兼容的功能时\r\n+ patch: 当你修复了一个向后兼容的 Bug 时\r\n\r\n假设 `react` 当前版本号为 `17.0.1`，我们要升级到 `17.0.2` 应该如何操作？\r\n\r\n``` diff\r\n- \"react\": \"17.0.1\",\r\n+ \"react\": \"17.0.2\",\r\n```\r\n\r\n## 自动发现更新\r\n\r\n升级版本号，最不建议的事情就是手动在 package.json 中进行修改。\r\n\r\n``` diff\r\n- \"react\": \"17.0.1\",\r\n+ \"react\": \"17.0.2\",\r\n```\r\n\r\n**毕竟，你无法手动发现所有需要更新的 package。**\r\n\r\n此时可借助于 `npm outdated`，发现有待更新的 package。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-10/clipboard-6918.0c6824.webp)\r\n\r\n使用 `npm outdated`，还可以列出其待更新 package 的文档。\r\n\r\n``` bash\r\n$ npm outdated -l\r\nPackage                 Current    Wanted    Latest  Location                            Depended by  Package Type     Homepage\r\n@next/bundle-analyzer    10.2.0    10.2.3    12.0.3  node_modules/@next/bundle-analyzer  app          dependencies     https://github.com/vercel/next.js#readme\r\n```\r\n\r\n## 自动更新版本号\r\n\r\n使用 `npm outdated` 虽能发现需要升级版本号的 package，但仍然需要手动在 package.json 更改版本号进行升级。\r\n\r\n此时推荐一个功能更强大的工具 `npm-check-updates`，比 `npm outdated` 强大百倍。\r\n\r\n`npm-check-updates -u`，可自动将 package.json 中待更新版本号进行重写。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-10/clipboard-3561.1b70dc.webp)\r\n\r\n升级 [minor] 小版本号，有可能引起 `Break Change`，可仅仅升级到最新的 patch 版本。\r\n\r\n``` bash\r\n$ npx npm-check-updates --target patch\r\n```\r\n\r\n## 一点小建议\r\n\r\n1. 当一个库的 major 版本号更新后，不要第一时间去更新，容易踩坑，可再度过几个 patch 版本号再更新尝试新功能\r\n1. 当遇到 major 版本号更新时，多看文档中的 ChangeLog，多看升级指导并多测试及审计",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-xZ_F",
    "number": 746,
    "title": "【Q720】请描述 node_modules 的目录结构(拓扑结构)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs45uXyW",
          "body": "> 以下 mermaid 无法渲染，可移至 <https://juejin.cn/post/7030084290989948935>\r\n\r\n\r\n## 基础\r\n\r\n当 `require('package-hello')` 时，假设 `package-hello` 是一个 npm 库，我们是如何找到该 `package` 的？\r\n\r\n1. 寻找当前目录的 `node_modules/package-hello` 目录\r\n1. 如果未找到，寻找上一级的 `../node_modules/package-hello` 目录，以此递归查找\r\n\r\n## 很久以前: 嵌套结构\r\n\r\n在 `npmv2` 时，`node_modules` 对于各个 package 的拓扑为嵌套结构。\r\n\r\n假设: \r\n\r\n1. 项目依赖 `package-a` 与 `package-b` 两个 package\r\n1. `package-a` 与 `package-b` 均依赖 `lodash@4.17.4`\r\n\r\n依赖关系以 Markdown 列表表示:\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@4.17.4`\r\n+ package-b\r\n  + `lodash@4.17.4`\r\n```\r\n\r\n此时 `node_modules` 目录结构如下: \r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  A            ---> C(\"lodash@4.17.4\")\r\n  B            ---> D(\"lodash@4.17.4\")\r\n```\r\n\r\n此时最大的问题\r\n\r\n1. 嵌套过深\r\n2. 占用空间过大\r\n\r\n## 现在阶段: 平铺结构\r\n\r\n> 目前在 npm/yarn 中仍然为平铺结构，但 pnpm 使用了更省空间的方法，以后将会提到\r\n\r\n在 `npmv3` 之后 `node_modules` 为平铺结构，拓扑结构如下:\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n```\r\n\r\n### *一个问题: 以下依赖最终 node_modules 结果如何？*\r\n\r\n> 可参考[该示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/topology)\r\n\r\n依赖关系以 Markdown 列表表示\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@^4.17.4`\r\n+ package-b\r\n  + `lodash@^4.16.1`\r\n```\r\n\r\n答: 与上拓扑结构一致，因为二者为 `^` 版本号，他们均会下载匹配该版本号范围的最新版本，比如 `@4.17.4`，因此二者依赖一致。\r\n\r\n> 此时如果有 lock，会有一点小问题，待稍后讨论\r\n\r\nnode_modules 目录结构如下图：\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n```\r\n\r\n### *再一个问题: 以下依赖最终 node_modules 结果如何？*\r\n\r\n> 可参考[该示例](https://github.com/shfshanyue/node-examples/tree/master/engineering/package/topology-dup)\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@4.17.4`\r\n+ package-b\r\n  + `lodash@4.16.1`\r\n```\r\n\r\n答：package-b 先从自身 node_modules 下寻找 `lodash`，找到 `lodash@4.16.1`\r\n\r\nnode_modules 目录结构如下图：\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(\"lodash@4.17.4\")\r\n  B            ---> D(\"lodash@4.16.1\")\r\n```\r\n\r\n### *再一个问题: 以下依赖最终 node_modules 结果如何*\r\n\r\n``` markdown\r\n+ package-a\r\n  + `lodash@4.0.0`\r\n+ package-b\r\n  + `lodash@4.0.0`\r\n+ package-c\r\n  + `lodash@3.0.0`\r\n+ package-d\r\n  + `lodash@3.0.0`\r\n```\r\n\r\n答：package-d 只能从自身的 node_modules 下寻找 `lodash@3.0.0`，而无法从 package-c 下寻找，此时 **lodash@3.0.0 不可避免地会被安装两次**\r\n\r\nnode_modules 目录结构如下图:\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(package-c)\r\n  app          ---> D(package-d)\r\n  app          ---> X(\"lodash@4.0.0\")\r\n  C            ---> Y(\"lodash@3.0.0\")\r\n  D            ---> Z(\"lodash@3.0.0\")\r\n```\r\n\r\n\r\n## 重复的版本依赖有什么问题？\r\n\r\n可参考 [npm doppelgangers](https://rushjs.io/pages/advanced/npm_doppelgangers/)\r\n\r\n1. Install Size，安装体积变大，浪费磁盘空间\r\n1. Build Size，构建打包体积变大，浪费带宽，网站打开延迟，破坏用户体验 (PS: 支持 Tree Shaking 会好点)\r\n1. 破坏单例模式，破坏缓存，如 postcss 的许多插件将 postcss 扔进 dependencies，重复的版本将导致解析 AST 多次\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-3kDL",
    "number": 747,
    "title": "【Q721】npm 第三方库需要提交 lockfile 吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4505c4",
          "body": "## 为何有人说第三方库不需要提交 package-lock.json/yarn.lock？\r\n\r\n> 该观点仅对第三方库的 `dependencies` 有效\r\n\r\n答: 你自己项目中所有依赖都会根据 lockfile 被锁死，**但并不会依照你第三方依赖的 lockfile**。\r\n\r\n试举一例:\r\n\r\n1. 项目中依赖 `react@^17.0.2`\r\n2. 而 `react@17.0.2` 依赖 `object-assign@^4.1.0`\r\n\r\n在 React 自身的 `yarn.lock` 中版本锁定依赖如下:\r\n\r\n``` bash\r\nreact@17.0.2\r\n└── object-assign@4.1.0 (PS: 请注意该版本号)\r\n```\r\n\r\n而在个人业务项目中 `yarn.lock` 中版本锁定依赖如下:\r\n\r\n``` bash\r\nApplication\r\n└── react@17.0.2\r\n    └── object-assign@4.99.99 (PS: 请注意该版本号)\r\n```\r\n\r\n**此时个人业务项目中 `object-assign@4.99.99` 与 React 中 `object-assign@4.1.0` 不符，将有可能出现问题**。\r\n\r\n此时，即使第三方库存在 `lockfile`，但也有着间接依赖(如此时的 `object-assign`，是第三方的依赖，个人业务项目中的依赖的依赖)不可控的问题。\r\n\r\n## 第三方库如何解决潜在的间接依赖不可控问题\r\n\r\n可参考 `next.js` 的解决方案。\r\n\r\n> [next.js 源码](https://github.com/vercel/next.js/tree/canary/packages/next) 点击此处\r\n\r\n1. 将所有依赖中的版本号在 `package.json` 中锁死。可见 [package.json](https://github.com/vercel/next.js/tree/canary/packages/next/package.json)\r\n1. 将部分依赖直接编译后直接引入，而非通过依赖的方式，如 `webpack`、`babel` 等。可见目录 [next/compiled](https://github.com/vercel/next.js/tree/canary/packages/next/compiled)\r\n\r\n以下是一部分 `package.json`\r\n\r\n``` js\r\n{\r\n  \"dependencies\": {\r\n    \"@babel/runtime\": \"7.15.4\",\r\n    \"@hapi/accept\": \"5.0.2\",\r\n    \"@napi-rs/triples\": \"1.0.3\"\r\n  }\r\n}\r\n```\r\n\r\n除了参考 `next.js` 直接锁死版本号方式外，还可以仍然按照 `^x.x.x` 加勤加维护并时时更新 `depencencies`\r\n\r\n## 总结\r\n\r\n`lockfile` 对于第三方库仍然必不可少。可见 `react`、`next.js`、`webpack` 均有 `yarn.lock`。(PS: 可见 yarn 的受欢迎程度，另外 vue3 采用了 pnpm)\r\n\r\n1. 第三方库的 `devDependencies` 必须在 lockfile 中锁定，这样 Contributor 可根据 lockfile 很容易将项目跑起来。\r\n2. 第三方库的 `dependencies` 虽然有可能存在不可控问题，但是可通过锁死 `package.json` 依赖或者勤加更新的方式来解决。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs47MS2c",
          "body": "对于业务开发者而言第三方库是否锁死自己无法决定吗？ 需要库的开发者自觉处理，请问大佬是这样吗",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1gehunzi",
            "url": "https://github.com/1gehunzi"
          }
        },
        {
          "id": "IC_kwDODQzyOs47MXpw",
          "body": "@xiyuanyuan 不对，恰好相反。我们是对于间接依赖而言的，在业务方可以锁死，但是库的开发者无法决定他们的依赖在我们业务方的锁死版本号",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4-7nRx",
    "number": 748,
    "title": "【Q722】请问什么是 CICD",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46Cn1u",
          "body": "\r\n+ `CI`，Continuous Integration，持续集成。\r\n+ `CD`，Continuous Deployment，持续部署。\r\n\r\n`CICD` 一般合称，无需特意区分二者区别。从开发、测试到上线的过程中，借助于 CICD 进行一些自动化处理，保障项目质量。\r\n\r\n`CICD` 与 git 集成在一起，可理解为服务器端的 `git hooks`: 当代码 push 到远程仓库后，借助 `WebHooks` 对当前代码在构建服务器(即 CI 服务器，也称作 Runner)中进行自动构建、测试及部署等。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-17/clipboard-6509.1b9b98.webp)\r\n\r\n它有若干好处:\r\n\r\n1. 功能分支提交后，通过 CICD 进行自动化测试、语法检查等，**如未通过 CICD，则无法 CodeReview，更无法合并到生产环境分支进行上线**\r\n1. 功能分支提交后，通过 CICD 检查 npm 库的风险、检查构建镜像容器的风险等\r\n1. 功能分支提交后，通过 CICD 对当前分支代码构建独立镜像并生成独立的分支环境地址进行测试，**如对每一个功能分支生成一个可供测试的地址，一般是 `<branch>.dev.shanyue.tech` 此种地址**\r\n1. 功能分支测试通过后，合并到主分支，自动构建镜像并部署到生成环境 (一般生成环境需要手动触发、自动部署)\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-17/pr-checks-final.26fba2.webp)\r\n\r\n由于近些年来 CICD 的全面介入，项目开发的工作流就是 CICD 的工作流，请看一个比较完善的 CICD Workflow。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-17/clipboard-7669.a41a94.webp)\r\n\r\n## CICD 工具\r\n\r\n`CICD` 集成于 CICD 工具及代码托管服务。CICD 有时也可理解为进行 CICD 的构建服务器，而提供 CICD 的服务，如以下产品，将会提供构建服务与 github/gitlab 集成在一起。\r\n\r\n+ `jenkins`\r\n+ `Travis CI`\r\n\r\n如果你们公司没有 CICD 基础设置，那么你可以尝试 github 免费的 CICD 服务: [github actions](https://github.com/features/actions)。\r\n\r\n公司一般以 `gitlab CI` 作为 CICD 工具，此时需要自建 `gitlab Runner` 作为构建服务器。\r\n\r\n## 一段简单的 CICD 配置\r\n\r\n每一家 CICD 产品，都有各自的配置方式，但是总体上用法差不多。以下 CI 脚本指当在 master 有代码变更时，自动部署上线。\r\n\r\n```yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker build -t harbor.shanyue.tech/fe/devtools-app\r\n    - docker push harbor.shanyue.tech/fe/devtools-app\r\n    - helm upgrade -install devtools-app-chart .\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_EiZ8",
    "number": 749,
    "title": "【Q723】如何使用 docker 部署前端",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46CoJH",
          "body": "\r\n使用 `docker` 部署前端最大的好处是隔离环境，单独管理：\r\n\r\n1. 前端项目依赖于 Node v16，而宿主机无法满足依赖，使用容器满足需求\r\n1. 前端项目依赖于 npm v8，而宿主机无法满足依赖，使用容器满足需求\r\n1. 前端项目需要将 8080 端口暴露出来，而容易与宿主机其它服务冲突，使用容器与服务发现满足需求\r\n\r\n## 使用 docker 部署前端\r\n\r\n假设本地跑起一个前端项目，需要以下步骤，并最终可在 `localhost:8080` 访问服务。\r\n\r\n``` bash\r\n$ npm i\r\n$ npm run build\r\n$ npm start\r\n```\r\n\r\n**那在 docker 中部署前端，与在本地将如何将项目跑起来步骤大致一致**，一个 Dockerfile 如下\r\n\r\n``` dockerfile\r\n# 指定 node 版本号，满足宿主环境\r\nFROM node:16-alpine\r\n\r\n# 指定工作目录，将代码添加至此\r\nWORKDIR /code\r\nADD . /code\r\n\r\n# 如何将项目跑起来\r\nRUN npm install\r\nRUN npm run build\r\nCMD npm start\r\n\r\n# 暴露出运行的端口号，可对外接入服务发现\r\nEXPOSE 8080\r\n```\r\n\r\n此时，我们使用 `docker build` 构建镜像并把它跑起来。\r\n\r\n``` bash\r\n# 构建镜像\r\n$ docker build -t fe-app .\r\n\r\n# 运行容器\r\n$ docker run -it --rm fe-app\r\n```\r\n\r\n恭喜你，能够写出以上的 Dockerfile，这说明你对 Docker 已经有了理解。但其中还有若干问题，我们对其进行一波优化\r\n\r\n1. 使用 `node:16` 作为基础镜像过于奢侈，占用体积太大，而最终产物 (js/css/html) 无需依赖该镜像。可使用更小的 nginx 镜像做多阶段构建。\r\n1. 多个 RUN 命令，不利于 Docker 的镜像分层存储。*可合并为一个 RUN 命令*\r\n1. 每次都需要 `npm i`，可合理利用 Docker 缓存，ADD 命令中内容发生改变将会破坏缓存。可将 package.json 提前移至目标目录，只要 *package.json/lockfile* 不发生变动，将不会重新 `npm i`\r\n\r\n优化后 Dockerfile 如下:\r\n\r\n``` dockerfile\r\nFROM node:16-alpine as builder\r\n\r\nWORKDIR /code\r\n\r\nADD package.json package-lock.json /code/\r\nRUN npm install\r\n\r\nADD . /code\r\n\r\nRUN npm run build \r\n\r\n# 选择更小体积的基础镜像\r\nFROM nginx:alpine\r\n\r\n# 将构建产物移至 nginx 中\r\nCOPY --from=builder code/build/ /usr/share/nginx/html/\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_EyNR",
    "number": 750,
    "title": "【Q724】软链接和硬链接有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46u1oq",
          "body": "https://www.jianshu.com/p/dde6a01c4094\r\n\r\n这个解释满分",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Gentlemancj",
            "url": "https://github.com/Gentlemancj"
          }
        },
        {
          "id": "IC_kwDODQzyOs46xDkF",
          "body": "> https://www.jianshu.com/p/dde6a01c4094\r\n> \r\n> 这个解释满分\r\n\r\n链接挂了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "nmsn",
            "url": "https://github.com/nmsn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_H6i7",
    "number": 751,
    "title": "【Q725】pnpm 有什么优势",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46FuNe",
          "body": "## 软链接和硬链接\r\n\r\n假设我们有一个文件，称为 `hello`\r\n\r\n通过 `ln -s` 创建一个软链接，通过 `ln` 可以创建一个硬链接。\r\n\r\n``` bash\r\n$ ln -s hello hello-soft\r\n$ ln hello hello-hard\r\n\r\n$ ls -lh\r\ntotal 768\r\n45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello\r\n45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello-hard\r\n45463415 lrwxr-xr-x  1 xiange  staff     5B 11 19 19:40 hello-soft -> hello\r\n```\r\n\r\n他们的区别有以下几点:\r\n\r\n1. 软链接可理解为指向源文件的指针，它是单独的一个文件，仅仅只有几个字节，它拥有独立的 `inode`\r\n1. 硬链接与源文件同时指向一个物理地址，它与源文件共享存储数据，它俩拥有相同的 `inode`\r\n\r\n## pnpm 为何节省空间\r\n\r\n它解决了 npm/yarn 平铺 node_modules 带来的依赖项重复的问题 (doppelgangers)\r\n\r\n假设存在依赖依赖:\r\n\r\n``` bash\r\n.\r\n├── package-a\r\n│   └── lodash@4.0.0\r\n├── package-b\r\n│   └── lodash@4.0.0\r\n├── package-c\r\n│   └── lodash@3.0.0\r\n└── package-d\r\n    └── lodash@3.0.0\r\n```\r\n\r\n那么不可避免地在 npm 或者 yarn 中，`lodash@3.0.0` 会被多次安装，无疑造成了空间的浪费与诸多问题。\r\n\r\n``` bash\r\n./node_modules/lodash\r\n./node_modules/package-a\r\n./node_modules/package-b\r\n./node_modules/package-c\r\n./node_modules/package-c/node_mdoules/lodash\r\n./node_modules/package-d\r\n./node_modules/package-d/node_mdoules/lodash\r\n```\r\n\r\n``` mermaid\r\ngraph\r\n  app(node_modules) ---> A(package-a)\r\n  app          ---> B(package-b)\r\n  app          ---> C(package-c)\r\n  app          ---> D(package-d)\r\n  app          ---> X(\"lodash@4.0.0\")\r\n  C            ---> Y(\"lodash@3.0.0\")\r\n  D            ---> Z(\"lodash@3.0.0\")\r\n```\r\n\r\n这里有一个来自 [Rush](https://rushjs.io/images/home/card-doppel.svg) 的图可以很形象的说明问题。\r\n\r\n![](https://rushjs.io/images/home/card-doppel.svg)\r\n\r\n这是一个较为常见的场景，在平时项目中有些库相同版本甚至会安装七八次，如 `postcss`、`ansi-styles`、`ansi-regex`、`braces` 等，你们可以去你们的 `yarn.lock`/`package-lock.json` 中搜索一下。\r\n\r\n而在 pnpm 中，它改变了 npm/yarn 的目录结构，采用软链接的方式，避免了 `doppelgangers` 问题更加节省空间。\r\n\r\n它最终生成的 `node_modules` 如下所示，从中也可以看出它解决了幽灵依赖的问题。\r\n\r\n``` bash\r\n./node_modules/package-a       ->  .pnpm/package-a@1.0.0/node_modules/package-a\r\n./node_modules/package-b       ->  .pnpm/package-b@1.0.0/node_modules/package-b\r\n./node_modules/package-c       ->  .pnpm/package-c@1.0.0/node_modules/package-c\r\n./node_modules/package-d       ->  .pnpm/package-d@1.0.0/node_modules/package-d\r\n./node_modules/.pnpm/lodash@3.0.0\r\n./node_modules/.pnpm/lodash@4.0.0\r\n./node_modules/.pnpm/package-a@1.0.0\r\n./node_modules/.pnpm/package-a@1.0.0/node_modules/package-a\r\n./node_modules/.pnpm/package-a@1.0.0/node_modules/lodash     -> .pnpm/package-a@1.0.0/node_modules/lodash@4.0.0\r\n./node_modules/.pnpm/package-b@1.0.0\r\n./node_modules/.pnpm/package-b@1.0.0/node_modules/package-b\r\n./node_modules/.pnpm/package-b@1.0.0/node_modules/lodash     -> .pnpm/package-b@1.0.0/node_modules/lodash@4.0.0\r\n./node_modules/.pnpm/package-c@1.0.0\r\n./node_modules/.pnpm/package-c@1.0.0/node_modules/package-c\r\n./node_modules/.pnpm/package-c@1.0.0/node_modules/lodash     -> .pnpm/package-c@1.0.0/node_modules/lodash@3.0.0\r\n./node_modules/.pnpm/package-d@1.0.0\r\n./node_modules/.pnpm/package-d@1.0.0/node_modules/package-d\r\n./node_modules/.pnpm/package-d@1.0.0/node_modules/lodash     -> .pnpm/package-d@1.0.0/node_modules/lodash@3.0.0\r\n```\r\n\r\n如此，依赖*软链接*的方式，可解决重复依赖安装 (doppelgangers) 的问题，**如果一个项目占用 1000 MB，那么使用 pnpm 可能仅占用 800 MB**\r\n\r\n然而它除此之外，还有一个最大的好处，**如果一个项目占用 1000 MB，传统方式十个项目占用 10000 MB，那么使用 pnpm 可能仅占用 3000 MB**，而它得益于硬链接。\r\n\r\n再借用以上示例，`lodash@3.0.0` 与 `lodash@4.0.0` 会生成一个指向全局目录(`~/.pnpm-store`)的硬链接，如果新项目依赖二者，则可复用存储空间。\r\n\r\n``` bash\r\n./node_modules/.pnpm/lodash@3.0.0/node_modules/lodash   -> hardlink \r\n./node_modules/.pnpm/lodash@4.0.0/node_modules/lodash   -> hardlink\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_MIMG",
    "number": 752,
    "title": "【Q726】浏览器中如何使用原生的 ESM",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46JR42",
          "body": "# Native Import: Import from URL\r\n\r\n通过 `script[type=module]`，可直接在浏览器中使用原生 `ESM`。这也使得前端不打包 (`Bundless`) 成为可能。\r\n\r\n``` html\r\n<script type=\"module\">\r\n  import lodash from 'https://cdn.skypack.dev/lodash'\r\n</script>\r\n```\r\n\r\n由于前端跑在浏览器中，**因此它也只能从 URL 中引入 `Package`**\r\n\r\n1. 绝对路径: `https://cdn.sykpack.dev/lodash`\r\n1. 相对路径: `./lib.js`\r\n\r\n现在打开浏览器控制台，把以下代码粘贴在控制台中。由于 `http import` 的引入，你发现你调试 `lodash` 此列工具库更加方便了。\r\n\r\n``` js\r\n> lodash = await import('https://cdn.skypack.dev/lodash')\r\n\r\n> lodash.get({ a: 3 }, 'a')\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-22/clipboard-2865.638ba7.webp)\r\n\r\n## ImportMap\r\n\r\n但 `Http Import` 每次都需要输入完全的 URL，相对以前的裸导入 (`bare import specifiers`)，很不太方便，如下例:\r\n\r\n``` js\r\nimport lodash from 'lodash'\r\n```\r\n\r\n它不同于 `Node.JS` 可以依赖系统文件系统，层层寻找 `node_modules`\r\n\r\n``` bash\r\n/home/app/packages/project-a/node_modules/lodash/index.js\r\n/home/app/packages/node_modules/lodash/index.js\r\n/home/app/node_modules/lodash/index.js\r\n/home/node_modules/lodash/index.js\r\n```\r\n\r\n在 ESM 中，可通过 `importmap` 使得裸导入可正常工作:\r\n\r\n``` html\r\n<script type=\"importmap\">\r\n{\r\n  \"imports\": {\r\n    \"lodash\": \"https://cdn.skypack.dev/lodash\",\r\n    \"ms\": \"https://cdn.skypack.dev/ms\"\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n此时可与以前同样的方式进行模块导入\r\n\r\n``` js\r\nimport lodash from 'lodash'\r\n\r\nimport(\"lodash\").then(_ => ...)\r\n```\r\n\r\n那么通过裸导入如何导入子路径呢？\r\n\r\n``` html\r\n<script type=\"importmap\">\r\n{\r\n  \"imports\": {\r\n    \"lodash\": \"https://cdn.skypack.dev/lodash\",\r\n    \"lodash/\": \"https://cdn.skypack.dev/lodash/\"\r\n  }\r\n}\r\n</script>\r\n<script type=\"module\">\r\nimport get from 'lodash/get.js'\r\n</script>\r\n```\r\n\r\n## Import Assertion\r\n\r\n通过 `script[type=module]`，不仅可引入 Javascript 资源，甚至可以引入 JSON/CSS，示例如下\r\n\r\n``` html\r\n<script type=\"module\">\r\nimport data from './data.json' assert { type: 'json' }\r\n\r\nconsole.log(data)\r\n</script>\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs49jEF1",
          "body": "补充三点 \r\n\r\n1.module默认是defer的加载和执行方式\r\n\r\n2.这里会存在单独的module的域不会污染到全局\r\n\r\n3.直接是strict\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        },
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_U75j",
    "number": 753,
    "title": "【Q727】如何将 CommonJS 转化为 ESM",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46SYZ2",
          "body": "> 本篇文章/答案本计划是三四百字，没想到最后越写越多，写了一千字。\r\n\r\n由于 Bundless 构建工具的兴起，要求所有的模块都是 ESM 模块化格式。\r\n\r\n目前社区有一部分模块同时支持 ESM 与 CommonJS，但仍有许多模块仅支持 CommonJS/UMD，因此将 CommonJS 转化为 ESM 是全部模块 ESM 化的过渡阶段。\r\n\r\n## ESM 与 CommonJS 的导入导出的不同\r\n\r\n在 ESM 中，导入导出有两种方式:\r\n\r\n1. 具名导出/导入: `Named Import/Export`\r\n1. 默认导出/导入: `Default Import/Export`\r\n\r\n代码示例如下:\r\n\r\n``` js\r\n// Named export/import\r\nexport { sum }\r\nimport { sum } from 'sum'\r\n\r\n// Default export/import\r\nexport default sum\r\nimport sum from 'sum'\r\n```\r\n\r\n而在 CommonJS 中，导入导出的方法只有一种:\r\n\r\n``` js\r\nmodule.exports = sum\r\n```\r\n\r\n而所谓的 `exports` 仅仅是 `module.exports` 的引用而已\r\n\r\n``` js\r\n// 实际上的 exports\r\nexports = module.exports\r\n\r\n// 以下两个是等价的\r\nexports.a = 3\r\nmodule.exports.a = 3\r\n```\r\n\r\n> PS: 一道题关于 `exports` 与 `module.exports` 的区别，以下 `console.log` 输出什么\r\n> ``` js\r\n> // hello.js\r\n> exports.a = 3\r\n> module.exports.b = 4\r\n> \r\n> // index.js\r\n> const hello = require('./hello')\r\n> console.log(hello)\r\n> ```\r\n\r\n> 再来一道题:\r\n> ``` js\r\n> // hello.js\r\n> exports.a = 3\r\n> module.exports = { b: 4 }\r\n> \r\n> // index.js\r\n> const hello = require('./hello')\r\n> console.log(hello)\r\n> ```\r\n\r\n正因为有二者的不同，因此在二者转换的时候有一些兼容问题需要解决。\r\n\r\n## exports 的转化\r\n\r\n正因为，二者有所不同，当 exports 转化时，既要转化为 `export {}`，又要转化为 `export default {}`\r\n\r\n``` js\r\n// Input:  index.cjs\r\nexports.a = 3\r\n\r\n// Output: index.mjs\r\n// 此处既要转化为默认导出，又要转化为具名导出！\r\nexport const a = 3\r\nexport default { a }\r\n```\r\n\r\n如果仅仅转为 `export const a = 3` 的具名导出，而不转换 `export default { a }`，将会出现什么问题？以下为例:\r\n\r\n``` js\r\n// Input: CJS\r\nexports.a = 3                   // index.cjs\r\n\r\nconst o = require('.')          // foo.cjs\r\nconsole.log(o.a)                // foo.cjs\r\n\r\n// Output: ESM\r\n// 这是有问题的错误转换示例:\r\n// 此处 a 应该再 export default { a } 一次\r\nexport const a = 3                    // index.mjs\r\n\r\nimport o from '.'               // foo.mjs\r\nconsole.log(o.a)                // foo.mjs 这里有问题，这里有问题，这里有问题\r\n```\r\n\r\n## module.exports 的转化\r\n\r\n对于 `module.exports`，我们可以遍历其中的 key (通过 AST)，将 key 转化为 `Named Export`，将 `module.exports` 转化为 `Default Export`\r\n\r\n``` js\r\n// Input:  index.cjs\r\nmodule.exports = {\r\n  a: 3,\r\n  b: 4\r\n}\r\n\r\n// Output: index.mjs\r\n// 此处既要转化为默认导出，又要转化为具名导出！\r\nexport default {\r\n  a: 3,\r\n  b: 4\r\n}\r\nexport const a = 3\r\nexport const b = 4\r\n```\r\n\r\n如果 `module.exports` 导出的是函数如何处理呢，特别是 `exports` 与 `module.exports` 的程序逻辑混合在一起？\r\n\r\n以下是一个正确的转换结果：\r\n\r\n``` js\r\n// Input: index.cjs\r\nmodule.exports = () => {}\r\nexports.a = 3\r\nexports.b = 4\r\n\r\n// Output: index.mjs\r\nconst sum = () => {}\r\nsum.a = 3\r\nsum.b = 4\r\nexport const a = 3\r\nexport const b = 4\r\nexport default = sum\r\n```\r\n\r\n也可以这么处理，将 `module.exports` 与 `exports` 的代码使用函数包裹起来，此时我们无需关心其中的逻辑细节。\r\n\r\n``` js\r\nvar esm$1 = {exports: {}};\r\n\r\n(function (module, exports) {\r\nmodule.exports = () => {};\r\nexports.a = 3;\r\nexports.b = 4;\r\n}(esm$1, esm$1.exports));\r\n\r\nvar esm = esm$1.exports;\r\n\r\nexport { esm as default };\r\n```\r\n\r\n## 一些复杂的转化\r\n\r\nESM 与 CommonJS 不仅仅是简单的语法上的不同，它们在思维方式上就完全不同，因此还有一些较为复杂的转换，本篇先不做谈论，感兴趣的可以去我的博客上查找相关文章。\r\n\r\n1. 如何处理 `__dirname`\r\n1. 如何处理 `require(dynamicString)`\r\n1. 如何处理 CommonJS 中的编程逻辑，如下\r\n\r\n以下代码涉及到编程逻辑，由于 `exports` 是一个动态的 Javascript 对象，而它自然可以使用两次，那应该如何正确编译为 ESM 呢？\r\n\r\n``` js\r\n// input: index.cjs\r\nexports.sum = 0\r\nPromise.resolve().then(() => {\r\n  exports.sum = 100\r\n})\r\n```\r\n\r\n以下是一种不会出问题的代码转换结果\r\n\r\n``` js\r\n// output: index.mjs\r\nconst _default = { }\r\nlet sum = _default.sum = 0\r\nPromise.resolve().then(() => {\r\n  sum = _default.sum = 100\r\n})\r\nexport default _default\r\nexport { sum }\r\n```\r\n\r\n## CommonJS To ESM 的构建工具\r\n\r\nCommonJS 向 ESM 转化，自然有构建工具的参与，比如\r\n\r\n+ [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs)\r\n\r\n甚至把一些 CommonJS 库转化为 ESM，并且置于 CDN 中，使得我们可以直接使用，而无需构建工具参与\r\n\r\n+ <https://cdn.skypack.dev/>\r\n+ <https://jspm.org/>\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_efCE",
    "number": 754,
    "title": "【Q728】如何对 npm package 进行发包",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46ceEF",
          "body": "## 准备工作：一个账号\r\n\r\n在发布公共 package 之前，需要在 [npm 官网](https://www.npmjs.com/)进行注册一个账号。\r\n\r\n随后，在本地(需要发包的地方)执行命令 `npm login`，进行交互式操作并且登录。\r\n\r\n``` bash\r\n$ npm login\r\n```\r\n\r\n## 发包\r\n\r\n发布一个 npm 包之前，填写 `package.json` 中以下三项最重要的字段。假设此时包的名称为 `@shanyue/just-demo`\r\n\r\n``` js\r\n{\r\n  name: '@shanyue/just-demo',\r\n  version: '1.0.0',\r\n  main: './index.js',\r\n}\r\n```\r\n\r\n之后执行 `npm publish` 发包即可。\r\n\r\n``` bash\r\n$ npm publish\r\n```\r\n\r\n一旦发布完成，在任意地方通过 `npm i` 均可依赖该包。\r\n\r\n``` js\r\nconst x = require('@shanyue/just-demo')\r\n\r\nconsole.log(x)\r\n```\r\n\r\n如若该包进行更新后，需要再次发包，可 `npm version` 控制该版本进行升级，记住需要遵守 [Semver 规范](https://github.com/shfshanyue/Daily-Question/issues/534)\r\n\r\n``` bash\r\n# 增加一个修复版本号: 1.0.1 -> 1.0.2 (自动更改 package.json 中的 version 字段)\r\n$ npm version patch\r\n\r\n# 增加一个小的版本号: 1.0.1 -> 1.1.0 (自动更改 package.json 中的 version 字段)\r\n$ npm version minor\r\n\r\n# 将更新后的包发布到 npm 中\r\n$ npm publish\r\n```\r\n\r\n## 实际发包的内容\r\n\r\n在 npm 发包时，实际发包内容为 `package.json` 中 `files` 字段，一般只需将构建后资源(如果需要构建)进行发包，源文件可发可不发。\r\n\r\n``` js\r\n{\r\n  files: ['dist']\r\n}\r\n```\r\n\r\n若需要查看一个 package 的发包内容，可直接在 `node_modules/${package}` 进行查看，将会发现它和源码有很大不同。也可以在 CDN 中进行查看，以 React 为例\r\n\r\n1. jsdelivr: <https://cdn.jsdelivr.net/npm/react/>\r\n1. unpkg: <https://unpkg.com/browse/react/>\r\n\r\n![UNPKG](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-27/clipboard-7248.4f8241.webp)\r\n\r\n## 发包的实际流程\r\n\r\n`npm publish` 将自动走过以下生命周期\r\n\r\n+ prepublishOnly: 如果发包之前需要构建，可以放在这里执行\r\n+ prepack\r\n+ prepare: 如果发包之前需要构建，可以放在这里执行 (该周期也会在 npm i 后自动执行)\r\n+ postpack\r\n+ publish\r\n+ postpublish\r\n\r\n发包实际上是将本地 package 中的所有资源进行打包，并上传到 npm 的一个过程。你可以通过 `npm pack` 命令查看详情\r\n\r\n``` bash\r\n$ npm pack\r\nnpm notice\r\nnpm notice 📦  midash@0.2.6\r\nnpm notice === Tarball Contents ===\r\nnpm notice 1.1kB  LICENSE\r\nnpm notice 812B   README.md\r\nnpm notice 5.7kB  dist/midash.cjs.development.js\r\nnpm notice 13.4kB dist/midash.cjs.development.js.map\r\nnpm notice 3.2kB  dist/midash.cjs.production.min.js\r\nnpm notice 10.5kB dist/midash.cjs.production.min.js.map\r\nnpm notice 5.3kB  dist/midash.esm.js\r\nnpm notice 13.4kB dist/midash.esm.js.map\r\nnpm notice 176B   dist/omit.d.ts\r\n......\r\nnpm notice === Tarball Details ===\r\nnpm notice name:          midash\r\nnpm notice version:       0.2.6\r\nnpm notice filename:      midash-0.2.6.tgz\r\nnpm notice package size:  11.5 kB\r\nnpm notice unpacked size: 67.8 kB\r\nnpm notice shasum:        c89d8c1aa96f78ce8b1dcf8f0f058fa7a6936a6a\r\nnpm notice integrity:     sha512-lyx8khPVkCHvH[...]kBL6K6VqOG6dQ==\r\nnpm notice total files:   46\r\nnpm notice\r\nmidash-0.2.6.tgz\r\n```\r\n\r\n当你发包成功后，也可以前往 [npm devtool](https://npm.devtool.tech/react) 查看各项数据。\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-27/clipboard-8735.9e7628.webp)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_faBr",
    "number": 755,
    "title": "【Q729】如何分析前端打包体积",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_tVD3",
          "body": "1. 安装用于分析包的模块\r\n\r\n```shell\r\nnpm install webpack-bundle-analyzer --save-dev\r\n```\r\n\r\n2. vue.config.js 新增内容\r\n\r\n```js\r\nmodule.exports = {\r\n  chainWebpack: config => {\r\n    if(process.env.analyzer) {\r\n      config\r\n        .plugin(\"webpack-bundle-analyzer\")\r\n        .use(require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n3. package.json 新加一条 script -- \"analyzer\"\r\n\r\n```js\r\n\"scripts\": {\r\n  \"analyzer\": \"set analyzer=true && vue-cli-service build\" \r\n}\r\n```\r\n\r\n4. 命令行下输入\r\n\r\n```shell\r\nnpm run analyzer\r\n```\r\n\r\n如果需要修改默认端口，可按如下修改配置\r\n\r\n```js\r\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\r\n \r\nmodule.exports = {\r\n  chainWebpack: config => {\r\n    if(process.env.analyzer)\r\n      config\r\n        .plugin('webpack-bundle-analyzer')\r\n        .use(new BundleAnalyzerPlugin({ analyzerPort : 7888 }))\r\n  }\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "WenReq",
            "url": "https://github.com/WenReq"
          }
        },
        {
          "id": "IC_kwDODQzyOs5BajPM",
          "body": "在最新的的vue-cli里面 我这个4.5版本里面\r\n在package.json的script 打包的时候加上--report\r\n`report:prod\": \"vue-cli-service build --report`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1138943712",
            "url": "https://github.com/1138943712"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CFThu",
          "body": "在 webpack 中，可以使用 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 分析打包后体积分析。\r\n\r\n其原理是根据 webpack 打包后的 [Stats](https://webpack.js.org/api/stats/#root) 数据进行分析，在 webpack compiler 的 [done hook](https://webpack.js.org/api/compiler-hooks/#done) 进行处理，见[源码](https://github.com/webpack-contrib/webpack-bundle-analyzer/blob/master/src/BundleAnalyzerPlugin.js#L75)\r\n\r\n``` js\r\ncompiler.hooks.done.tapAsync('webpack-bundle-analyzer',  stats => {  });\r\n```\r\n\r\n在默认配置下，[webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 将会启动服务打开一个各个 chunk 下各个 module 占用体积的可视化图。\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538692bbcc8d485b893ebeac02cc90a5~tplv-k3u1fbpfcp-watermark.image?)\r\n\r\n**你可以通过它，找到在在打包中占用体积最大的模块，并进行优化。**\r\n\r\n在查看页面中，有三个体积选项：\r\n\r\n1. `stat`: 每个模块的原始体积\r\n2. `parsed `: 每个模块经 webpack 打包处理之后的体积，比如 terser 等做了压缩，便会体现在上边\r\n3. `gzip`: 经 gzip 压缩后的体积\r\n\r\n## ANALYZE 环境变量\r\n\r\n在实际项目中，往往通过环境变量 `ANALYZE` 配置该插件，代码如下，可见[bundle-analyze/build.js](https://github.com/shfshanyue/node-examples/blob/master/engineering/webpack/bundle-analyzer/build.js)。\r\n\r\n``` js\r\nconst webpack = require('webpack')\r\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\r\n\r\n// 1. BundleAnalyzerPlugin 是如何工作的？\r\n// 2. Stat、Parsed、Gziped 分别是何意义？\r\n// 3. terserplugin 对此结果有影响吗？\r\n\r\nfunction f1 () {\r\n  return webpack({\r\n    entry: './index.js',\r\n    mode: 'none',\r\n    plugins: [\r\n      process.env.ANALYZE && new BundleAnalyzerPlugin()\r\n    ]\r\n  })\r\n}\r\n\r\nf1().run((err, stat) => {\r\n})\r\n```\r\n\r\n在打包时，通过制定环境变量即可分析打包体积\r\n\r\n``` bash\r\nANALYZE=true npm run build\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_fcHA",
    "number": 756,
    "title": "【Q730】什么是 AST，及其应用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46dox2",
          "body": "`AST` 是 `Abstract Syntax Tree` 的简称，是前端工程化绕不过的一个名词。它涉及到工程化诸多环节的应用，比如:\r\n\r\n1. 如何将 Typescript 转化为 Javascript (typescript)\r\n1. 如何将 SASS/LESS 转化为 CSS (sass/less)\r\n1. 如何将 ES6+ 转化为 ES5 (babel)\r\n1. 如何将 Javascript 代码进行格式化 (eslint/prettier)\r\n1. 如何识别 React 项目中的 JSX (babel)\r\n1. GraphQL、MDX、Vue SFC 等等\r\n\r\n而在语言转换的过程中，实质上就是对其 AST 的操作，核心步骤就是 AST 三步走\r\n\r\n1. Code -> AST (Parse)\r\n1. AST -> AST (Transform)\r\n1. AST -> Code (Generate)\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-13/AST.37256a.webp)\r\n\r\n以下是一段代码，及其对应的 AST\r\n\r\n```js\r\n// Code\r\nconst a = 4\r\n\r\n// AST\r\n{\r\n  \"type\": \"Program\",\r\n  \"start\": 0,\r\n  \"end\": 11,\r\n  \"body\": [\r\n    {\r\n      \"type\": \"VariableDeclaration\",\r\n      \"start\": 0,\r\n      \"end\": 11,\r\n      \"declarations\": [\r\n        {\r\n          \"type\": \"VariableDeclarator\",\r\n          \"start\": 6,\r\n          \"end\": 11,\r\n          \"id\": {\r\n            \"type\": \"Identifier\",\r\n            \"start\": 6,\r\n            \"end\": 7,\r\n            \"name\": \"a\"\r\n          },\r\n          \"init\": {\r\n            \"type\": \"Literal\",\r\n            \"start\": 10,\r\n            \"end\": 11,\r\n            \"value\": 4,\r\n            \"raw\": \"4\"\r\n          }\r\n        }\r\n      ],\r\n      \"kind\": \"const\"\r\n    }\r\n  ],\r\n  \"sourceType\": \"module\"\r\n}\r\n```\r\n\r\n不同的语言拥有不同的解析器，比如 Javascript 的解析器和 CSS 的解析器就完全不同。\r\n\r\n对相同的语言，也存在诸多的解析器，也就会生成多种 AST，如 `babel` 与 `espree`。\r\n\r\n在 [AST Explorer](https://astexplorer.net/) 中，列举了诸多语言的解析器(Parser)，及转化器(Transformer)。\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96e2f4eba4e5475faab8068d7c06c43c~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n## AST 的生成\r\n\r\nAST 的生成这一步骤被称为**解析(Parser)**，而该步骤也有两个阶段: 词法分析(Lexical Analysis)和语法分析(Syntactic Analysis)\r\n\r\n### 词法分析 (Lexical Analysis)\r\n\r\n词法分析用以将代码转化为 `Token` 流，维护一个关于 Token 的数组\r\n\r\n![](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-12-13/Parse.050e33.webp)\r\n\r\n```js\r\n// Code\r\na = 3\r\n\r\n// Token\r\n[\r\n  { type: { ... }, value: \"a\", start: 0, end: 1, loc: { ... } },\r\n  { type: { ... }, value: \"=\", start: 2, end: 3, loc: { ... } },\r\n  { type: { ... }, value: \"3\", start: 4, end: 5, loc: { ... } },\r\n  ...\r\n]\r\n```\r\n\r\n词法分析后的 Token 流也有诸多应用，如:\r\n\r\n1. 代码检查，如 eslint 判断是否以分号结尾，判断是否含有分号的 token\r\n1. 语法高亮，如 highlight/prism 使之代码高亮\r\n1. 模板语法，如 ejs 等模板也离不开\r\n\r\n### 语法分析 (Syntactic Analysis)\r\n\r\n语法分析将 Token 流转化为结构化的 AST，方便操作\r\n\r\n```js\r\n{\r\n  \"type\": \"Program\",\r\n  \"start\": 0,\r\n  \"end\": 5,\r\n  \"body\": [\r\n    {\r\n      \"type\": \"ExpressionStatement\",\r\n      \"start\": 0,\r\n      \"end\": 5,\r\n      \"expression\": {\r\n        \"type\": \"AssignmentExpression\",\r\n        \"start\": 0,\r\n        \"end\": 5,\r\n        \"operator\": \"=\",\r\n        \"left\": {\r\n          \"type\": \"Identifier\",\r\n          \"start\": 0,\r\n          \"end\": 1,\r\n          \"name\": \"a\"\r\n        },\r\n        \"right\": {\r\n          \"type\": \"Literal\",\r\n          \"start\": 4,\r\n          \"end\": 5,\r\n          \"value\": 3,\r\n          \"raw\": \"3\"\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  \"sourceType\": \"module\"\r\n}\r\n```\r\n\r\n## 实践\r\n\r\n可通过自己写一个解析器，将语言 (DSL) 解析为 AST 进行练手，以下两个示例是不错的选择\r\n\r\n1. 解析简单的 HTML 为 AST\r\n1. 解析 Marktodwn List 为 AST\r\n\r\n或可参考一个最简编译器的实现 [the super tiny compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs4-DTzb",
          "body": "你好，请问下 token流 怎么理解这个名词？因为通常理解的token就是一个唯一的字符串，流，一般想到的是什么文件流什么的。一些什么序列化相关的，而token流说是一个数组，那就是说是由很多字符串组成的一个数组吗？为什么不直接说是一个数组反而要说是token流，为什么要提到 token 以及流（有点咬文嚼字了:( ），谢谢~~",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wenhui7788",
            "url": "https://github.com/wenhui7788"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_fhCs",
    "number": 757,
    "title": "【Q731】简述 browserslist 的意义",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs471Z8f",
          "body": "browserslist 是在不同的前端工具之间共用目标浏览器和 node 版本的配置工具。\r\n相当于给 Babel、PostCSS、ESLint、StyleLint 等这些前端工具预设一个浏览器支持范围，这些工具转换或检查代码时会参考这个范围。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "YaoHuangMark",
            "url": "https://github.com/YaoHuangMark"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CMORT",
          "body": "\r\n[browserslist](https://github.com/browserslist/browserslist) 用特定的语句来查询浏览器列表，如 `last 2 Chrome versions`。\r\n\r\n``` js\r\n$ npx browserslist \"last 2 Chrome versions\"\r\nchrome 100\r\nchrome 99\r\n```\r\n\r\n细说起来，**它是现代前端工程化不可或缺的工具，无论是处理 JS 的 `babel`，还是处理 CSS 的 `postcss`，凡是与垫片相关的，他们背后都有 `browserslist` 的身影。**\r\n\r\n+ `babel`，在 `@babel/preset-env` 中使用 `core-js` 作为垫片\r\n+ `postcss` 使用 `autoprefixer` 作为垫片\r\n\r\n关于前端打包体积与垫片关系，我们有以下几点共识:\r\n\r\n1. 由于低浏览器版本的存在，垫片是必不可少的\r\n2. 垫片越少，则打包体积越小\r\n3. 浏览器版本越新，则垫片越少\r\n\r\n那在前端工程化实践中，当我们确认了浏览器版本号，那么它的垫片体积就会确认。\r\n\r\n假设项目只需要支持最新的两个谷歌浏览器。那么关于 `browserslist` 的查询，可以写作 `last 2 Chrome versions`。\r\n\r\n而随着时间的推移，**该查询语句将会返回更新的浏览器，垫片体积便会减小。**\r\n\r\n**如使用以上查询语句，一年前可能还需要 `Promise.any` 的垫片，但目前肯定不需要了。**\r\n\r\n## 原理\r\n\r\n最终，谈一下 `browserslist` 的原理: `browserslist` 根据正则解析查询语句，对浏览器版本数据库 `caniuse-lite` 进行查询，返回所得的浏览器版本列表。\r\n\r\n> PS: `caniuse-lite` 这个库也由 `browserslist` 团队进行维护，它是基于 [caniuse](https://caniuse.com/) 的数据库进行的数据整合。\r\n\r\n因为 `browserslist` 并不维护数据库，因此它会经常提醒你去更新 `caniuse-lite` 这个库，由于 lock 文件的存在，因此需要使用以下命令手动更新数据库。\r\n\r\n``` bash\r\n$ npx browserslist@latest --update-db\r\n```\r\n\r\n该命令将会对 caniuse-lite 进行升级，可体现在 lock 文件中。\r\n\r\n``` diff\r\n     \"caniuse-lite\": {\r\n-      \"version\": \"1.0.30001265\",\r\n-      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001265.tgz\",\r\n-      \"integrity\": \"sha512-YzBnspggWV5hep1m9Z6sZVLOt7vrju8xWooFAgN6BA5qvy98qPAPb7vNUzypFaoh2pb3vlfzbDO8tB57UPGbtw==\",\r\n+      \"version\": \"1.0.30001332\",\r\n+      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001332.tgz\",\r\n+      \"integrity\": \"sha512-10T30NYOEQtN6C11YGg411yebhvpnC6Z102+B95eAsN0oB6KUs01ivE8u+G6FMIRtIrVlYXhL+LUwQ3/hXwDWw==\",\r\n       \"dev\": true\r\n     },\r\n```\r\n\r\n## 一些常用的查询语法\r\n\r\n### 根据用户份额:\r\n\r\n+ `> 5%`: 在全球用户份额大于 `5%` 的浏览器\r\n+ `> 5% in CN`: 在中国用户份额大于 `5%` 的浏览器\r\n\r\n### 根据最新浏览器版本\r\n\r\n+ `last 2 versions`: 所有浏览器的最新两个版本\r\n+ `last 2 Chrome versions`: Chrome 浏览器的最新两个版本\r\n\r\n### 不再维护的浏览器\r\n\r\n+ `dead`: 官方不在维护已过两年，比如 `IE10`\r\n\r\n### 浏览器版本号\r\n\r\n+ `Chrome > 90`: Chrome 大于 90 版本号的浏览器\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_fimd",
    "number": 758,
    "title": "【Q732】简述 bundless 的优势与不足",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_dpcR",
          "body": "Bundleless 的优势。\r\n1.项目启动快。因为不需要过多的打包，只需要处理修改后的单个文件，所以响应速度是 O(1) 级别，刷新即可即时生效，速度很快。\r\n2.浏览器加载块。利用浏览器自主加载的特性，跳过打包的过程。\r\n3.本地文件更新，重新请求单个文件。\r\n![Bundleless](http://oss.tianmasport.com/gx/size/2022-03-11/196/951803225336446976.png) ",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "WenReq",
            "url": "https://github.com/WenReq"
          }
        },
        {
          "id": "IC_kwDODQzyOs5Zfzgr",
          "body": "> 为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）\r\n\r\nhttps://cn.vitejs.dev/guide/why.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "justorez",
            "url": "https://github.com/justorez"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_fi8x",
    "number": 759,
    "title": "【Q733】简述 npm cache",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs4_fWtg",
          "body": "npm 会把所有下载的包，保存在用户文件夹下面。\r\n\r\n默认值：~/.npm在Posix上 或 %AppData%/npm-cache在Windows上。根缓存文件夹。\r\n\r\nnpm install 之后会计算每个包的 sha1 值(PS:安全散列算法(Secure Hash Algorithm))，然后将包与他的 sha1 值关联保存在 package-lock.json 里面，下次 npm install 时，会根据 package-lock.json 里面保存的 sha1 值去文件夹里面寻找包文件，如果找到就不用从新下载安装了。\r\n\r\n```sh\r\nnpm cache verify\r\n```\r\n\r\n上面这个命令是重新计算，磁盘文件是否与 sha1 值匹配，如果不匹配可能删除。\r\n\r\n> 要对现有缓存内容运行脱机验证，请使用 `npm cache verify`。\r\n\r\n```sh\r\nnpm cache clean --force\r\n```\r\n\r\n上面这个命令是删除磁盘所有缓存文件。",
          "star": {
            "totalCount": 5
          },
          "author": {
            "login": "WenReq",
            "url": "https://github.com/WenReq"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_foP6",
    "number": 760,
    "title": "【Q734】如何修复某个 npm 包的紧急 bug",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46eink",
          "body": "假设 `lodash` 有一个 Bug，影响线上开发，应该怎么办？\r\n\r\n![把大象扔进冰箱里需要几步](https://cdn.jsdelivr.net/gh/shfshanyue/assets/2021-11-11/clipboard-5920.ee51bc.webp)\r\n\r\n答: 三步走。\r\n\r\n1. 在 Github 提交 Pull Request，修复 Bug，等待合并\r\n1. 合并 PR 后，等待新版本发包\r\n1. 升级项目中的 lodash 依赖\r\n\r\n很合理很规范的一个流程，但是它一个最大的问题就是，太慢了，三步走完黄花菜都凉了。\r\n\r\n此时可直接上手修改 `node_modules` 中 lodash 代码，并修复问题！\r\n\r\n新问题：`node_modules` 未纳入版本管理，在生产环境并没有用。请看流程\r\n\r\n1. 本地修改 `node_modules/lodash`，本地正常运行 ✅\r\n1. 线上 `npm i lodash`，lodash 未被修改，线上运行失败 ❌\r\n\r\n此时有一个简单的方案，临时将修复文件纳入工作目录，可以解决这个问题\r\n\r\n1. 本地修改 `node_modules/lodash`，本地正常运行 ✅\r\n2. 将修改文件复制到 `${work_dir}/patchs/lodash` 中，纳入版本管理 \r\n3. 线上 `npm i lodash`，并将修改文件再度复制到 `node_modules/lodash` 中，线上正常运行 ✅\r\n\r\n但此时并不是很智能，且略有小问题，演示如下:\r\n\r\n1. 本地修改 `node_modules/lodash`，本地正常运行 ✅\r\n2. 将修改文件复制到 `${work_dir}/patchs/lodash` 中，纳入版本管理 ✅\r\n3. 线上 `npm i lodash`，并将修改文件再度复制到 `node_modules/lodash` 中，线上正常运行 ✅\r\n4. 两个月后升级 `lodash`，该问题得以解决，而我们代码引用了 lodash 的新特性\r\n5. 线上 `npm i lodash`，并将修改文件再度复制到 `node_modules/lodash` 中，由于已更新了 lodash，并且依赖于新特性，线上运行失败 ❌\r\n\r\n此时有一个万能之策，那就是 [patch-package](https://github.com/ds300/patch-package)\r\n\r\n## patch-package\r\n\r\n想要知道 `patch-package` 如何解决上述问题，请先了解下它的用法，流程如下\r\n\r\n``` bash\r\n# 修改 lodash 的一个小问题\r\n$ vim node_modules/lodash/index.js\r\n\r\n# 对 lodash 的修复生成一个 patch 文件，位于 patches/lodash+4.17.21.patch\r\n$ npx patch-package lodash\r\n\r\n# 将修复文件提交到版本管理之中\r\n$ git add patches/lodash+4.17.21.patch\r\n$ git commit -m \"fix 一点儿小事 in lodash\"\r\n\r\n# 此后的命令在生产环境或 CI 中执行\r\n# 此后的命令在生产环境或 CI 中执行\r\n# 此后的命令在生产环境或 CI 中执行\r\n\r\n# 在生产环境装包\r\n$ npm i\r\n\r\n# 为生产环境的 lodash 进行小修复\r\n$ npx patch-package\r\n\r\n# 大功告成！\r\n```\r\n\r\n再次看下 `patch-package` 自动生成 patch 文件的本来面目吧:\r\n\r\n它实际上是一个 `diff` 文件，在生产环境中可自动根据 diff 文件与版本号 (根据patch文件名存取) 将修复场景复原！\r\n\r\n``` bash\r\n$ cat patches/lodash+4.17.21.patch\r\ndiff --git a/node_modules/lodash/index.js b/node_modules/lodash/index.js\r\nindex 5d063e2..fc6fa33 100644\r\n--- a/node_modules/lodash/index.js\r\n+++ b/node_modules/lodash/index.js\r\n@@ -1 +1,3 @@\r\n+console.log('DEBUG SOMETHING')\r\n+\r\n module.exports = require('./lodash');\r\n\\ No newline at end of file\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_fpMB",
    "number": 761,
    "title": "【Q735】前端如何进行高效的分包",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs46eie8",
          "body": "# 如何正确地进行分包\r\n\r\n## 为什么需要分包？\r\n\r\n*为什么需要进行分包，一个大的 `bundle.js` 不好吗？*\r\n\r\n极其不建议，可从两方面进行考虑:\r\n\r\n1. 一行代码将导致整个 `bundle.js` 的缓存失效\r\n1. 一个页面仅仅需要 `bundle.js` 中 1/N 的代码，剩下代码属于其它页面，完全没有必要加载\r\n\r\n## 如何更好的分包？\r\n\r\n### 打包工具运行时\r\n\r\n> webpack(或其他构建工具) 运行时代码不容易变更，需要单独抽离出来，比如 `webpack.runtime.js`。由于其体积小，**必要时可注入 `index.html` 中**，减少 HTTP 请求数，优化关键请求路径\r\n\r\n### 前端框架运行时\r\n\r\n> React(Vue) 运行时代码不容易变更，且每个组件都会依赖它，可单独抽离出来 `framework.runtime.js`。请且注意，**务必将 React 及其所有依赖(react-dom/object-assign)共同抽离出来**，否则有可能造成性能损耗，见下示例\r\n\r\n*假设仅仅抽离 React 运行时(不包含其依赖)为单独 Chunk*，且每个路由页面为单独 Chunk。*某页面不依赖任何第三方库*，则该页面会加载以下 Chunk\r\n\r\n1. `webpack.runtime.js`    5KB  ✅\r\n2. `framework.runtime.js`  30KB ✅\r\n3. `page-a.chunk.js`       50KB ✅\r\n4. `vendor.chunk.js`       50KB ❌ (因 webpack 依赖其 `object-assign`，而 `object-assign` 将被打入共同依赖 `vendor.chunk.js`，因此此时它必回加载，但是该页面并不依赖任何第三方库，完全没有必要全部加载 `vendor.chunk.js`)\r\n\r\n将 React 运行时及其所有依赖，共同打包，修复结果如下，拥有了更完美的打包方案。\r\n\r\n1. `webpack.runtime.js`    5KB  ✅\r\n2. `framework.runtime.js`  40KB ✅  (+10KB)\r\n3. `page-a.chunk.js`       50KB ✅\r\n\r\n### 高频库\r\n\r\n一个模块被 N(2个以上) 个 Chunk 引用，可称为公共模块，可把公共模块给抽离出来，形成 `vendor.js`。\r\n\r\n问：那如果一个模块被用了多次 (2次以上)，但是该模块体积过大(1MB)，每个页面都会加载它(但是无必要，因为不是每个页面都依赖它)，导致性能变差，此时如何分包？\r\n\r\n答：如果一个模块虽是公共模块，但是该模块体积过大，可直接 `import()` 引入，异步加载，单独分包，比如 `echarts` 等\r\n\r\n问：如果公共模块数量多，导致 vendor.js 体积过大(1MB)，每个页面都会加载它，导致性能变差，此时如何分包\r\n\r\n答：有以下两个思路\r\n\r\n1. 思路一: 可对 vendor.js 改变策略，比如被引用了十次以上，被当做公共模块抽离成 verdor-A.js，五次的抽离为 vendor-B.js，两次的抽离为 vendor-C.js\r\n1. 思路二: 控制 vendor.js 的体积，当大于 100KB 时，再次进行分包，多分几个 vendor-XXX.js，但每个 vendor.js 都不超过 100KB\r\n\r\n## 使用 webpack 分包\r\n\r\n在 webpack 中可以使用 [SplitChunksPlugin](https://webpack.js.org/plugins/split-chunks-plugin) 进行分包，它需要满足三个条件:\r\n\r\n1. minChunks: 一个模块是否最少被 minChunks 个 chunk 所引用\r\n1. maxInitialRequests/maxAsyncRequests: 最多只能有 maxInitialRequests/maxAsyncRequests 个 chunk 需要同时加载 (如一个 Chunk 依赖 VendorChunk 才可正常工作，此时同时加载chunk数为 2)\r\n1. minSize/maxSize: chunk 的体积必须介于 (minSize, maxSize) 之间\r\n\r\n以下是 `next.js` 的默认配置，可视作最佳实践\r\n\r\n> [源码位置: next/build/webpack-config.ts](https://github.com/vercel/next.js/blob/v12.0.5-canary.10/packages/next/build/webpack-config.ts#L728)\r\n\r\n``` js\r\n{\r\n  // Keep main and _app chunks unsplitted in webpack 5\r\n  // as we don't need a separate vendor chunk from that\r\n  // and all other chunk depend on them so there is no\r\n  // duplication that need to be pulled out.\r\n  chunks: (chunk) =>\r\n    !/^(polyfills|main|pages\\/_app)$/.test(chunk.name) &&\r\n    !MIDDLEWARE_ROUTE.test(chunk.name),\r\n  cacheGroups: {\r\n    framework: {\r\n      chunks: (chunk: webpack.compilation.Chunk) =>\r\n        !chunk.name?.match(MIDDLEWARE_ROUTE),\r\n      name: 'framework',\r\n      test(module) {\r\n        const resource =\r\n          module.nameForCondition && module.nameForCondition()\r\n        if (!resource) {\r\n          return false\r\n        }\r\n        return topLevelFrameworkPaths.some((packagePath) =>\r\n          resource.startsWith(packagePath)\r\n        )\r\n      },\r\n      priority: 40,\r\n      // Don't let webpack eliminate this chunk (prevents this chunk from\r\n      // becoming a part of the commons chunk)\r\n      enforce: true,\r\n    },\r\n    lib: {\r\n      test(module: {\r\n        size: Function\r\n        nameForCondition: Function\r\n      }): boolean {\r\n        return (\r\n          module.size() > 160000 &&\r\n          /node_modules[/\\\\]/.test(module.nameForCondition() || '')\r\n        )\r\n      },\r\n      name(module: {\r\n        type: string\r\n        libIdent?: Function\r\n        updateHash: (hash: crypto.Hash) => void\r\n      }): string {\r\n        const hash = crypto.createHash('sha1')\r\n        if (isModuleCSS(module)) {\r\n          module.updateHash(hash)\r\n        } else {\r\n          if (!module.libIdent) {\r\n            throw new Error(\r\n              `Encountered unknown module type: ${module.type}. Please open an issue.`\r\n            )\r\n          }\r\n\r\n          hash.update(module.libIdent({ context: dir }))\r\n        }\r\n\r\n        return hash.digest('hex').substring(0, 8)\r\n      },\r\n      priority: 30,\r\n      minChunks: 1,\r\n      reuseExistingChunk: true,\r\n    },\r\n    commons: {\r\n      name: 'commons',\r\n      minChunks: totalPages,\r\n      priority: 20,\r\n    },\r\n    middleware: {\r\n      chunks: (chunk: webpack.compilation.Chunk) =>\r\n        chunk.name?.match(MIDDLEWARE_ROUTE),\r\n      filename: 'server/middleware-chunks/[name].js',\r\n      minChunks: 2,\r\n      enforce: true,\r\n    },\r\n  },\r\n  maxInitialRequests: 25,\r\n  minSize: 20000,\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs4_fpOm",
    "number": 762,
    "title": "【Q736】前端如何对分支环境进行部署",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5AoXWO",
          "body": "以下是基于gitlab的分支和tag进行前端部署的.gitlab-ci.yml配置\r\n\r\n```\r\nimage: node:12-alpine3.14\r\nstages: # 分段\r\n  # - install\r\n  - build\r\n  - deploy\r\n  - clear\r\n\r\ncache: # 缓存\r\n  paths:\r\n    - node_modules\r\n\r\njob_install:\r\n  tags:\r\n    - test\r\n  stage: build\r\n  script:\r\n    - npm install -g cnpm --registry=https://registry.npm.taobao.org\r\n    - cnpm install\r\n    - npm run build\r\n  # 只在指定dev分支或者tag以 dev_ 开头的标签执行该job\r\n  only:\r\n    refs:\r\n      - dev\r\n      - /^dev_[0-9]+(?:.[0-9]+)+$/ # regular expression\r\n  # 打包后的文件可以在gitlab上直接下载 \r\n  artifacts:\r\n    name: \"dist\"\r\n    paths:\r\n      - dist\r\n\r\njob_deploy:\r\n  image: docker\r\n  stage: deploy\r\n  environment:\r\n    name: test\r\n    url: http://172.6.6.6:8000\r\n  script:\r\n    - docker build -t appimages .\r\n    - if [ $(docker ps -aq --filter name=app-container) ]; then docker rm -f app-container;fi\r\n    - docker run -d -p 8082:80 --name app-container appimages\r\n\r\njob_clear:\r\n  image: docker\r\n  stage: clear\r\n  tags:\r\n    - test\r\n  script:\r\n    - if [ $(docker ps -aq | grep \"Exited\" | awk '{print $1 }') ]; then docker stop $(docker ps -a | grep \"Exited\" | awk '{print $1 }');fi\r\n    - if [ $(docker ps -aq | grep \"Exited\" | awk '{print $1 }') ]; then docker rm $(docker ps -a | grep \"Exited\" | awk '{print $1 }');fi\r\n    - if [ $(docker images | grep \"none\" | awk '{print $3}') ]; then docker rmi $(docker images | grep \"none\" | awk '{print $3}');fi\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "AndyTiTi",
            "url": "https://github.com/AndyTiTi"
          }
        },
        {
          "id": "IC_kwDODQzyOs5CMTzA",
          "body": "一种基于容器及 docker-compose 或者 k8s 的思路\r\n\r\n1. 借用现有的 CICD 服务，如 `github actions` 或者 `gitlab CI` **获取当前分支信息**\r\n1. 借用 Docker 快速部署前端或者后端，**根据分支信息启动不同的服务 (Service)**，**根据 Docker 启动服务并配置响应的标签 (Label)**\r\n1. 根据容器的标签与当前 Git 分支对前端后端设置不同的域名\r\n\r\n以下是一个 Preview 的示例，其中服务名 `cra-preview-${COMMIT_REF_NAME}` 基于分支名称进行构建。\r\n\r\n``` yaml\r\nversion: \"3\"\r\nservices:\r\n  cra-preview-${COMMIT_REF_NAME}:\r\n    build:\r\n      context: .\r\n      dockerfile: router.Dockerfile\r\n    labels:\r\n       # 配置域名: Preview\r\n       - \"traefik.http.routers.cra-preview-${COMMIT_REF_NAME}.rule=Host(`${COMMIT_REF_NAME}.cra.shanyue.tech`)\"\r\n       - traefik.http.routers.cra-preview-${COMMIT_REF_NAME}.tls=true\r\n       - traefik.http.routers.cra-preview-${COMMIT_REF_NAME}.tls.certresolver=le\r\n```\r\n\r\n在进行构建时，再通过 `envsub` 工具进行环境变量的替换\r\n\r\n``` bash\r\ncat preview.docker-compose.yaml | envsubst > docker-compose.yaml\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5DC-vH",
    "number": 764,
    "title": "【Q737】如何取得一个数字的小数部分与整数部分",
    "body": "试举几例\r\n\r\n+ `1.3e-19`\r\n+ `1.6`\r\n\r\n引用一些第三方包处理也可以",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs49i-_s",
          "body": "```typescript \r\nfunction splitNum (data: unknown): [string, string] {\r\n    if (typeof data === 'number' && !isNaN(data)) {\r\n        const dataStr = data.toString()\r\n        const eIndex = dataStr.indexOf('e-')\r\n        if (eIndex > -1) {\r\n            const result = dataStr.split('e-')\r\n            return ['0', `0.${'0'.repeat(Number(result[1]) - 1)}${result[0].replace('.', '')}`]\r\n        } else {\r\n            const result = dataStr.split('.')\r\n            if (result.length === 1) {\r\n                result.push('0')\r\n            }\r\n            return [result[0], `0.${result[1]}`]\r\n        }\r\n    }\r\n    return ['0', '0']\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "heretic-G",
            "url": "https://github.com/heretic-G"
          }
        },
        {
          "id": "IC_kwDODQzyOs49m-zr",
          "body": "```typescript\r\n/**科学计数法兼容*/\r\nconst SNFn = (val: string) => {\r\n  let state = val.includes('e-');\r\n  let splitStr = `e${state ? '-' : '+'}`;\r\n  let data = val.split(splitStr);\r\n  let fixBit = Number(data[1]);\r\n  let temp = data[0];\r\n  if (temp.includes('.')) {\r\n    let poinitPosition = temp.indexOf('.');\r\n    let len = temp.length;\r\n    fixBit = fixBit + (poinitPosition + (state ? 0 : 1)) - len;\r\n    temp = `${temp}`.replace('.', '');\r\n  }\r\n  let result = state\r\n    ? `0.${`0`.repeat(fixBit)}${temp}`\r\n    : `${temp}${`0`.repeat(fixBit)}`;\r\n  if (state && result.includes('-')) {\r\n    result = `-${result.replace('-', '')}`;\r\n  }\r\n  return state ? [`0`, result] : [result, `0`];\r\n};\r\n\r\n/**main*/\r\nconst splitFn = (val: number) => {\r\n  const valStr = `${val}`;\r\n  /**完全整数返回*/\r\n  if (!valStr.includes('.') && !valStr.includes('e')) return [valStr, `0`];\r\n  /**科学计数法兼容*/\r\n  if (valStr.includes('e')) {\r\n    let result = SNFn(valStr);\r\n    return result;\r\n  }\r\n  /**正常含小数返回*/\r\n  const result = valStr.split('.');\r\n  let state=result[0].includes('-')\r\n  return [`${result[0]}`, `${state?'-':''}0.${result[1]}`];\r\n};\r\n```\r\n\r\nhttps://stackblitz.com/edit/typescript-hr1bbp",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Feahter",
            "url": "https://github.com/Feahter"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5DQggf",
    "number": 765,
    "title": "【Q738】websocket 和短轮询有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5AWrev",
          "body": "短轮询是每隔一段时间发送一次HTTP请求，WebSocket 是全双工通讯的协议，允许服务端主动向客户端推送数据。短轮询的实时性不高，而且影响性能，而WebSocket做到了真正意义上的实时。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhiyuan5985",
            "url": "https://github.com/zhiyuan5985"
          }
        },
        {
          "id": "IC_kwDODQzyOs5DQPgD",
          "body": "好像是建立长连接，在连接不挂掉期间，都是可以互相传输信息",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1596944197",
            "url": "https://github.com/1596944197"
          }
        },
        {
          "id": "IC_kwDODQzyOs5G_MvB",
          "body": "websocket  是双工道通信协议\r\n短轮询 是单工道",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wolichuang",
            "url": "https://github.com/wolichuang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5H8lxa",
    "number": 771,
    "title": "【Q739】webpack 中是如何处理 new URL 资源的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5H8l8l",
    "number": 772,
    "title": "【Q740】vite 中是如何处理 new URL 资源的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5IGhN6",
    "number": 773,
    "title": "【Q741】我们上传图片为 Blob/File 对象时，是如何向服务器端传送数据的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5DQPTl",
          "body": "new FormData()可以发送二进制对象 #https://developer.mozilla.org/zh-CN/docs/Web/API/FormData\r\n也可以发送base64然后保存",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "1596944197",
            "url": "https://github.com/1596944197"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5NqjNP",
    "number": 788,
    "title": "【Q742】大文件上传，如何获取到读取进度？",
    "body": "``` html\r\n    <input type=\"file\" id=\"input\" onchange=\"handleFiles(this.files)\" />\r\n```\r\n当用户选择大文件上传时，浏览区需要花很长时间读取文件，读取完成后才会触发onchange事件\r\n\r\n问:\r\n1. 如何确定用户是选择了文件上传？还是取消了选择文件？\r\n2. 如果用户选择了文件，如何获取到读取进度？",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5G_MEt",
          "body": "0. 选择完文件建立连接后，生成 hash 值给后端，每次后端先判断下是否有 hash 值传过来。\r\n1. 文件超过一定大小的时候，需要前端进行固定大小的，切片上传\r\n2. 后端根据切片来接收数据，返回上传进度\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wolichuang",
            "url": "https://github.com/wolichuang"
          }
        }
      ]
    },
    "labels": {
      "nodes": []
    }
  },
  {
    "id": "I_kwDODQzyOs5Uf-6M",
    "number": 793,
    "title": "【Q747】如何实现一个 omit/omitBy 函数",
    "body": "``` js\r\nconst object = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\n\r\n//=> { c: 5 }\r\n_.omit(object, ['a', 'b'])\r\n\r\n// omit by value\r\n//=> { b:4, c: 5 }\r\nomitBy(object, value => value === 3)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5MrVN0",
          "body": "## TypeScript\r\n\r\n一种简单思路，顺序遍历 source 的每一项 key，与参数做对比，通过即储存到目标对象中\r\n\r\n```ts\r\nfunction omit<T extends Record<string, unknown>>(source: T, keys: (keyof T)[]) {\r\n    return Object.keys(source).reduce(((target: T, nowKey: keyof T) => {\r\n        if(!keys.includes(nowKey)) target[nowKey] = source[nowKey]\r\n        return target\r\n    }), {} as T)\r\n}\r\n\r\n\r\nfunction omitBy<T extends Record<string, unknown>>(source: T, filterFn: (v: unknown) => boolean) {\r\n    return Object.keys(source).reduce(((target: T, nowKey: keyof T) => {\r\n        if(!filterFn(source[nowKey])) target[nowKey] = source[nowKey]\r\n        return target\r\n    }), {} as T)\r\n}\r\n```\r\n\r\n## JavaScript\r\n\r\n```javascript\r\n\r\nfunction omit(source, keys) {\r\n    return Object.keys(source).reduce(((target, nowKey) => {\r\n        if(!keys.includes(nowKey)) target[nowKey] = source[nowKey]\r\n        return target\r\n    }), {})\r\n}\r\n\r\n\r\nfunction omitBy(source, filiterFn) {\r\n    return Object.keys(source).reduce(((target, nowKey) => {\r\n        if(!filiterFn(source[nowKey])) target[nowKey] = source[nowKey]\r\n        return target\r\n    }), {})\r\n}\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "alexzhang1030",
            "url": "https://github.com/alexzhang1030"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MrWYH",
          "body": "@alexzhang1030 omit 的复杂度过高，性能较差。应遍历 keys，逐一删除。另外，ts 直接用 Omit 这个内置 type。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MrW0N",
          "body": "> @alexzhang1030 omit 的复杂度过高，性能较差。应遍历 keys，逐一删除。另外，ts 直接用 Omit 这个内置 type。\n\n有个问题，直接删除不就修改源数据了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "alexzhang1030",
            "url": "https://github.com/alexzhang1030"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MrY5D",
          "body": "首先 {...obj}\r\n\r\n\r\n\r\n---原始邮件---\r\n发件人: ***@***.***&gt;\r\n发送时间: 2022年10月21日(周五) 中午12:11\r\n收件人: ***@***.***&gt;;\r\n抄送: ***@***.******@***.***&gt;;\r\n主题: Re: [shfshanyue/Daily-Question] 【Q747】如何实现一个 omit/omitBy 函数 (Issue #793)\r\n\r\n\r\n\r\n\r\n  \r\n@alexzhang1030 omit 的复杂度过高，性能较差。应遍历 keys，逐一删除。另外，ts 直接用 Omit 这个内置 type。\r\n  \r\n有个问题，直接删除不就修改源数据了\r\n \r\n—\r\nReply to this email directly, view it on GitHub, or unsubscribe.\r\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MrZFT",
          "body": "> 首先 {...obj}\n> \n> \n> \n> \n> \n> \n> \n> ---原始邮件---\n> \n> 发件人: ***@***.***&gt;\n> \n> 发送时间: 2022年10月21日(周五) 中午12:11\n> \n> 收件人: ***@***.***&gt;;\n> \n> 抄送: ***@***.******@***.***&gt;;\n> \n> 主题: Re: [shfshanyue/Daily-Question] 【Q747】如何实现一个 omit/omitBy 函数 (Issue #793)\n> \n> \n> \n> \n> \n> \n> \n> \n> \n>   \n> \n> @alexzhang1030 omit 的复杂度过高，性能较差。应遍历 keys，逐一删除。另外，ts 直接用 Omit 这个内置 type。\n> \n>   \n> \n> 有个问题，直接删除不就修改源数据了\n> \n>  \n> \n> —\n> \n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> \n> You are receiving this because you authored the thread.Message ID: ***@***.***&gt;\n\n懂了，还的是月哥，待会我加上",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "alexzhang1030",
            "url": "https://github.com/alexzhang1030"
          }
        },
        {
          "id": "IC_kwDODQzyOs5MrZfs",
          "body": "``` ts\r\nfunction omit<T extends Record<string, any>, K extends string, K2 extends keyof T>(obj: T, keys: (K | K2)[]) {\r\n  const result = { ...obj }\r\n\r\n  keys.forEach((key) => {\r\n    delete result[key]\r\n  })\r\n\r\n  return result as Omit<T, K>\r\n}\r\n\r\n\r\nfunction omitBy<T extends Record<string, any>, K extends keyof T>(object: T, callback: (value: T[K], key: K) => boolean) {\r\n  const result = { ...object }\r\n\r\n  Object.entries(result).forEach(([key, value]) => {\r\n    const isDrop = callback(value, key as K)\r\n\r\n    if (isDrop)\r\n      delete result[key]\r\n  })\r\n\r\n  return result as Partial<T>\r\n}\r\n\r\n\r\n\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "croatialu",
            "url": "https://github.com/croatialu"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5WNCdJ",
    "number": 794,
    "title": "【Q748】在 babel 编译为低版本 ES 时，为何能够编译可选链之类语法，但无法编译 API",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5OOTHW",
          "body": "见 <https://q.shanyue.tech/engineering/734.html>\r\n\r\nbabel/swc 只能处理操作符，而无法处理新的 API。如果需要处理 API 兼容，则需要引入 `core-js` 增加垫片代码",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5mN1vM",
    "number": 800,
    "title": "【Q743】实现 batchFn 函数，可以批量执行函数",
    "body": "补全及实现一下函数\r\n\r\n``` js\r\n\r\nlet executeCount = 0;\r\nconst targetFn = async nums => {\r\n  executeCount++;\r\n  return nums.map(num => 2 * num + 1);\r\n};\r\n\r\nconst batcher = (fn) => {\r\n  // todo batch logic\r\n  return () => {\r\n\r\n  }\r\n}\r\n\r\nconst batchedFn = batcher(targetFn);\r\n\r\nconst main = async () => {\r\n  const [result1, result2, result3] = await Promise.all([\r\n    batchedFn([1, 2, 3]),\r\n    batchedFn([4, 5]),\r\n    batchedFn([6, 7]),\r\n  ]);\r\n  \r\n  console.log(result1, result2, result3) \r\n  console.log(executeCount)  // 预期为 1\r\n}\r\n\r\nmain()\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5ch7Tl",
          "body": "在 [graphql/loader](https://github.com/graphql/dataloader/blob/main/src/index.js) 以及 [trpc](https://github.com/trpc/trpc/blob/next/packages/client/src/internals/dataLoader.ts#L41) 中均有关于 batch 的实现，意在提升性能，将多次 IO 合并为一次 IO\r\n\r\n其关键在于一次事件循环中的微任务队列存储所有的 batchKeys。\r\n\r\n[代码片段及执行结果见码上掘金](https://code.juejin.cn/pen/7342137519703588915)\r\n\r\n``` js\r\nconst batcher = (fn) => {\r\n  // todo batch logic\r\n  let allArgs = []\r\n  // 能够实现 batch 的关键所在\r\n  // 此处 fn(allArgs) 甚至可以实现为 fn([...new Set(allArgs)])，性能更好一些\r\n  const wait = Promise.resolve().then(() => fn(allArgs))\r\n\r\n  return async (args) => {\r\n    allArgs = [...allArgs, ...args]\r\n    const result = await wait\r\n\r\n    // allArgs 与 result 形成的一个 Map\r\n    // 借助于 lodash 可以更可读化地写成 Object.fromEntries(_.zip(allArgs, result))\r\n    const resultMap = result.reduce((acc, x, i) => {\r\n      const v = allArgs[i]\r\n      acc[v] = x\r\n      return acc\r\n    }, {})\r\n    return args.map(a => resultMap[a])\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "IC_kwDODQzyOs51uC0n",
          "body": "运行结果好像是输出 3 个 `[3, 5, 7]`，返回的 `promise` 中 `args` 应该都指向了第一次调用时传入的参数 ",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "MJWade96",
            "url": "https://github.com/MJWade96"
          }
        },
        {
          "id": "IC_kwDODQzyOs51uDS5",
          "body": "网上看到了另一种解法：[SegmentFault](https://segmentfault.com/a/1190000039406198)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "MJWade96",
            "url": "https://github.com/MJWade96"
          }
        },
        {
          "id": "IC_kwDODQzyOs51uu2b",
          "body": "@MJWade96 已修复，并配上相应的注释、码上掘金的 Playground 以及相关源码参考。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwzMDU0MjAwNTE1",
          "name": "code"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5yLx1G",
    "number": 802,
    "title": "【Q474】在 react 中，以下父子组件的 useEffect/useLayoutEffect 顺序如何",
    "body": "以下代码在控制台里如何按序输出，代码见 [codesandbox](https://codesandbox.io/p/sandbox/react-effect-layout-nest-fghgf2?file=%2Fsrc%2FApp.tsx%3A1%2C1-38%2C1)\r\n\r\n``` tsx\r\nimport { useEffect, useLayoutEffect } from \"react\";\r\nimport \"./App.css\";\r\n\r\nfunction Child() {\r\n  console.log(\"Child: Render\");\r\n\r\n  useEffect(() => {\r\n    console.log(\"Child: useEffect\");\r\n  });\r\n\r\n  useLayoutEffect(() => {\r\n    console.log(\"Child: useLayoutEffect\");\r\n  });\r\n\r\n  return <div className=\"App\">Child</div>;\r\n}\r\n\r\nfunction App() {\r\n  console.log(\"App: render\");\r\n\r\n  useEffect(() => {\r\n    console.log(\"App: useEffect\");\r\n  });\r\n\r\n  useLayoutEffect(() => {\r\n    console.log(\"App: useLayoutEffect\");\r\n  });\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      App\r\n      <Child />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n```\r\n",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs5nqtq8",
          "body": "不太会，跑了下，运行结果如下\r\nhttps://stackblitz.com/edit/vitejs-vite-ibcjhf?file=src%2FApp.jsx\r\n```\r\nApp: render\r\nChild: Render\r\nChild: useLayoutEffect\r\nApp: useLayoutEffect\r\nChild: useEffect\r\nApp: useEffect\r\n```\r\n\r\n学习了下面两篇文章：\r\nhttps://jser.dev/2023-07-08-how-does-useeffect-work\r\nhttps://jser.dev/react/2021/12/04/how-does-useLayoutEffect-work \r\n\r\n总结一下我的理解：\r\n1、useEffect 通过 scheduleCallback调度的，是异步执行的，也就是在渲染到页面后执行\r\n而useLayoutEffect 是同步执行的，发生在dom mutation更新了dom结构，但是还未绘制到屏幕之前\r\n2、useEffect 和 useLayoutEffect 都是递归执行的，先执行子组件\r\n3、有useEffect 和 useLayoutEffect的fiber会被打上标记，加入到effectList中, 每次更新都会都会处理, 两个函数都会处理成effectObject, 包含create、destory属性，其中create是useEffect 和 useLayoutEffect传入的函数，destory对应传入的函数执行返回的函数，在commit阶段，每次都是先执行destory清理函数，然后执行create， 挂载时destory为undefined，跳过清理函数执行，执行create，执行后把return的函数复制给destory， 下一次更新时destory不为undefined就会执行destory销毁函数，如果dep有变化接下来执行create",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wangfengyuan",
            "url": "https://github.com/wangfengyuan"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs5zTg0m",
    "number": 803,
    "title": "【Q745】webpack 的打包流程是什么样的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "IC_kwDODQzyOs51b8rS",
          "body": "Webpack 的打包流程大致可以归纳为以下几个步骤：\r\n初始化: 启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。\r\n编译: 从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找出该 Module 依赖的 Module，递归地进行编译处理。\r\n确定 Chunk: 每个 Module 都编译完成后，根据 Module 之间的依赖关系，生成代码块(Chunk)。\r\n生成 Bundle: 每个 Chunk 都转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。\r\n输出完成: 确定好输出内容后，根据配置确定的路径与文件名，把文件写入到文件系统。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Apr2026",
            "url": "https://github.com/Apr2026"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs51hvYX",
    "number": 804,
    "title": "【Q744】数据库中更新一条记录时，如何自动更新其 updated_at 字段",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs6AzjEP",
    "number": 805,
    "title": "【Q746】如何避免 SQL 攻击",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs6BOSt-",
    "number": 806,
    "title": "【Q749】React18 有哪些新特性",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs6BOSy2",
    "number": 807,
    "title": "【Q750】React19 有哪些新特性",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "I_kwDODQzyOs6Ch12V",
    "number": 808,
    "title": "【Q752】实现 useDebouncedCallback",
    "body": "类似 [useDebouncedCallback](https://github.com/xnimorz/use-debounce?tab=readme-ov-file#debounced-callbacks)\r\n\r\n示例如下\r\n\r\n``` js\r\n\r\nfunction Input() {\r\n  const [value, setValue] = useState('');\r\n\r\n  const handleChange = useDebouncedCallback(\r\n    (value) => {\r\n      setValue(value);\r\n    },\r\n    1000\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        onChange={(e) => handleChange(e.target.value)}\r\n      />\r\n      <p>{value}</p>\r\n    </div>\r\n  );\r\n}\r\n```",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": []
    }
  }
]