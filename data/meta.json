{
  "2": {
    "number": 2,
    "title": "【Q002】当 ping 一个 IP 地址时发生了什么",
    "keywords": [
      "ping",
      "IP 地址",
      "ICMP ECHO_REQUEST",
      "ICMP ECHO_RESPONSE",
      "查询报文"
    ],
    "description": "从 ping 的 man 手册就可以看出来，ping 实际上发送了 ICMP ECHO_REQUEST 的报文。通过让目标 IP 地址返回 ICMP ECHO_RESPONSE 报文来判断 IP 可不可达。ICMP 分为 Query 查询报文及 Error Message 报文，ping 为查询报文。"
  },
  "7": {
    "number": 7,
    "title": "【Q006】如何写一个 SQL 获取分组 top n 的数据",
    "keywords": [
      "SQL",
      "获取",
      "分组",
      "top n",
      "数据"
    ],
    "description": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名    假设有学生表 student(id, score, class_id)，score 代表分数，class_id 代表班级，如何写出 SQL 取每个班级分数前三名    通过一个自连接可以获取到"
  },
  "10": {
    "number": 10,
    "title": "【Q009】如何实现一个元素的水平垂直居中",
    "keywords": [
      "实现",
      "元素",
      "水平垂直居中",
      "行内元素",
      "块状元素"
    ],
    "description": "要求对行内元素、块状元素及不定宽高的块状元素均可适用。提供一些现代浏览器下使用 flex/grid 的方法，不仅支持块状元素，而且支持行内元素，对固定高宽与不固定高宽皆可使用。"
  },
  "11": {
    "number": 11,
    "title": "【Q010】了解 React 中的 ErrorBoundary 吗，它有那些使用场景",
    "keywords": [
      "React",
      "ErrorBoundary",
      "使用场景"
    ],
    "description": "了解 React 中的 ErrorBoundary 吗，它有那些使用场景"
  },
  "17": {
    "number": 17,
    "title": "【Q016】后端的敏感数据在生产环境是如何配置的",
    "keywords": [
      "后端",
      "敏感数据",
      "生产环境",
      "配置",
      "数据库"
    ],
    "description": "后端的敏感数据在生产环境是如何配置的，如数据库的账号密码，jwt 的 secret，联调上游服务的 token 等"
  },
  "19": {
    "number": 19,
    "title": "【Q018】当你使用 docker 部署应用时，如何查看应用日志",
    "keywords": [
      "docker",
      "部署",
      "应用",
      "日志",
      "k8s"
    ],
    "description": "当你使用 docker 部署应用时，如何查看应用日志。在docker中使用 docker logs CONTAINER。如果在k8s中使用 kubectl logs POD。"
  },
  "23": {
    "number": 23,
    "title": "【Q022】如何实现一个简单的 Promise",
    "keywords": [
      "Promise",
      "实现",
      "简单",
      "resolve",
      "reject"
    ],
    "description": "一个简单的 Promise 的粗糙实现，关键点在于当 pending 时， thenable 函数由一个队列维护。当状态变为 resolved(fulfilled) 时，队列中所有 thenable 函数执行。当 resolved 时， thenable 函数直接执行。rejected 状态同理。"
  },
  "27": {
    "number": 27,
    "title": "【Q026】如何对接口进行压力测试",
    "keywords": [
      "接口",
      "压力测试",
      "ab",
      "wrk",
      "siege"
    ],
    "description": "如何对接口进行压力测试"
  },
  "28": {
    "number": 28,
    "title": "【Q027】在前端开发中，如何获取浏览器的唯一标识",
    "keywords": [
      "浏览器",
      "唯一标识",
      "前端开发",
      "获取",
      "指纹信息"
    ],
    "description": "根据 canvas 可以获取浏览器指纹信息。绘制 canvas，获取 base64 的 dataurl。对 dataurl 这个字符串进行 md5 摘要计算，得到指纹信息。若在生产环境使用，可以使用 fingerprintjs2，根据业务需求，如单设备是否可跨浏览器，以此选择合适的 component"
  },
  "29": {
    "number": 29,
    "title": "【Q028】在linux中如何获取登录的用户",
    "keywords": [
      "linux",
      "获取",
      "登录",
      "用户",
      "who"
    ],
    "description": "在linux中如何获取登录的用户"
  },
  "38": {
    "number": 38,
    "title": "【Q037】linux 有哪些发行版，你最喜欢哪一个",
    "keywords": [
      "linux",
      "发行版",
      "Centos",
      "Ubuntu",
      "服务器"
    ],
    "description": "我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。用的人多，就好用了。（不过我装 tmux 和 vim 都需要从源码编译"
  },
  "47": {
    "number": 47,
    "title": "【Q046】docker 中的网络隔离是如何实现的",
    "keywords": [
      "docker",
      "网络隔离",
      "实现",
      "参考",
      "iptables"
    ],
    "description": "docker 中的网络隔离是如何实现的"
  },
  "50": {
    "number": 50,
    "title": "【Q049】什么是守护进程",
    "keywords": [
      "守护进程",
      "后台进程",
      "控制台关闭",
      "运行",
      "深层次"
    ],
    "description": "守护进程，可以被认为是后台进程，当你把控制台关闭时，它仍然还会运行。当然 - 这只是表面，从更深层次看呢？"
  },
  "55": {
    "number": 55,
    "title": "【Q054】简述TCP 的三次握手",
    "keywords": [
      "TCP",
      "三次握手",
      "socket",
      "ESTABSHED"
    ],
    "description": "简述TCP 的三次握手。一图胜千言。三次握手之后，客户端与服务器端的两个 socket 处于 ESTABSHED 状态。"
  },
  "56": {
    "number": 56,
    "title": "【Q055】如何在 linux 中打印所有环境变量",
    "keywords": [
      "linux",
      "打印",
      "环境变量",
      "printenv",
      "XDG_SESSION_ID"
    ],
    "description": "如何在 linux 中打印所有环境变量"
  },
  "58": {
    "number": 58,
    "title": "【Q057】什么是熔断机制，微服务如何做熔断",
    "keywords": [
      "熔断机制",
      "微服务",
      "熔断"
    ],
    "description": "什么是熔断机制，微服务如何做熔断"
  },
  "60": {
    "number": 60,
    "title": "【Q059】四层负载均衡与七层负载均衡有什么区别",
    "keywords": [
      "四层负载均衡",
      "七层负载均衡",
      "区别"
    ],
    "description": "四层负载均衡与七层负载均衡有什么区别"
  },
  "61": {
    "number": 61,
    "title": "【Q060】你们项目中的计划任务是如何组织的",
    "keywords": [
      "项目",
      "计划任务",
      "组织"
    ],
    "description": "你们项目中的计划任务是如何组织的"
  },
  "62": {
    "number": 62,
    "title": "【Q061】如何判断两个链表是否相交",
    "keywords": [
      "链表",
      "相交"
    ],
    "description": "如何判断两个链表是否相交"
  },
  "63": {
    "number": 63,
    "title": "【Q062】RPC 与 REST 有什么优劣",
    "keywords": [
      "RPC",
      "REST",
      "优劣"
    ],
    "description": "RPC 与 REST 有什么优劣"
  },
  "64": {
    "number": 64,
    "title": "【Q063】SIGINT SIGTERM SIGKILL 有什么区别",
    "keywords": [
      "SIGINT",
      "SIGTERM",
      "SIGKILL",
      "区别"
    ],
    "description": "SIGINT SIGTERM SIGKILL 有什么区别"
  },
  "65": {
    "number": 65,
    "title": "【Q064】如何实现服务发现 (Service Discovery)",
    "keywords": [
      "服务发现",
      "k8s"
    ],
    "description": "如何实现服务发现 (Service Discovery) TODO: k8s 的服务发现是如何实现的"
  },
  "66": {
    "number": 66,
    "title": "【Q065】有没有使用过 oss，对象存储相比块存储和文件存储有什么优缺点",
    "keywords": [
      "oss",
      "对象存储",
      "块存储",
      "文件存储",
      "优缺点"
    ],
    "description": "有没有使用过 oss，对象存储相比块存储和文件存储有什么优缺点"
  },
  "67": {
    "number": 67,
    "title": "【Q066】如何使用 react hooks 实现 useFetch 请求数据",
    "keywords": [
      "react hooks",
      "useFetch",
      "请求数据",
      "API",
      "设计"
    ],
    "description": "如何使用 react hooks 实现 useFetch 请求数据，比如设计成 useFetch 这种形式，它的 API 应该如何设计"
  },
  "68": {
    "number": 68,
    "title": "【Q067】react 如何使用 render prop component 请求数据",
    "keywords": [
      "react",
      "render prop component",
      "请求数据",
      "fetching data"
    ],
    "description": "react 如何使用 render prop component 请求数据"
  },
  "81": {
    "number": 81,
    "title": "【Q080】使用 webpack 打包时，如何更好地利用 long term cache",
    "keywords": [
      "webpack",
      "打包",
      "long term cache",
      "contenthash",
      "chunkhash"
    ],
    "description": "使用 webpack 打包时，如何更好地利用 long term cache @SageSanyue 目前更推荐使用 contenthash，而不是 chunkhash"
  },
  "85": {
    "number": 85,
    "title": "【Q084】随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代",
    "keywords": [
      "http2",
      "前端性能优化",
      "传统方案",
      "替代",
      "雪碧图"
    ],
    "description": "随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代"
  },
  "87": {
    "number": 87,
    "title": "【Q086】Tree Shaking 的原理是什么",
    "keywords": [
      "Tree Shaking",
      "ES Module",
      "静态分析",
      "AST",
      "打包体积"
    ],
    "description": "Tree Shaking 指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。"
  },
  "88": {
    "number": 88,
    "title": "【Q087】什么是 CNAME 记录和 A 记录",
    "keywords": [
      "CNAME",
      "A",
      "记录",
      "域名",
      "IP"
    ],
    "description": "什么是 CNAME 记录和 A 记录    CNAME：域名  -> 域名  A：域名 -> IP"
  },
  "89": {
    "number": 89,
    "title": "【Q088】如何实现 promise.map，限制 promise 并发数",
    "keywords": [
      "实现",
      "promise.map",
      "限制",
      "promise",
      "并发数"
    ],
    "description": "如何实现 promise.map，限制 promise 并发数。实现一个 promise.map，进行并发数控制。"
  },
  "95": {
    "number": 95,
    "title": "【Q094】你们的前端代码上线部署一次需要多长时间，需要人为干预吗",
    "keywords": [
      "前端代码",
      "上线部署",
      "时间",
      "人为干预",
      "敏捷开发"
    ],
    "description": "你们的前端代码上线部署一次需要多长时间，需要人为干预吗 更短的部署时间，更少的人为干预，更有利于敏捷开发"
  },
  "97": {
    "number": 97,
    "title": "【Q096】cron 表达式 (* 10 * * *) 会如何触发",
    "keywords": [
      "cron",
      "表达式",
      "触发",
      "十点",
      "执行"
    ],
    "description": "每天十点，每分钟都会执行一次"
  },
  "98": {
    "number": 98,
    "title": "【Q097】cron 表达式 (30 10 * * *) 会如何触发",
    "keywords": [
      "cron",
      "表达式",
      "触发",
      "十点半",
      "执行"
    ],
    "description": "每天十点半执行一次"
  },
  "99": {
    "number": 99,
    "title": "【Q098】在 linux 中如何查看 cron 执行的情况",
    "keywords": [
      "linux",
      "cron",
      "centos",
      "日志文件",
      "tail"
    ],
    "description": "在 linux 中如何查看 cron 执行的情况。在 centos 中，查看日志文件。"
  },
  "100": {
    "number": 100,
    "title": "【Q099】git 如何查看某个文件的提交历史",
    "keywords": [
      "git",
      "查看",
      "文件",
      "提交历史"
    ],
    "description": "git 如何查看某个文件的提交历史"
  },
  "102": {
    "number": 102,
    "title": "【Q101】你们后端代码上线部署一次需要多长时间",
    "keywords": [
      "后端代码",
      "上线部署",
      "时间",
      "开发人员",
      "项目部署流程"
    ],
    "description": "你们后端代码上线部署一次需要多长时间。关键在于考虑开发人员对项目部署流程的了解。30分钟左右。那你们部署的流程是什么呢？我觉得半个小时有点多呀。"
  },
  "110": {
    "number": 110,
    "title": "【Q109】可以对图片开启 gzip 压缩吗，为什么",
    "keywords": [
      "图片",
      "gzip",
      "压缩",
      "开启",
      "更大"
    ],
    "description": "不需要开启，如果开启的话，有可能使图片变的更大。如果你注意一些网站的 img 资源时，就会发现他们都没有开启 gzip"
  },
  "118": {
    "number": 118,
    "title": "【Q117】既然 http 是无状态协议，那它是如何保持登录状态",
    "keywords": [
      "http",
      "无状态协议",
      "登录状态",
      "cookie",
      "Authorization header"
    ],
    "description": "既然 http 是无状态协议，那它是如何保持登录状态 通过 cookie 或者 Authorization header 来传递凭证，在服务端进行认证"
  },
  "119": {
    "number": 119,
    "title": "【Q118】有没有读过 koa 的源码，什么是洋葱模型呢",
    "keywords": [
      "koa",
      "源码",
      "洋葱模型",
      "中间件",
      "框架"
    ],
    "description": "四十行代码实现一个 koa，了解 koa 的源码和洋葱模型，构建 Application 和 Context，实现洋葱模型及中间件改造，完成 compose 函数的封装，异常处理"
  },
  "122": {
    "number": 122,
    "title": "【Q121】我们如何从 http 的报文中得知该服务使用的技术栈",
    "keywords": [
      "http",
      "报文",
      "技术栈",
      "response header",
      "X-Powerd-By"
    ],
    "description": "我们如何从 http 的报文中得知该服务使用的技术栈。一般有两个 response header，有时服务端为了隐蔽自己真实的技术栈会隐蔽这两个字段：X-Powerd-By、Server。"
  },
  "125": {
    "number": 125,
    "title": "【Q124】如何保证内网服务的安全性",
    "keywords": [
      "内网服务",
      "安全性",
      "gitlab CE",
      "重大漏洞",
      "公司内部使用"
    ],
    "description": "如何保证内网服务的安全性，如 gitlab CE 经常暴露出重大漏洞，而它也只需要在公司内部使用。部署 gitlab 时我们如何保证它的安全性"
  },
  "129": {
    "number": 129,
    "title": "【Q128】构建镜像时，那几个指令会增加镜像层数",
    "keywords": [
      "构建镜像时",
      "指令",
      "增加镜像层数",
      "RUN",
      "ADD"
    ],
    "description": "构建镜像时，那几个指令会增加镜像层数"
  },
  "134": {
    "number": 134,
    "title": "【Q133】http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思",
    "keywords": [
      "http",
      "响应头",
      "content-type",
      "application/octet-stream",
      "二进制流"
    ],
    "description": "代表二进制流，一般用以下载文件"
  },
  "136": {
    "number": 136,
    "title": "【Q135】负载均衡有哪几种方式，它们的原理是什么",
    "keywords": [
      "负载均衡",
      "方式",
      "原理"
    ],
    "description": "负载均衡有哪几种方式，它们的原理是什么"
  },
  "140": {
    "number": 140,
    "title": "【Q139】在 Node 应用中如何利用多核心CPU的优势",
    "keywords": [
      "Node",
      "cluster",
      "多核心CPU",
      "优势",
      "应用"
    ],
    "description": "在 Node 应用中如何利用多核心CPU的优势 使用 cluster 模块 Node 中 cluster 的原理是什么"
  },
  "141": {
    "number": 141,
    "title": "【Q140】Node 中 cluster 的原理是什么",
    "keywords": [
      "Node",
      "cluster",
      "fork",
      "Load Balance",
      "多进程共享端口"
    ],
    "description": "Node 中 cluster 的原理是什么。1. fork 子进程  2. Load Balance  3. 多进程共享端口。相关文章：Node 官方文档: cluster，深入浅出 node cluster，Node.js进阶：cluster模块深入剖析。"
  },
  "143": {
    "number": 143,
    "title": "【Q142】react hooks 中如何模拟 componentDidMount",
    "keywords": [
      "react hooks",
      "componentDidMount",
      "useEffect",
      "callback",
      "依赖的状态"
    ],
    "description": "在 useEffect，把第二个参数即依赖的状态，设置为 []"
  },
  "145": {
    "number": 145,
    "title": "【Q144】http 1.1 中的 keep-alive 有什么作用",
    "keywords": [
      "http 1.1",
      "keep-alive",
      "TCP 连接",
      "http 请求",
      "SSL 连接"
    ],
    "description": "在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求。避免了重开 TCP 连接的开销，避免了刷新时重新建立 SSL 连接的开销，避免了QPS过大时，服务器的连接数过大。在服务器端使用响应头开启 keep-alive。"
  },
  "146": {
    "number": 146,
    "title": "【Q145】如何判断端口是否可达",
    "keywords": [
      "判断端口是否可达",
      "nc",
      "-z",
      "测试接口连通性",
      "localhost"
    ],
    "description": "如何判断端口是否可达 使用 nc，-z 指测试接口连通性 nc -vz localhost 443"
  },
  "147": {
    "number": 147,
    "title": "【Q146】如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗",
    "keywords": [
      "SSR",
      "created",
      "componentWillMount",
      "localStorage",
      "浏览器环境"
    ],
    "description": "如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗    不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错"
  },
  "149": {
    "number": 149,
    "title": "【Q148】关于 JSON，以下代码输出什么",
    "keywords": [
      "JSON",
      "代码",
      "输出",
      "对象",
      "字符串"
    ],
    "description": "关于 JSON，以下代码输出什么。const obj = { a: 3, b: 4, c: null }. console.log(JSON.stringify(obj)). 输出什么？"
  },
  "151": {
    "number": 151,
    "title": "【Q150】redis 中 zset 是什么，用作什么应用场景",
    "keywords": [
      "redis",
      "zset",
      "SortedSet",
      "排行榜",
      "优先级消息队列"
    ],
    "description": "redis 中 zset 是什么，用作什么应用场景 SortedSet，有序集合，一般可以有两种用途 排行榜，TOP N 之类 优先级消息队列"
  },
  "152": {
    "number": 152,
    "title": "【Q151】react hooks 如何替代或部分替代 redux 功能",
    "keywords": [
      "react hooks",
      "替代",
      "部分替代",
      "redux",
      "功能"
    ],
    "description": "我们把全局store分为两块 从服务器端来，如各种 model，此时可以使用 swr 直接替代。或者封装一个 useModel，如 useUser，usePermission 客户端全局 store，此时可以使用 useReducer 和 useContext 来替代"
  },
  "153": {
    "number": 153,
    "title": "【Q152】如何实现一个 react hook，你有没有自己写过一个",
    "keywords": [
      "react hook",
      "自定义",
      "useState",
      "useEffect",
      "hooks"
    ],
    "description": "如何实现一个 react hook，你有没有自己写过一个 可以参考官方文档  自定义一个 hook 仅仅是一个以 use 打头，组合 useState 和 useEffect 或者其它 hooks 的一个普通函数"
  },
  "157": {
    "number": 157,
    "title": "【Q156】如何进行代码质量检测",
    "keywords": [
      "代码质量检测",
      "圈复杂度",
      "复杂度",
      "测试用例数量",
      "维护"
    ],
    "description": "如何进行代码质量检测    圈复杂度(Cyclomatic complexity)描写了代码的复杂度，可以理解为覆盖代码所有场景所需要的最少测试用例数量。CC 越高，代码则越不好维护"
  },
  "161": {
    "number": 161,
    "title": "【Q160】如何设置一个 cookie",
    "keywords": [
      "设置",
      "cookie",
      "旧方式",
      "新的API",
      "cookieStore"
    ],
    "description": "如何设置一个 cookie"
  },
  "167": {
    "number": 167,
    "title": "【Q166】在C语言中，void * 是什么意思",
    "keywords": [
      "C语言",
      "void *",
      "指针",
      "整数",
      "字符串"
    ],
    "description": "在C语言中，void * 是一个可能指向任何类型的指针。"
  },
  "168": {
    "number": 168,
    "title": "【Q167】每个指针所占的存储空间是多少",
    "keywords": [
      "指针",
      "存储空间",
      "字长",
      "64位系统",
      "32位系统"
    ],
    "description": "每个指针所占的存储空间与字长有关。如果是64位系统，则占八个字节，32位系统，则占四个字节。可以用 sizeof 测试"
  },
  "172": {
    "number": 172,
    "title": "【Q171】在服务器内如何得知自己的公网IP",
    "keywords": [
      "服务器",
      "公网IP",
      "TCP 连接",
      "真实 IP 地址",
      "curl"
    ],
    "description": "在服务器内如何得知自己的公网IP。有现成的公网IP服务提供，根据 TCP 连接获得真实 IP 地址。"
  },
  "173": {
    "number": 173,
    "title": "【Q172】C语言中 printf 与 puts 有什么区别",
    "keywords": [
      "C语言",
      "printf",
      "puts",
      "区别",
      "字符串输出"
    ],
    "description": "C语言中printf与puts有什么区别。支持各种格式的printf函数可以输出各种类型的数据，而puts函数只能输出字符串到stdout，适用于只有字符串时。"
  },
  "178": {
    "number": 178,
    "title": "【Q177】如何在 url 中传递数组",
    "keywords": [
      "URL",
      "数组",
      "复杂数据",
      "传输",
      "约定"
    ],
    "description": "在 URL 中如何传递数组这种复杂的数据，完全取决于项目中前后端成员关于复杂数据在 URL 中传输的约定，一般情况下可以使用以下方式来传递数组"
  },
  "182": {
    "number": 182,
    "title": "【Q181】如何实现 compose 函数，进行函数合成",
    "keywords": [
      "compose",
      "函数合成",
      "redux",
      "高阶组件",
      "从右向左"
    ],
    "description": "实现一个 compose 函数，进行函数合成，比如 redux 中的 compose，react 高阶组件连续调用时的 compose"
  },
  "185": {
    "number": 185,
    "title": "【Q184】有没有使用过 css variable，它解决了哪些问题",
    "keywords": [
      "css variable",
      "解决问题",
      "运行时控制",
      "灵活",
      "JS 控制"
    ],
    "description": "有没有使用过 css variable，它解决了哪些问题    可在运行时控制 CSS 逻辑，与 less/sass 相比，更加灵活，因为它很容易通过 JS 来控制。"
  },
  "186": {
    "number": 186,
    "title": "【Q185】谈谈你对 styled-component 的看法",
    "keywords": [
      "styled-component",
      "CSS-in-JS",
      "流行",
      "方案"
    ],
    "description": "谈谈你对 styled-component 的看法    最为流行的 CSS-in-JS 方案"
  },
  "187": {
    "number": 187,
    "title": "【Q186】写一个关于全排列，全组合的函数",
    "keywords": [
      "全排列",
      "全组合",
      "Arragement",
      "Combination"
    ],
    "description": "写一个关于全排列，全组合的函数"
  },
  "189": {
    "number": 189,
    "title": "【Q188】大数乘法和大数加法",
    "keywords": [
      "大数乘法",
      "大数加法"
    ],
    "description": "大数乘法和大数加法"
  },
  "196": {
    "number": 196,
    "title": "【Q195】package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明",
    "keywords": [
      "package-lock.json",
      "作用",
      "项目",
      "lock 文件",
      "版本号"
    ],
    "description": "package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明 packagelock.json/yarn.lock 用以锁定版本号，保证开发环境与生产环境的一致性，避免出现不兼容 API 导致生产环境报错"
  },
  "199": {
    "number": 199,
    "title": "【Q198】如何实现类似 lodash.get 函数",
    "keywords": [
      "实现",
      "类似",
      "lodash.get",
      "函数",
      "ts"
    ],
    "description": "使用 get 函数可避免长链的 key 时获取不到属性而出现问题，此时进行异常避免时及其服务，如 o.a && o.a.b && o.a.b.c && o.a.b.c.d"
  },
  "202": {
    "number": 202,
    "title": "【Q201】js 中什么是可选链操作符，如何访问数组",
    "keywords": [
      "可选链操作符",
      "访问数组",
      "嵌套获取对象的属性值",
      "undefined",
      "null"
    ],
    "description": "?. 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。"
  },
  "214": {
    "number": 214,
    "title": "【Q213】什么是隔离级，都有哪些隔离级",
    "keywords": [
      "隔离级",
      "并发事务",
      "隔离机制",
      "ANSI SQL",
      "Read Uncommited"
    ],
    "description": "隔离级事关并发事务的隔离机制，ANSI SQL 中定义了四种隔离级，分别是 Read Uncommited, Read Committed, Repetable Read, Serializable"
  },
  "221": {
    "number": 221,
    "title": "【Q220】请简述一下 event loop",
    "keywords": [
      "event loop",
      "网站",
      "好评"
    ],
    "description": "请简述一下 event loop 这个网站好评啊！"
  },
  "227": {
    "number": 227,
    "title": "【Q226】数据库死锁是怎么产生的",
    "keywords": [
      "数据库死锁",
      "事务",
      "资源",
      "交替顺序访问",
      "并发"
    ],
    "description": "多个事务对资源的交替顺序访问，如事务1，访问A表，A表锁住，访问B表，此时B表却被事务2锁住，等待事务2，访问B表，B表锁住，访问A表，此时A表却被事务1锁住，等待。由此观之，此死锁出现的条件极为苛刻。"
  },
  "229": {
    "number": 229,
    "title": "【Q228】如何实现一个 flatMap 函数 (头条)",
    "keywords": [
      "flatMap",
      "EcmaScript",
      "例子",
      "输出",
      "原因"
    ],
    "description": "Array.prototype.flatMap 已经是 EcmaScript 的标准，看一个例子，它的输出是多少？很可惜，不是 [2, 3, 4, 5]，原因在于 flatMap 实际上是先 map 再 flat，实现如下"
  },
  "230": {
    "number": 230,
    "title": "【Q229】在数据库中一个字段如果是字符串类型的，那应该设置哪种数据类型",
    "keywords": [
      "数据库",
      "字段",
      "字符串类型",
      "数据类型",
      "text"
    ],
    "description": "在数据库中一个字段如果是字符串类型的，那应该设置哪种数据类型。在 postgres 中的情况，有三种 varchar，char 以及 text，其中三者没有性能差异。所以，选择 text 是最好的方案。"
  },
  "232": {
    "number": 232,
    "title": "【Q231】你周末都喜欢做些什么",
    "keywords": [
      "周末",
      "喜欢",
      "打篮球",
      "看电影",
      "看不下书"
    ],
    "description": "你周末都喜欢做些什么。打篮球，看电影，看不下书怎么办。丰富而有意义的生活啊，有这样的美好生活，还看书干嘛？工作日再看呀。"
  },
  "236": {
    "number": 236,
    "title": "【Q235】useEffect 中如何使用 async/await",
    "keywords": [
      "useEffect",
      "async/await",
      "clean-up",
      "Promise",
      "subscription"
    ],
    "description": "根据文档及 ts 的提示来看，useEffect 的回调参数返回的是一个清除副作用的 clean-up 函数。因此无法返回 Promise，更无法使用 async/await    此时可以选择再包装一层 async 函数，置于 useEffect 的回调函数中，变相使用 async/await"
  },
  "240": {
    "number": 240,
    "title": "【Q239】Node 如何进行进程间通信 ",
    "keywords": [
      "Node",
      "进程间通信",
      "spawn",
      "fork",
      "pipe"
    ],
    "description": "对于 spawn/fork 出来的父子进程来说，可以通过 pipe 的方式 process.on('message')/process.send stdin.on/stdout.write 对于并无相关的进程 socket message queue"
  },
  "242": {
    "number": 242,
    "title": "【Q241】如何使用 async/await 实现 Promise.all 的效果",
    "keywords": [
      "async/await",
      "Promise.all",
      "getUser",
      "Promise",
      "await"
    ],
    "description": "如何使用 async/await 实现 Promise.all 的效果。如获取三个用户的信息，使用 Promise.all 的写法。那如何不使用 Promise.all 实现以上效果。使用 async/await 实现。"
  },
  "247": {
    "number": 247,
    "title": "【Q245】有没有用过 Promise.allSettled() ，它是干什么的",
    "keywords": [
      "Promise.allSettled",
      "代码",
      "简洁"
    ],
    "description": "有没有用过 Promise.allSettled() ，它是干什么的 @mrrs878 代码相当简洁了！"
  },
  "255": {
    "number": 255,
    "title": "【Q253】cookie 有哪些字段",
    "keywords": [
      "cookie",
      "字段",
      "path",
      "domain",
      "key"
    ],
    "description": "cookie 有哪些字段"
  },
  "257": {
    "number": 257,
    "title": "【Q255】图片防盗链原理是什么",
    "keywords": [
      "图片防盗链原理",
      "请求头",
      "refer",
      "屏蔽图片"
    ],
    "description": "图片防盗链原理是什么 请求头中的 refer 来判断是否屏蔽图片"
  },
  "260": {
    "number": 260,
    "title": "【Q258】如何实现一个分布式的爬虫",
    "keywords": [
      "分布式",
      "爬虫",
      "redis",
      "url",
      "调度器"
    ],
    "description": "可以通过 redis 实现一个分布式的 url 调度器 (Set)，多个分布式爬虫的爬取器从调度器中统一取地址进行爬取"
  },
  "262": {
    "number": 262,
    "title": "【Q260】如何实现单点登录",
    "keywords": [
      "单点登录",
      "原理",
      "简单实现",
      "图",
      "链接"
    ],
    "description": "一张来单点登录原理与简单实现的图"
  },
  "263": {
    "number": 263,
    "title": "【Q261】当写爬虫时，因爬取过多被禁掉 IP 怎么解决",
    "keywords": [
      "爬虫",
      "IP",
      "解决",
      "维护",
      "Proxy"
    ],
    "description": "当写爬虫时，因爬取过多被禁掉 IP 怎么解决。可以维护一个 IP 地址池，通过 Proxy 的方式去爬取网页"
  },
  "268": {
    "number": 268,
    "title": "【Q266】bind 与 call/apply 的区别是什么",
    "keywords": [
      "bind",
      "call",
      "apply",
      "区别"
    ],
    "description": "bind 与 call/apply 的区别是什么。他们都是绑定 this 的，但是 bind 返回函数，call/apply 直接执行函数。"
  },
  "271": {
    "number": 271,
    "title": "【Q269】什么是 XSS 攻击，如何避免",
    "keywords": [
      "XSS",
      "攻击",
      "避免",
      "CSS",
      "跨站脚本攻击"
    ],
    "description": "CSS (Cross Site Scripting)，跨站脚本攻击。可使用以下脚本在指定网站上进行攻击"
  },
  "282": {
    "number": 282,
    "title": "【Q280】html 的默认 display 属性是多少",
    "keywords": [
      "html",
      "display",
      "属性",
      "默认"
    ],
    "description": "html 根元素的默认 display 为 block"
  },
  "284": {
    "number": 284,
    "title": "【Q282】对一个非定长宽的块状元素如何做垂直水平居中",
    "keywords": [
      "非定长宽",
      "块状元素",
      "垂直水平居中",
      "css",
      "position"
    ],
    "description": "对一个非定长宽的块状元素如何做垂直水平居中"
  },
  "285": {
    "number": 285,
    "title": "【Q283】http 请求头中的 X-Forwarded-For 代表什么意思",
    "keywords": [
      "X-Forwarded-For",
      "http",
      "请求头",
      "代表",
      "意思"
    ],
    "description": "X-Forwarded-For 被反向代理器生成，如 nginx，traefik 等，一般用作标识客户端真实的 IP 地址，目前已成为事实上的标准。"
  },
  "289": {
    "number": 289,
    "title": "【Q287】在 redis 中如何查看版本号",
    "keywords": [
      "redis",
      "版本号",
      "查看",
      "5.0.7",
      "sha"
    ],
    "description": "在 redis 中如何查看版本号 Redis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=fbc6fab733127977"
  },
  "290": {
    "number": 290,
    "title": "【Q288】如何求数组中的 TOP k",
    "keywords": [
      "数组",
      "TOP k",
      "前 N 个最大的数",
      "小顶堆",
      "堆化"
    ],
    "description": "如何求数组中的 TOP k  求数组中的前 N 个最大的数    1. 取数组中前 k 个数做小顶堆，堆化  1. 数组中的其它数逐一与堆顶元素比较，若大于堆顶元素，则插入该数    时间复杂度 O(nlg(k))"
  },
  "293": {
    "number": 293,
    "title": "【Q291】简述 node/v8 中的垃圾回收机制",
    "keywords": [
      "v8",
      "垃圾回收机制",
      "Scavenge",
      "Mark-Sweep",
      "Mark-Compact"
    ],
    "description": "v8 中的垃圾回收机制分为三种。Scavenge，工作在新生代，把 from space 中的存活对象移至 to space。Mark-Sweep，标记清除。新生代的某些对象由于过度活跃会被移至老生代，此时对老生代中活对象进行标记，并清理死对象。Mark-Compact，标记整理。"
  },
  "294": {
    "number": 294,
    "title": "【Q292】peerDependency 是为了解决什么问题",
    "keywords": [
      "peerDependency",
      "解决",
      "问题",
      "npm",
      "peer",
      "dependencies"
    ],
    "description": "Q292 peerDependency 是为了解决什么问题"
  },
  "296": {
    "number": 296,
    "title": "【Q294】optionalDependencies 的使用场景是什么",
    "keywords": [
      "optionalDependencies",
      "使用场景",
      "包",
      "依赖",
      "异常处理"
    ],
    "description": "当一个包是可依赖可不依赖时，可采用 optionalDependencies，但需要在代码中做好异常处理。如 chokidar 对 fsevents 的引入"
  },
  "297": {
    "number": 297,
    "title": "【Q295】fetch 中 credentials 指什么意思，可以取什么值",
    "keywords": [
      "fetch",
      "credentials",
      "cookie",
      "omit",
      "same-origin"
    ],
    "description": "credentials指在使用fetch发送请求时是否应当发送cookie。omit: 从不发送cookie. same-origin: 同源时发送cookie (浏览器默认值). include: 同源与跨域时都发送cookie."
  },
  "299": {
    "number": 299,
    "title": "【Q297】服务器的平均负载如何计算",
    "keywords": [
      "服务器的平均负载",
      "计算",
      "load average",
      "单位时间",
      "运行态进程"
    ],
    "description": "服务器的平均负载如何计算 load average 指单位时间内运行态进程及不可中断进程的平均进程数，运行态进程指正在使用或者等待使用 CPU 的进程，不可中断进程指正等待一些 IO 操作的进程。可使用 uptime 查看此指标。"
  },
  "300": {
    "number": 300,
    "title": "【Q298】如何创建一个进程",
    "keywords": [
      "创建一个进程",
      "exec",
      "fork"
    ],
    "description": "如何创建一个进程"
  },
  "303": {
    "number": 303,
    "title": "【Q301】base64 由哪64个字符构成",
    "keywords": [
      "base64",
      "64个字符",
      "A-Z",
      "a-z",
      "0-9"
    ],
    "description": "base64 由哪64个字符构成"
  },
  "307": {
    "number": 307,
    "title": "【Q305】如何删除项目中没有使用到的 package",
    "keywords": [
      "删除",
      "项目",
      "没有使用",
      "package",
      "depcheck"
    ],
    "description": "如何删除项目中没有使用到的 package，可以采用 depcheck 来完成这件事"
  },
  "315": {
    "number": 315,
    "title": "【Q313】在浏览器中如何获取剪切板中内容",
    "keywords": [
      "浏览器",
      "获取剪切板中内容",
      "Clipboard API",
      "权限",
      "读取剪贴板"
    ],
    "description": "通过 Clipboard API 可以获取剪切板中内容，但需要获取到 clipboard-read 的权限，以下是关于读取剪贴板内容的代码。该方法在 devtools 中不生效。相关问题: 【Q019】如何实现选中复制的功能"
  },
  "317": {
    "number": 317,
    "title": "【Q315】'+' 与 '~' 选择器有什么不同",
    "keywords": [
      "选择器",
      "不同",
      "紧邻",
      "兄弟元素",
      "随后"
    ],
    "description": "+ + 选择器匹配紧邻的兄弟元素  + ~ 选择器匹配随后的所有兄弟元素"
  },
  "337": {
    "number": 337,
    "title": "【Q334】position: sticky 如何工作，适用于哪些场景",
    "keywords": [
      "position",
      "sticky",
      "relative",
      "fixed",
      "场景"
    ],
    "description": "position: sticky 可理解为 relative 与 fixed 的结合体"
  },
  "341": {
    "number": 341,
    "title": "【Q338】js 中在 new 的时候发生了什么",
    "keywords": [
      "js",
      "new",
      "对象",
      "this",
      "实例"
    ],
    "description": "js 中在 new 的时候发生了什么。创建一个新的对象。this 指向实例，并且执行函数。如果没有显式返回，则默认返回这个实例。"
  },
  "342": {
    "number": 342,
    "title": "【Q339】伪类与伪元素有什么区别",
    "keywords": [
      "伪类",
      "伪元素",
      "区别",
      "单冒号",
      "双冒号"
    ],
    "description": "伪类与伪元素有什么区别。伪类使用单冒号，而伪元素使用双冒号。如 :hover 是伪类，::before 是伪元素。伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容。参考 https://www.w3.org/TR/CSS2/selector.html#pseudo-elements"
  },
  "347": {
    "number": 347,
    "title": "【Q344】如何列出所有已合并到 master 的分支并删除",
    "keywords": [
      "列出",
      "已合并",
      "分支",
      "删除",
      "master"
    ],
    "description": "如何列出所有已合并到 master 的分支并删除"
  },
  "348": {
    "number": 348,
    "title": "【Q345】postgres 中 Index Scan 与 Index Only Scan 有何区别",
    "keywords": [
      "postgres",
      "Index Scan",
      "Index Only Scan",
      "查询条件",
      "索引"
    ],
    "description": "假设在 user 表简历索引 (name, age) Index Scan 指查询中除利用索引外还有额外的查询条件，如 (name, age) 是索引，但是 sex 不是 Index Only Scan 指查询中可以全部利用索引，如 (name, age) 都是索引"
  },
  "350": {
    "number": 350,
    "title": "【Q347】在 node 中如何开启 https",
    "keywords": [
      "node",
      "https",
      "express",
      "开启",
      "代码"
    ],
    "description": "在 express 中开启 https，如下代码所示"
  },
  "354": {
    "number": 354,
    "title": "【Q351】如何得知目前 node 版本的 v8 版本号",
    "keywords": [
      "node",
      "版本号",
      "v8",
      "process.versions",
      "依赖"
    ],
    "description": "如何得知目前 node 版本的 v8 版本号 在 process.versions 中可以查看 node 及相关依赖的版本号"
  },
  "357": {
    "number": 357,
    "title": "【Q354】在 node 中如何判断一个对象是 stream",
    "keywords": [
      "stream",
      "node",
      "对象",
      "判断",
      "缓冲区"
    ],
    "description": "stream 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。每一个 stream 都有 pipe 函数，可以用来判断一个对象是否 stream。代码如下，摘自 is-stream: 一个周下载量两千万的 npm package。"
  },
  "358": {
    "number": 358,
    "title": "【Q355】什么是 Iterable 对象，与 Array 有什么区别",
    "keywords": [
      "Iterable",
      "对象",
      "Array",
      "区别",
      "迭代"
    ],
    "description": "什么是 Iterable 对象，与 Array 有什么区别    实现了 [Symbol.iterator] 属性的对象即是 Iterable 对象，然后可以使用操作符 for...of 进行迭代    详细参考 <https://javascript.info/iterable>"
  },
  "361": {
    "number": 361,
    "title": "【Q357】js 如何全部替代一个子串为另一个子串",
    "keywords": [
      "替换",
      "子串",
      "正则表达式",
      "全量替换",
      "特殊字符"
    ],
    "description": "两种办法    + str.split('foo').join('bar')  + str.replaceAll('foo', 'bar')，在 ESNext 中，目前支持性不好"
  },
  "366": {
    "number": 366,
    "title": "【Q361】既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗 ",
    "keywords": [
      "CORS",
      "CSRF",
      "攻击",
      "form",
      "xhr"
    ],
    "description": "既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗 对 CORS 一点用也没有 form 提交不通过 CORS 检测，你可以在本地进行测试 即使通过 xhr 及 fetch 进行提交被 CORS 拦住，但是对于简单请求而言，请求仍被发送，已造成了攻击"
  },
  "369": {
    "number": 369,
    "title": "【Q364】css 如何匹配前N个子元素及最后N个子元素",
    "keywords": [
      "css",
      "匹配",
      "前N个子元素",
      "最后N个子元素",
      "表格单双行条纹样式"
    ],
    "description": "css 如何匹配前N个子元素及最后N个子元素"
  },
  "375": {
    "number": 375,
    "title": "【Q370】如何使用 CSS 实现网站的暗黑模式 (Dark Mode)",
    "keywords": [
      "CSS",
      "暗黑模式",
      "Dark Mode",
      "网站",
      "实现"
    ],
    "description": "如何使用 CSS 实现网站的暗黑模式 (Dark Mode) 可参考以下文章: 1. Dark mode in 5 minutes, with inverted lightness variables"
  },
  "390": {
    "number": 390,
    "title": "【Q385】什么是缓存穿透，如何解决",
    "keywords": [
      "缓存穿透",
      "解决",
      "数据库",
      "缓存策略",
      "高并发"
    ],
    "description": "当访问数据库中不存在的数据时，此时由于不恰当的缓存策略，每次查询都会穿透缓存打在数据库上，这样在高并发下可能造成缓存穿透"
  },
  "392": {
    "number": 392,
    "title": "【Q387】http2 中 server push 与 websocket 有什么区别",
    "keywords": [
      "HTTP2",
      "Server Push",
      "websocket",
      "资源",
      "数据通信"
    ],
    "description": "HTTP2 Server Push，一般用以服务器根据解析 index.html 同时推送 JPG/JS/CSS 等资源，而免了服务器发送多次请求 websocket，用以服务器与客户端手动编写代码去推送进行数据通信"
  },
  "401": {
    "number": 401,
    "title": "【Q394】https 中证书的格式化信息有哪些",
    "keywords": [
      "https",
      "证书",
      "格式化信息",
      "TLS",
      "X.509"
    ],
    "description": "在 TLS 握手过程中，服务器端需要给客户端提供证书，X.509 就是证书的标准格式。以下是 github 的证书在 Mac 上显示的内容，可见：序列号、Subject Name、Issuer Name、电子签名、签名算法、公钥、扩展。"
  },
  "402": {
    "number": 402,
    "title": "【Q395】https 连接时如何保证证书没被废弃掉",
    "keywords": [
      "https",
      "连接",
      "证书",
      "废弃",
      "CRL"
    ],
    "description": "两种方式：CRL（Certificate Revocation List，证书撤销名单）。PKI 体系中由 CA 维护的一个被撤销证书的列表，浏览器会定时拉取这个文件。但这个文件的实时性及性能都可能有问题"
  },
  "403": {
    "number": 403,
    "title": "【Q396】TLS1.3 相比 TLS1.2 有何不同",
    "keywords": [
      "TLS1.3",
      "TLS1.2",
      "RFC 5246",
      "RFC 8446",
      "ClientHello"
    ],
    "description": "握手时间从以前的 2RTT 缩短到 1RTT，通过 Pre shared-key 减少了单独的 ServerKeyExchange 与 ClientKeyExchange 消耗的一个 RTT  0-RTT Resumption"
  },
  "405": {
    "number": 405,
    "title": "【Q398】在 wireshark 中如何抓包 https/http2",
    "keywords": [
      "wireshark",
      "抓包",
      "https",
      "http2",
      "参考"
    ],
    "description": "在 wireshark 中如何抓包 https/http2"
  },
  "408": {
    "number": 408,
    "title": "【Q401】在 TLS 层如何优化网站性能",
    "keywords": [
      "TLS",
      "OSCP Stapling",
      "TLS 1.3"
    ],
    "description": "在 TLS 层如何优化网站性能"
  },
  "409": {
    "number": 409,
    "title": "【Q402】如何实现一个函数 isPlainObject 判断是否为纯对象",
    "keywords": [
      "实现",
      "函数",
      "isPlainObject",
      "判断",
      "纯对象"
    ],
    "description": "如何实现一个函数 isPlainObject 判断是否为纯对象 纯对象：通过 Object 构造函数或者 Object.create 构建，见下示例"
  },
  "412": {
    "number": 412,
    "title": "【Q405】你使用过哪些前端性能分析工具",
    "keywords": [
      "前端性能分析工具",
      "lighthouse",
      "chrome devtools",
      "webpagetest",
      "分布式的性能分析工具"
    ],
    "description": "你使用过哪些前端性能分析工具。最常见且实用的性能工具有两个：lighthouse: 可在 chrome devtools 直接使用，根据个人设备及网络对目标网站进行分析，并提供各种建议。webpagetest: 分布式的性能分析工具，可在全球多个区域的服务器资源为你的网站进行分析，并生成相应的报告。"
  },
  "413": {
    "number": 413,
    "title": "【Q406】在你们的后端应用中，redis 用在哪些场景",
    "keywords": [
      "后端应用",
      "redis",
      "缓存",
      "限流",
      "队列"
    ],
    "description": "在你们的后端应用中，redis 用在哪些场景"
  },
  "416": {
    "number": 416,
    "title": "【Q409】什么是 BNF 与 ABNF",
    "keywords": [
      "BNF",
      "ABNF",
      "巴克斯范式",
      "编程语言语法",
      "元语言"
    ],
    "description": "BNF (巴克斯范式) 是一种描述编程语言语法的元语言 ABNF (Augmented BNF)，扩展的 BNF，通过 <https://www.ietf.org/rfc/rfc5234.txt> 规范"
  },
  "417": {
    "number": 417,
    "title": "【Q410】你最近看的三本书是什么",
    "keywords": [
      "最近",
      "三本书",
      "第二本书",
      "感觉"
    ],
    "description": "你最近看的三本书是什么"
  },
  "426": {
    "number": 426,
    "title": "【Q419】DV、OV、EV 类的证书有何区别",
    "keywords": [
      "DV",
      "OV",
      "EV",
      "Domain Validation",
      "Organization Validation"
    ],
    "description": "DV、OV、EV 类的证书有何区别，Domain Validation，最低级别的证书校验，Lets Encrypt 就是这种，因此也不怎么需要花钱，Organization Validation，校验证书中组织身份，从中可以看出公司名称，所在地等信息，Extended Validation，最高级别的证书校验"
  },
  "428": {
    "number": 428,
    "title": "【Q421】如何实现一个无限累加的 sum 函数",
    "keywords": [
      "无限累加",
      "sum函数",
      "懒计算",
      "valueOf",
      "递归"
    ],
    "description": "这是一个关于懒计算的函数，使用 sum 收集所有累加项，使用 valueOf 进行计算"
  },
  "430": {
    "number": 430,
    "title": "【Q423】什么是安全的正则表达式",
    "keywords": [
      "安全的正则表达式",
      "CPU",
      "定时炸弹",
      "回溯次数",
      "指数爆炸"
    ],
    "description": "下边这个正则表达式能把 CPU 跑挂的正则表达式就是一个定时炸弹，回溯次数进入了指数爆炸般的增长。"
  },
  "432": {
    "number": 432,
    "title": "【Q425】什么是层叠上下文 (stacking context)",
    "keywords": [
      "层叠上下文",
      "stacking context",
      "HTML 元素",
      "z 轴",
      "z-index"
    ],
    "description": "我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。其中，z-index 会影响这个层级的优先性"
  },
  "435": {
    "number": 435,
    "title": "【Q428】在 nginx 中如何配置负载均衡",
    "keywords": [
      "nginx",
      "负载均衡",
      "proxy_pass",
      "upstream",
      "round_robin"
    ],
    "description": "通过 proxy_pass 与 upstream 即可实现最为简单的负载均衡。如下配置会对流量均匀地导向 172.168.0.1，172.168.0.2 与 172.168.0.3 三个服务器"
  },
  "440": {
    "number": 440,
    "title": "【Q433】在C语言中，void 是什么意思",
    "keywords": [
      "C语言",
      "void",
      "返回",
      "print",
      "hello"
    ],
    "description": "在C语言中，void是指无需返回的空值。以下是一个示例代码，其中的return语句没有返回任何东西，可以省略不写。"
  },
  "441": {
    "number": 441,
    "title": "【Q434】当服务器资源返回 304 时与那些 HTTP 响应头有关",
    "keywords": [
      "服务器资源",
      "返回 304",
      "HTTP 响应头",
      "新鲜度",
      "浏览器获取资源"
    ],
    "description": "当服务器资源返回 304 时与那些 HTTP 响应头有关。再次请求时，需要向服务器校验新鲜度，如果资源是新鲜的，返回 304，从浏览器获取资源。与之相关的 Request/Response Headers 有以下几个：Last-Modified/If-Modified-Since，Etag/If-None-Match"
  },
  "443": {
    "number": 443,
    "title": "【Q436】如何实现一个 sample 函数，从数组中随机取一个元素",
    "keywords": [
      "实现",
      "sample",
      "函数",
      "数组",
      "随机"
    ],
    "description": "如何实现一个 sample 函数，从数组中随机取一个元素"
  },
  "450": {
    "number": 450,
    "title": "【Q442】http3 解决了什么问题",
    "keywords": [
      "http3",
      "UDP",
      "http2",
      "TCP",
      "连接阻塞"
    ],
    "description": "http3 基于 UDP 协议，这是与以前版本的 http 最大的不同，可以解决 http2 TCP 连接阻塞的问题。"
  },
  "451": {
    "number": 451,
    "title": "【Q443】实现一个数组扁平化的函数 flatten ",
    "keywords": [
      "数组扁平化",
      "flatten",
      "实现",
      "函数",
      "reduce"
    ],
    "description": "实现一个数组扁平化的函数 flatten 模拟 Array.prototype.flat 实现，默认展开一层，可传递参数用以展开多层"
  },
  "452": {
    "number": 452,
    "title": "【Q444】介绍 CSS 隐藏页面中某个元素的几种方法",
    "keywords": [
      "CSS",
      "隐藏",
      "元素",
      "方法",
      "display"
    ],
    "description": "介绍 CSS 隐藏页面中某个元素的几种方法"
  },
  "457": {
    "number": 457,
    "title": "【Q449】vue3 中，如何监听数组的变化",
    "keywords": [
      "vue3",
      "监听数组的变化",
      "深层数组",
      "监听"
    ],
    "description": "vue3 中，如何监听数组的变化。比如深层数组如何监听"
  },
  "458": {
    "number": 458,
    "title": "【Q450】Vue 中 nextTick 的实现原理是什么",
    "keywords": [
      "Vue",
      "nextTick",
      "Promise",
      "MutationObserver",
      "setImmediate"
    ],
    "description": "Vue 中 nextTick 的实现原理是什么"
  },
  "459": {
    "number": 459,
    "title": "【Q451】同一进程的线程共享那些资源",
    "keywords": [
      "堆",
      "全局变量",
      "文件"
    ],
    "description": "同一进程的线程共享那些资源"
  },
  "461": {
    "number": 461,
    "title": "【Q453】typeof 与 instanceof 的区别",
    "keywords": [
      "typeof",
      "instanceof",
      "区别",
      "基础数据类型",
      "复杂数据类型"
    ],
    "description": "typeof 用以判断基础数据类型 (null 除外)。instanceOf 借助原型链判断复杂数据类型。"
  },
  "467": {
    "number": 467,
    "title": "【Q459】mysql 中 limit offset 过大导致查询缓慢的原因及解决方案",
    "keywords": [
      "mysql",
      "limit",
      "offset",
      "查询缓慢",
      "解决方案"
    ],
    "description": "mysql 中 limit offset 过大导致查询缓慢的原因及解决方案"
  },
  "471": {
    "number": 471,
    "title": "【Q463】前端如何实现文件上传功能",
    "keywords": [
      "前端",
      "文件上传功能",
      "Blob"
    ],
    "description": "前端如何实现文件上传功能"
  },
  "474": {
    "number": 474,
    "title": "【Q466】在 SSR 项目中如何判断当前环境时服务器端还是浏览器端",
    "keywords": [
      "SSR",
      "判断",
      "当前环境",
      "服务器端",
      "浏览器端"
    ],
    "description": "在 SSR 项目中如何判断当前环境时服务器端还是浏览器端"
  },
  "477": {
    "number": 477,
    "title": "【Q469】HTML 中的 input 标签有哪些 type",
    "keywords": [
      "HTML",
      "input",
      "type",
      "button",
      "checkbox"
    ],
    "description": "HTML 中的 input 标签有哪些 type    button  没有默认行为的按钮，上面显示 value 属性的值，默认为空。    checkbox  复选框，可设为选中或未选中。"
  },
  "479": {
    "number": 479,
    "title": "【Q471】如何自定义滚动条的样式",
    "keywords": [
      "滚动条",
      "样式",
      "伪元素",
      "滑块",
      "轨道"
    ],
    "description": "滚动条相关样式都是伪元素，以 scrollbar 打头，有以下伪元素，从 -webkit 中可见兼容性一般，不过无所谓，现在 Chrome 浏览器占大头。但其实最常用的是以下几个伪元素：滚动条、滑块、轨道，如下滚动条设置成功"
  },
  "481": {
    "number": 481,
    "title": "【Q473】关于模块化，什么是 amd 和 umd",
    "keywords": [
      "模块化",
      "amd",
      "umd",
      "define",
      "cjs"
    ],
    "description": "amd 是一种浏览器中的模块格式，关键字为 define，cjs 是一种 Node 中的模块格式，也是广为人所熟悉的 require/exports。而 umd 是 amd 与 cjs 两种格式的兼容。既可以跑在浏览器，又可以跑在 Node 中"
  },
  "484": {
    "number": 484,
    "title": "【Q476】textarea 如何禁止拉伸",
    "keywords": [
      "textarea",
      "禁止拉伸",
      "CSS",
      "样式",
      "resize"
    ],
    "description": "使用 CSS 样式可以避免拉伸"
  },
  "498": {
    "number": 498,
    "title": "【Q489】如何实现一个函数 lodash.merge",
    "keywords": [
      "实现",
      "函数",
      "lodash.merge",
      "Array.prototype.flatMap",
      "EcmaScript"
    ],
    "description": "如何实现一个函数 lodash.merge Array.prototype.flatMap 已经是 EcmaScript 的标准，看一个例子，它的输出是多少？ 很可惜，不是 [2, 3, 4, 5]，原因在于 flatMap 实际上是先 map 再 flat，实现如下"
  },
  "503": {
    "number": 503,
    "title": "【Q494】如何过滤数组中的 falsy value",
    "keywords": [
      "过滤",
      "数组",
      "falsy value",
      "filter",
      "Boolean"
    ],
    "description": "如何过滤数组中的 falsy value"
  },
  "504": {
    "number": 504,
    "title": "【Q495】如何把一个数组随机打乱",
    "keywords": [
      "数组",
      "随机",
      "打乱",
      "原生实现",
      "lodash"
    ],
    "description": "如何把一个数组随机打乱 使用原生实现，Math.rondom() - 0.5 有时大于0，有时小于0会达成这样的效果 借用 lodash 可更方便"
  },
  "507": {
    "number": 507,
    "title": "【Q498】什么是服务器渲染 (SSR)",
    "keywords": [
      "服务器渲染",
      "renderToString",
      "hydrate"
    ],
    "description": "什么是服务器渲染 (SSR)    1. renderToString  1. hydrate"
  },
  "515": {
    "number": 515,
    "title": "【Q505】JS 中基础数据类型有哪些",
    "keywords": [
      "JS",
      "基础数据类型",
      "number",
      "bigint",
      "string"
    ],
    "description": "JS 中基础数据类型有七种，包括number、bigint、string、undefined、null和symbol。"
  },
  "522": {
    "number": 522,
    "title": "【Q509】如何确认你们项目是否依赖某一个依赖项",
    "keywords": [
      "确认",
      "项目",
      "依赖项",
      "引用",
      "npm"
    ],
    "description": "如何确认你们项目是否依赖某一个依赖项 例: 你们项目中是否引用了 npm 库 semver yarn list | grep xxx"
  },
  "523": {
    "number": 523,
    "title": "【Q510】当你引入某一个依赖项时，你引入的是该依赖下的哪一个文件",
    "keywords": [
      "引入",
      "依赖项",
      "文件"
    ],
    "description": "当你引入某一个依赖项时，你引入的是该依赖下的哪一个文件"
  },
  "524": {
    "number": 524,
    "title": "【Q511】npm workspaces 解决了什么问题",
    "keywords": [
      "npm",
      "workspaces",
      "解决",
      "问题",
      "多个包"
    ],
    "description": "npm workspaces 解决了什么问题 多个包难以互相链接"
  },
  "526": {
    "number": 526,
    "title": "【Q513】有没有使用过 async/await，他们的原理是什么",
    "keywords": [
      "async/await",
      "原理",
      "Generator",
      "自动执行器"
    ],
    "description": "有没有使用过 async/await，他们的原理是什么    原理: 一个 Generator 与一个自动执行器"
  },
  "527": {
    "number": 527,
    "title": "【Q514】什么是闭包，闭包的应用有哪些地方",
    "keywords": [
      "闭包",
      "应用",
      "地方"
    ],
    "description": "什么是闭包，闭包的应用有哪些地方"
  },
  "529": {
    "number": 529,
    "title": "【Q516】HTML 标签有哪些行内元素",
    "keywords": [
      "HTML",
      "标签",
      "行内元素",
      "a",
      "img"
    ],
    "description": "常见的标签有以下几种，可参考 inline element a img picture span input textarea select label"
  },
  "530": {
    "number": 530,
    "title": "【Q517】CSS如何设置一行超出显示省略号",
    "keywords": [
      "CSS",
      "设置",
      "一行",
      "超出",
      "显示"
    ],
    "description": "CSS如何设置一行超出显示省略号"
  },
  "531": {
    "number": 531,
    "title": "【Q518】CSS如何设置多行超出显示省略号",
    "keywords": [
      "CSS",
      "多行超出显示省略号",
      "-webkit-line-clamp"
    ],
    "description": "使用 -webkit-line-clamp 来设置多行超出显示省略号"
  },
  "532": {
    "number": 532,
    "title": "【Q519】如何发布一个全局可执行命令的 npm package",
    "keywords": [
      "发布",
      "全局",
      "可执行命令",
      "npm",
      "package"
    ],
    "description": "如何发布一个全局可执行命令的 npm package"
  },
  "538": {
    "number": 538,
    "title": "【Q525】flex 布局中 order 有何作用",
    "keywords": [
      "flex",
      "布局",
      "order",
      "作用"
    ],
    "description": "order属性定义Flex布局中子元素的排列顺序，数值越小，排列越靠前，默认为0。"
  },
  "540": {
    "number": 540,
    "title": "【Q527】解构赋值一个数组，a 取第一项默认值为 3，c取剩下的值组成数组",
    "keywords": [
      "解构赋值",
      "数组",
      "默认值",
      "剩下的值",
      "组成数组"
    ],
    "description": "解构赋值一个数组，a 取第一项默认值为 3，c取剩下的值组成数组"
  },
  "543": {
    "number": 543,
    "title": "【Q530】HTML 中有哪些语义化标签",
    "keywords": [
      "HTML",
      "语义化标签",
      "header",
      "footer",
      "main"
    ],
    "description": "HTML 中有哪些语义化标签。见文档 HTML Elements - MDN。header、footer、main 是其中的一些标签。"
  },
  "545": {
    "number": 545,
    "title": "【Q532】简述 css 中 position 的值",
    "keywords": [
      "css",
      "position",
      "static",
      "relative",
      "absolute"
    ],
    "description": "简述 css 中 position 的值"
  },
  "546": {
    "number": 546,
    "title": "【Q533】什么是 BFC",
    "keywords": [
      "BFC",
      "生成",
      "作用",
      "应用",
      "块级格式化上下文"
    ],
    "description": "什么是 BFC  它是如何生成的  它有什么作用及应用  块级格式化上下文，Block Formatting Context"
  },
  "547": {
    "number": 547,
    "title": "【Q534】CSS 如何实现固定长宽比的元素",
    "keywords": [
      "CSS",
      "固定长宽比",
      "元素",
      "padding",
      "aspect-ratio"
    ],
    "description": "过去的解决方案是使用 padding。一个元素的 padding 如若设置为百分比，则代表的是以父元素宽度为基准，根据这个原理，可设置长宽比。但实际上意义有限，毕竟你把 padding 给占了，content 无任何区域。现代化的解决方案是使用长宽比的 CSS 属性: aspect-ratio"
  },
  "548": {
    "number": 548,
    "title": "【Q535】rem、em、vw、vh 的值各是什么意思",
    "keywords": [
      "rem",
      "em",
      "vw",
      "vh",
      "CSS Data Type",
      "length"
    ],
    "description": "他们同属于 CSS Data Type 中的 [length]，见文档 length - MDN。rem: 根据根元素(即 html)的 font-size。em: 根据自身元素的 font-size。vw: viewport width。vh: viewport height。"
  },
  "550": {
    "number": 550,
    "title": "【Q537】line-height 的值分别取 [2, 2em, 200%] 有什么区别?",
    "keywords": [
      "line-height",
      "值",
      "取",
      "区别",
      "代码"
    ],
    "description": "line-height 的值分别取 2, 2em, 200% 有什么区别?"
  },
  "552": {
    "number": 552,
    "title": "【Q538】你是如何保障你们项目质量的",
    "keywords": [
      "lint",
      "type",
      "test",
      "code review",
      "git hooks"
    ],
    "description": "你是如何保障你们项目质量的"
  },
  "553": {
    "number": 553,
    "title": "【Q539】Javascript 数组中有那些方法可以改变自身，那些不可以",
    "keywords": [
      "Javascript",
      "数组",
      "方法",
      "改变自身",
      "不可以"
    ],
    "description": "Javascript 数组中有那些方法可以改变自身，那些不可以"
  },
  "554": {
    "number": 554,
    "title": "【Q540】如何判断一个数组是否包含某个值",
    "keywords": [
      "判断",
      "数组",
      "包含",
      "值",
      "includes"
    ],
    "description": "如何判断一个数组是否包含某个值"
  },
  "555": {
    "number": 555,
    "title": "【Q541】如何判断字符串包含某个子串",
    "keywords": [
      "字符串",
      "包含",
      "子串",
      "判断",
      "includes"
    ],
    "description": "如何判断字符串包含某个子串"
  },
  "556": {
    "number": 556,
    "title": "【Q542】DOM 中如何阻止事件默认行为，如何判断事件否可阻止？",
    "keywords": [
      "DOM",
      "事件默认行为",
      "判断事件是否可阻止",
      "preventDefault",
      "cancelable"
    ],
    "description": "DOM 中如何阻止事件默认行为，如何判断事件否可阻止？追问：有哪些事件可阻止，哪些事件不可阻止? e.preventDefault(): 取消事件 e.cancelable: 事件是否可取消 如果 addEventListener 第三个参数 { passive: true}，preventDefault 将会会无效"
  },
  "558": {
    "number": 558,
    "title": "【Q544】什么是事件委托，e.currentTarget 与 e.target 有何区别",
    "keywords": [
      "事件委托",
      "e.currentTarget",
      "e.target",
      "React",
      "Root Element"
    ],
    "description": "事件委托指当有大量子元素触发事件时，将事件监听器绑定在父元素进行监听，此时数百个事件监听器变为了一个监听器，提升了网页性能。另外，React 把所有事件委托在 Root Element，用以提升性能。"
  },
  "560": {
    "number": 560,
    "title": "【Q546】浏览器中 cookie 有哪些字段",
    "keywords": [
      "浏览器",
      "cookie",
      "字段",
      "Domain",
      "Path"
    ],
    "description": "浏览器中 cookie 有哪些字段"
  },
  "562": {
    "number": 562,
    "title": "【Q548】DOM 中 Element 与 Node 有何区别",
    "keywords": [
      "DOM",
      "Element",
      "Node"
    ],
    "description": "DOM 中 Element 与 Node 有何区别"
  },
  "563": {
    "number": 563,
    "title": "【Q549】如何判断某一个值是数组",
    "keywords": [
      "判断",
      "值",
      "数组",
      "实现",
      "下载量"
    ],
    "description": "如何判断某一个值是数组    完美实现一个月下载量超过一个亿的包: isarray    js  const isArray = Array.isArray || list => ({}).toString.call(list) === '[object Array]'"
  },
  "567": {
    "number": 567,
    "title": "【Q553】Grid 布局的优势在哪里",
    "keywords": [
      "Grid",
      "布局",
      "优势",
      "响应式"
    ],
    "description": "Grid 布局的优势在哪里 响应式！"
  },
  "571": {
    "number": 571,
    "title": "【Q556】如何封装一个支持过期时间的 localStorage",
    "keywords": [
      "封装",
      "支持过期时间",
      "localStorage",
      "数据结构",
      "过期时间"
    ],
    "description": "设置如下数据结构，当用户存储数据时，存储至 __value 字段。并将过期时间存储至 __expires 字段。而当每次获取数据时，判断当前时间是否已超过 __expires 过期时间，如果超过，则返回 undefined，并删除该数据。"
  },
  "573": {
    "number": 573,
    "title": "【Q558】如何统计当前页面出现的所有标签",
    "keywords": [
      "统计",
      "当前页面",
      "标签",
      "document.querySelectorAll",
      "document.getElementsByTagName"
    ],
    "description": "如何统计当前页面出现的所有标签，使用纯文本输出，移除等特殊字符，总结提炼内容将作为 description 字段，并列出五个左右的关键词，作为 keywords 字段。文本内容如下：【Q558】如何统计当前页面出现的所有标签"
  },
  "574": {
    "number": 574,
    "title": "【Q559】如何监听 localStorage 的变动",
    "keywords": [
      "监听",
      "localStorage",
      "变动"
    ],
    "description": "如何监听 localStorage 的变动"
  },
  "575": {
    "number": 575,
    "title": "【Q560】Data URL 的应用场景及如何生成",
    "keywords": [
      "Data URL",
      "应用场景",
      "生成",
      "MIME类型",
      "二进制数据"
    ],
    "description": "Data URLs 由四个部分组成：前缀(data:) 指示数据类型的MIME类型 如果二进制数据则为可选的base64标记，比如图片 数据"
  },
  "576": {
    "number": 576,
    "title": "【Q561】实现一个 inherits 函数进行继承",
    "keywords": [
      "实现",
      "inherits",
      "函数",
      "继承",
      "Dog"
    ],
    "description": "实现一个 inherits 函数进行继承 使用方法如 inherits(Dog, Animal); Dog 对 Animal 进行了继承"
  },
  "577": {
    "number": 577,
    "title": "【Q562】WeakMap 与垃圾回收有何关系",
    "keywords": [
      "WeakMap",
      "垃圾回收",
      "关系",
      "引用对象",
      "基础数据类型"
    ],
    "description": "WeakMap 与垃圾回收有何关系    WeakMap 与 Map 有亮点不同    1. 键值只能为引用对象，无法使用基础数据类型  2. 弱引用，无法枚举，因此无 .entries() 方法"
  },
  "578": {
    "number": 578,
    "title": "【Q563】什么是媒体查询，JS 可以监听媒体查询吗",
    "keywords": [
      "媒体查询",
      "JS",
      "监听"
    ],
    "description": "什么是媒体查询，JS 可以监听媒体查询吗"
  },
  "583": {
    "number": 583,
    "title": "【Q568】为何 0.1+0.2 不等于 0.3，应如何做相等比较",
    "keywords": [
      "0.1+0.2",
      "不等于",
      "相等比较",
      "二进制",
      "精度的损失"
    ],
    "description": "为何 0.1+0.2 不等于 0.3，应如何做相等比较"
  },
  "585": {
    "number": 585,
    "title": "【Q570】浏览器中如何读取二进制信息",
    "keywords": [
      "浏览器",
      "读取",
      "二进制信息"
    ],
    "description": "浏览器中如何读取二进制信息"
  },
  "587": {
    "number": 587,
    "title": "【Q572】关于暂时性死域，判断以下代码输出",
    "keywords": [
      "暂时性死域",
      "let",
      "const",
      "声明变量",
      "报错"
    ],
    "description": "暂时性死域的问题，对于 let/const 声明变量之前被使用的话会报错"
  },
  "588": {
    "number": 588,
    "title": "【Q573】关于词法作用域，判断以下代码输出",
    "keywords": [
      "词法作用域",
      "代码输出",
      "变量",
      "嵌套作用域",
      "ReferenceError"
    ],
    "description": "由于 js 为词法作用域(Lexical Scope)，访问某个变量时，先在当前作用域中查找，如果查找不到则在嵌套作用域中查找，直到找到。如果找不到，则报 ReferenceError。"
  },
  "589": {
    "number": 589,
    "title": "【Q574】关于 this，判断以下代码输出",
    "keywords": [
      "this",
      "函数",
      "严格模式",
      "输出",
      "undefined"
    ],
    "description": "只有在存在 this 的函数中设置严格模式，this 为 undefined。因此此时会正常输出。"
  },
  "590": {
    "number": 590,
    "title": "【Q575】关于 new，判断以下代码输出",
    "keywords": [
      "new",
      "代码输出",
      "F",
      "a"
    ],
    "description": "关于 new，判断以下代码输出    function F () {    this.a = 3;    return {      a: 4;    }  }    const f = new F();  console.log(f.a);    4"
  },
  "592": {
    "number": 592,
    "title": "【Q577】关于简单的事件循环，判断以下代码输出",
    "keywords": [
      "事件循环",
      "代码输出",
      "setTimeout",
      "Promise.resolve",
      "主线程执行栈"
    ],
    "description": "关于简单的事件循环，判断以下代码输出次序"
  },
  "597": {
    "number": 597,
    "title": "【Q581】箭头函数和普通函数的区别",
    "keywords": [
      "箭头函数",
      "普通函数",
      "区别"
    ],
    "description": "箭头函数无 this，无 prototype"
  },
  "598": {
    "number": 598,
    "title": "【Q582】什么是 URL 编码 (URL Encode)",
    "keywords": [
      "URL 编码",
      "URL Encode"
    ],
    "description": "什么是 URL 编码 (URL Encode)"
  },
  "601": {
    "number": 601,
    "title": "【Q585】如何确保你们的项目开启了 gzip",
    "keywords": [
      "项目",
      "开启",
      "gzip",
      "响应头",
      "内容"
    ],
    "description": "如何确保你们的项目开启了 gzip 当你们的项目上线后，如何查看它是否开启了 gzip 在响应头中查看是否有以下值：content-encoding: gzip"
  },
  "604": {
    "number": 604,
    "title": "【Q588】什么是 HSTS ",
    "keywords": [
      "HSTS"
    ],
    "description": "什么是 HSTS"
  },
  "606": {
    "number": 606,
    "title": "【Q590】React 中什么是合成事件",
    "keywords": [
      "React",
      "合成事件",
      "API",
      "浏览器差异",
      "事件委托"
    ],
    "description": "React 中合成事件提供统一的 API，抹平各大浏览器差异。所有事件绑定在 React Root Element 进行事件委托。"
  },
  "611": {
    "number": 611,
    "title": "【Q595】React 中监听 input 的 onChange 事件的原生事件是什么",
    "keywords": [
      "React",
      "onChange",
      "原生事件",
      "input",
      "监听"
    ],
    "description": "React 中监听 input 的 onChange 事件的原生事件是什么"
  },
  "614": {
    "number": 614,
    "title": "【Q598】如何实现一个深比较的函数 deepEqual",
    "keywords": [
      "实现",
      "深比较",
      "函数",
      "deepEqual"
    ],
    "description": "如何实现一个深比较的函数 deepEqual"
  },
  "616": {
    "number": 616,
    "title": "【Q600】在 React hooks 中如何模拟 forceUpdate",
    "keywords": [
      "React hooks",
      "模拟",
      "forceUpdate"
    ],
    "description": "在 React hooks 中如何模拟 forceUpdate"
  },
  "619": {
    "number": 619,
    "title": "【Q602】如何把对象转化为 key/value 的二维数组",
    "keywords": [
      "对象",
      "转化",
      "key/value",
      "二维数组",
      "Object.entries"
    ],
    "description": "如何把对象转化为 key/value 的二维数组"
  },
  "620": {
    "number": 620,
    "title": "【Q603】在 JS 中如何监听 Object 某个属性值的变化",
    "keywords": [
      "JS",
      "监听",
      "Object",
      "属性值",
      "变化"
    ],
    "description": "在 JS 中可以使用两种方式监听属性值变化"
  },
  "626": {
    "number": 626,
    "title": "【Q608】请简介 CSS 的盒模型",
    "keywords": [
      "CSS",
      "盒模型",
      "box-sizing",
      "content-box",
      "border-box"
    ],
    "description": "CSS 的盒模型主要包括以下两种，可通过 box-sizing 属性进行配置：content-box：默认属性。width 只包含 content，border-box：width 包含 (content、padding、border)"
  },
  "627": {
    "number": 627,
    "title": "【Q609】请简述重新登录 refresh token 的原理",
    "keywords": [
      "重新登录",
      "refresh token",
      "原理"
    ],
    "description": "请简述重新登录 refresh token 的原理"
  },
  "628": {
    "number": 628,
    "title": "【Q610】了解什么是 JSBridge 吗",
    "keywords": [
      "JSBridge"
    ],
    "description": "了解什么是 JSBridge"
  },
  "634": {
    "number": 634,
    "title": "【Q616】在 nginx 中如何配置 HTTP 协商缓存",
    "keywords": [
      "nginx",
      "配置",
      "HTTP",
      "协商缓存",
      "Cache-Control"
    ],
    "description": "在 nginx 中如何配置 HTTP 协商缓存 Nginx 中在 1.3.3 后已默认开启了协商缓存，手动配置如下：location /public { add_header Cache-Control no-cache; etag on; if_modified_since exact; }"
  },
  "635": {
    "number": 635,
    "title": "【Q617】什么是 base64 与 URL Safe base64",
    "keywords": [
      "base64",
      "URL Safe base64"
    ],
    "description": "base64 由 0-9、A-Z、a-z 及 +、/ 组成，但是在 URL 中使用 base64 时，/ 容易与路径符号发生冲突。因此，URL Safe Base64 将 + 替换为 _，/ 替换为 -。"
  },
  "638": {
    "number": 638,
    "title": "【Q620】CSS 有哪些选择器",
    "keywords": [
      "CSS",
      "选择器",
      ":hover",
      ":active",
      ":first-child"
    ],
    "description": "CSS 有哪些选择器 :hover :active :first-child"
  },
  "639": {
    "number": 639,
    "title": "【Q621】CSS 有哪些伪类与伪元素选择器",
    "keywords": [
      "CSS",
      "伪类",
      "伪元素",
      "选择器",
      "MDN"
    ],
    "description": "CSS 有哪些伪类与伪元素选择器"
  },
  "641": {
    "number": 641,
    "title": "【Q623】如何判断一个数值为整数",
    "keywords": [
      "判断",
      "数值",
      "整数",
      "ES6",
      "ES5"
    ],
    "description": "如何判断一个数值为整数"
  },
  "649": {
    "number": 649,
    "title": "【Q631】在 Node 中如何读写文件",
    "keywords": [
      "Node",
      "读写文件",
      "open",
      "read",
      "close"
    ],
    "description": "在 Node 中如何读写文件"
  },
  "651": {
    "number": 651,
    "title": "【Q633】Node 中服务端框架如何解析 http 的请求体 body",
    "keywords": [
      "Node",
      "服务端框架",
      "解析",
      "http",
      "请求体"
    ],
    "description": "在 Node 服务中，通过 http.createServer 接收到的 req 为可读流，对流进行读取数据。"
  },
  "653": {
    "number": 653,
    "title": "【Q635】请输出 100 以内的菲波那切数列",
    "keywords": [
      "菲波那切数列",
      "输出",
      "100",
      "纯文本",
      "关键词"
    ],
    "description": "请输出 100 以内的菲波那切数列"
  },
  "662": {
    "number": 662,
    "title": "【Q644】实现一个异步的 sum/add",
    "keywords": [
      "异步",
      "sum",
      "add",
      "并发次数",
      "promise.map"
    ],
    "description": "请实现以下 sum 函数，只能调用 add 进行实现"
  },
  "664": {
    "number": 664,
    "title": "【Q646】如何禁止打开浏览器控制台",
    "keywords": [
      "禁止打开浏览器控制台",
      "github",
      "AEPKILL",
      "devtools-detector"
    ],
    "description": "如何禁止打开浏览器控制台"
  },
  "666": {
    "number": 666,
    "title": "【Q648】如何把一个数组 Array 转化为迭代器 Iterable",
    "keywords": [
      "数组",
      "迭代器",
      "转化",
      "Iterable",
      "next"
    ],
    "description": "如何把一个数组 Array 转化为迭代器 Iterable"
  },
  "672": {
    "number": 672,
    "title": "【Q654】css加载会阻塞DOM树的解析和渲染吗",
    "keywords": [
      "css加载",
      "阻塞DOM树",
      "解析",
      "渲染"
    ],
    "description": "css加载会阻塞DOM树的解析和渲染吗"
  },
  "675": {
    "number": 675,
    "title": "【Q657】实现一个 composeLeft/flow(从左向右) 函数，进行函数合成",
    "keywords": [
      "实现",
      "composeLeft",
      "flow",
      "函数合成",
      "lodash.flow"
    ],
    "description": "实现一个 composeLeft/flow(从左向右) 函数，进行函数合成，类似于 lodash.flow"
  },
  "677": {
    "number": 677,
    "title": "【Q659】在 React Hooks 中实现 usePreviouseValue 取上次渲染的值",
    "keywords": [
      "React Hooks",
      "usePreviouseValue",
      "渲染的值"
    ],
    "description": "在 React Hooks 中实现 usePreviouseValue 取上次渲染的值"
  },
  "680": {
    "number": 680,
    "title": "【Q662】TCP 是如何进行拥塞控制的",
    "keywords": [
      "TCP",
      "拥塞控制",
      "Reno",
      "慢启动",
      "拥塞避免"
    ],
    "description": "TCP 是如何进行拥塞控制的，可参考文章: <https://zhuanlan.zhihu.com/p/76023663> Reno，慢启动，拥塞避免，快重传，快恢复"
  },
  "682": {
    "number": 682,
    "title": "【Q664】请简述下 Node 与浏览器环境中的事件循环",
    "keywords": [
      "Node",
      "浏览器环境",
      "事件循环"
    ],
    "description": "请简述下 Node 与浏览器环境中的事件循环"
  },
  "685": {
    "number": 685,
    "title": "【Q667】简述下 WebWorker，它如何进行通信",
    "keywords": [
      "WebWorker",
      "通信"
    ],
    "description": "简述下 WebWorker，它如何进行通信"
  },
  "686": {
    "number": 686,
    "title": "【Q668】JS 中异步任务为何分为微任务与宏任务",
    "keywords": [
      "JS",
      "异步任务",
      "微任务",
      "宏任务"
    ],
    "description": "JS 中异步任务为何分为微任务与宏任务"
  },
  "687": {
    "number": 687,
    "title": "【Q669】在 CSS 中，使用 rem 作为单位有何缺点",
    "keywords": [
      "CSS",
      "rem",
      "单位",
      "缺点"
    ],
    "description": "在 CSS 中，使用 rem 作为单位有何缺点"
  },
  "688": {
    "number": 688,
    "title": "【Q670】如何提高首屏渲染时间？",
    "keywords": [
      "提高首屏渲染时间"
    ],
    "description": "如何提高首屏渲染时间"
  },
  "689": {
    "number": 689,
    "title": "【Q671】浏览器中监听事件函数 addEventListener 第三个参数有那些值",
    "keywords": [
      "浏览器",
      "监听事件函数",
      "addEventListener",
      "第三个参数",
      "MDN"
    ],
    "description": "浏览器中监听事件函数 addEventListener 第三个参数有那些值。详见 MDN https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"
  },
  "692": {
    "number": 692,
    "title": "【Q673】求给定数组中 N 个数相加之和为 sum 所有可能集合",
    "keywords": [
      "数组",
      "N个数相加",
      "和",
      "可能集合",
      "补充代码"
    ],
    "description": "求给定数组中 N 个数相加之和为 sum 所有可能集合，请补充以下代码"
  },
  "694": {
    "number": 694,
    "title": "【Q675】浏览器中 Frame 与 Event Loop 的关系是什么",
    "keywords": [
      "浏览器",
      "Frame",
      "Event Loop",
      "关系"
    ],
    "description": "浏览器中 Frame 与 Event Loop 的关系是什么"
  },
  "699": {
    "number": 699,
    "title": "【Q680】在 Node 中如何读取大文件的内容",
    "keywords": [
      "Node",
      "读取",
      "大文件",
      "内容",
      "createReadStream"
    ],
    "description": "在 Node 中如何读取大文件的内容"
  },
  "704": {
    "number": 704,
    "title": "【Q685】如何遍历一个对象",
    "keywords": [
      "遍历",
      "对象",
      "Reflect.ownKeys",
      "Object.keys"
    ],
    "description": "如何遍历一个对象    1. Reflect.ownKeys({ a: 3, b: 4})  2. Object.keys({ a: 3, b: 4 })"
  },
  "705": {
    "number": 705,
    "title": "【Q686】网站性能优化中，如何对小图片进行优化",
    "keywords": [
      "网站性能优化",
      "小图片",
      "优化"
    ],
    "description": "网站性能优化中，如何对小图片进行优化"
  },
  "706": {
    "number": 706,
    "title": "【Q687】https 如何被抓包，原理是什么",
    "keywords": [],
    "description": "https 如何被抓包，原理是什么"
  },
  "713": {
    "number": 713,
    "title": "【Q692】什么是协变与逆变",
    "keywords": [
      "协变与逆变",
      "父/子型别关系",
      "型别构造器",
      "构造出的多个复杂型别",
      "父/子型别关系的用语"
    ],
    "description": "协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。"
  },
  "716": {
    "number": 716,
    "title": "【Q695】Flex 布局中的 flex-basis 与 width 有何区别",
    "keywords": [
      "Flex",
      "布局",
      "flex-basis",
      "width",
      "区别"
    ],
    "description": "当 flex-direction 为 column 时，主轴为纵轴，此时 flex-basis 与 height 对应。flex-basis 的值为理想情况，而在实际情况中可能被压缩。"
  },
  "720": {
    "number": 720,
    "title": "【Q698】有没有使用过 Node 的 inspect 这个核心模块",
    "keywords": [
      "Node",
      "inspect",
      "核心模块",
      "文档",
      "Node Inspector API"
    ],
    "description": "有没有使用过 Node 的 inspect 这个核心模块 文档 Node Inspector API"
  },
  "730": {
    "number": 730,
    "title": "【Q706】typescript 中 interface 与 type 有何区别",
    "keywords": [
      "typescript",
      "interface",
      "type",
      "区别",
      "types"
    ],
    "description": "typescript 中 interface 与 type 有何区别"
  },
  "733": {
    "number": 733,
    "title": "【Q708】webpack 中的 code spliting 是如何动态加载 chunk 的？",
    "keywords": [
      "webpack",
      "code spliting",
      "chunk",
      "import()",
      "moduleIds"
    ],
    "description": "一个 webpack 的运行时，包括最重要的两个数据结构：__webpack_modules__ 和 __webpack_require__。code spliting 是通过 import() 实现的。"
  },
  "734": {
    "number": 734,
    "title": "【Q709】core-js 是做什么用的？",
    "keywords": [
      "core-js",
      "polyfill",
      "ES",
      "API",
      "垫片"
    ],
    "description": "core-js 是关于 ES 标准最出名的 polyfill，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。你也许每天都与它打交道，但你毫不知情。由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本越高，垫片越少，体积就会越小。"
  },
  "742": {
    "number": 742,
    "title": "【Q717】如何检测出你们安装的依赖是否安全",
    "keywords": [
      "安装的依赖",
      "安全",
      "npm install",
      "库",
      "挖矿"
    ],
    "description": "如何检测出你们安装的依赖是否安全    如何确保所有 npm install 的依赖都是安全的？    当有一个库偷偷在你的笔记本后台挖矿怎么办？    比如，不久前一个周下载量超过八百万的库被侵入，它在你的笔记本运行时会偷偷挖矿。"
  },
  "746": {
    "number": 746,
    "title": "【Q720】请描述 node_modules 的目录结构(拓扑结构)",
    "keywords": [
      "node_modules",
      "目录结构",
      "拓扑结构",
      "npm",
      "库"
    ],
    "description": "请描述 node_modules 的目录结构(拓扑结构)"
  },
  "793": {
    "number": 793,
    "title": "【Q747】如何实现一个 omit/omitBy 函数",
    "keywords": [
      "omit",
      "omitBy",
      "复杂度",
      "性能",
      "遍历"
    ],
    "description": "如何实现一个 omit/omitBy 函数。omit 的复杂度过高，性能较差。应遍历 keys，逐一删除。另外，ts 直接用 Omit 这个内置 type。"
  },
  "794": {
    "number": 794,
    "title": "【Q748】在 babel 编译为低版本 ES 时，为何能够编译可选链之类语法，但无法编译 API",
    "keywords": [
      "babel",
      "编译",
      "低版本",
      "ES",
      "可选链"
    ],
    "description": "在 babel 编译为低版本 ES 时，为何能够编译可选链之类语法，但无法编译 API"
  }
}